{
  "source_file": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning.json",
  "lecture_name": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning",
  "course": "Generative AI",
  "total_chunks": 4,
  "chunks": [
    {
      "id": "transcript_generative_ai_generative_ai_3강_text_generati_c000_ad346f",
      "content": "[강의 녹취록] 과목: Generative AI | 강의: 3강 | 제목: Text Generation 2 Parameter Efficient Tuning\n\n안녕하세요. 고려대학교 산업경영공학부 강필성 교수입니다. 세 번째 강의로서 텍스트 제너레이션의 두 번째 파트 파라미터 에피션트 튜닝이라는 주제로 강의를 진행하도록 하겠습니다. 우선 파라미터 에피션트 튜닝이라는 타픽을 가지고 온 이유에 대해서 먼저 설명을 드려야 될 것 같습니다. LLM의 발전과 파라미터 에피전트 파인 튜닝의 방법론의 중요성을 설명을 드리고요. 이 PFT 파라미터 에피전트 파인 튜닝을 하는 4가지의 방법, 첫 번째 어댑터 두 번째 프리픽스 튜닝, 세 번째 프롬프트 튜닝, 네 번째 로우 랭크 어댑테이션까지 설명을 드리고 마무리하겠습니다. LLM의 발전과 파라미터 에피션 파인튜닝 방법론의 중요성을 먼저 말씀을 드리겠습니다. LLM은 트랜스포머 구조 기반의 언어 모델들이 다양한 NLP 테스크에서 훌륭한 성능 향상을 보인 이후로 제너럴 퍼포즈를 위한 라즈 랭귀지 모델들이 제한되어 왔습니다. 이를 통해서 학습 데이터와 모델의 파라미터 사이즈가 커질수록 성능이 점점 더 높아지고 왔다라는 것을 알 수가 있습니다. 그런데 이러한 언어 모델을 활용하기 위해서는 일반적으로 범용 웹 데이터를 기반으로 해서 사전 학습을 수행하고 그 이후에 다운스트림 테스크에 맞추어서 파인튜닝을 진행해 왔습니다. 이러한 학습 방법은 특정한 테스크의 성능 향상을 보장한다라는 장점은 있습니다. 그렇기 때문에 언어 모델을 타겟 테스크에 맞게 어댑팅하거나 파인 튜닝 하는 방법론들이 우수한 성능을 기록해 왔습니다. 그래서 이 전통적인 방식에서는 세 가지의 방법으로 유형화할 수가 있는데요. 퓨처 베이스 어프로치 같은 경우에는 사전 학습 모델로부터 임베딩을 먼저 추출을 하고 이 추출된 인베딩으로부터 우리가 원하는 어떠한 테스크를 수행하기 위한 클래식 파이어를 학습하는 방법이 있습니다. 두 번째는 파인 튜닝의 첫 번째 단계로서 사전 학습된 모형에서부터 가장 마지막 단계에 해당하는 아웃풋 레이어를 업데이트하는 방법이 있고요. 세 번째인 두 번째 파인튜닝 단계에서는 모든 레이어들을 업데이트하는 방식이 있습니다. 그래서 보시면 프로즌이라고 되어 있는 거는 사전 학습을 통해서 학습된 웨이트들 파라미터들을 고정을 시키는데 여기에 있는 파인 튜닝의 첫 번째 단계는 후반부를 업데이트를 시킨다면 파인 튜닝의 두 번째 단계는 모든 레이어에 대해서 업데이트를 수행하게 됩니다. 이러한 방법을 성능과 학습 효율이라는 관점으로 나누어 볼 때 모든 파라미터를 학습하는 경우가 가장 높은 성능을 기록하는 것을 확인할 수가 있습니다. 그래서 성능 자체는 가장 높지만 트레이닝 에피션시가 왼쪽이 빠른 거고 오른쪽이 느린 거니까 당연히 모든 이 파라미터들을 학습할 때가 속도는 가장 느리겠죠. 이러한 이제 단점을 이제 극복하기 위해서 인 컨텍스트 러닝 icl이라는 개념이 이제 나왔습니다. gpt3가 발표된 이후에는 파인 튜닝이 없어도 언어 모델을 쉽게 활용할 수 있게 되었고요. 타겟 테스크에 대해서 몇 가지의 예시를 주어 주고 모델에 입력해 주게 될 경우에는 모델을 튜닝하지 않고 쉽게 문제를 풀 수 있게 되었다라는 뜻입니다. 이전 강의에서도 잠깐 언급했었던 제로 샷 같은 경우에는 태스크만 주는 것이고요. 원 샷은 이그젬플 하나 주는 것, 퓨 샷은 여러 개 주는 것을 의미합니다. 이러한 이제 컨벤셔널 어프로치들은 모델을 지속적으로 추가 학습하는 과정 여기서는 시퀀셜 트랜스퍼 러닝 패러다임이라고 표현하는데요. 언어 모델이 기존에 학습한 정보를 있는 현상 캐타스트로픽 포게팅이라는 표현을 쓰기도 합니다. 야기합니다. 또한 모델이 모든 파라미터를 새로운 데이터에 대해서 항상 학습하는 것이 정답은 아니라는 것도 밝혀져 있습니다. 그리고 컨벤셔널 어프로치는 모델의 크기가 점점 커짐에 따라서 모델의 전체 파라미터를 학습하는 것이 어려워지고요. 다운 스트림 테스크마다 독립적으로 학습된 모델을 저장하고 배포할 때마다 막대한 시간과 컴퓨팅 자원이 필요해진다라는 문제점이 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning.json",
        "lecture_name": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning",
        "course": "Generative AI",
        "lecture_num": "3강",
        "lecture_title": "Text Generation 2 Parameter Efficient Tuning",
        "chunk_idx": 0,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:ae603a749437b2b440a17e31cc5d92d8016ac6cb8ec12c6c5e4190cc40b6203c"
      },
      "token_estimate": 1094,
      "char_count": 2012
    },
    {
      "id": "transcript_generative_ai_generative_ai_3강_text_generati_c001_d905e3",
      "content": "[Generative AI] [Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning\n\n다. 야기합니다. 또한 모델이 모든 파라미터를 새로운 데이터에 대해서 항상 학습하는 것이 정답은 아니라는 것도 밝혀져 있습니다. 그리고 컨벤셔널 어프로치는 모델의 크기가 점점 커짐에 따라서 모델의 전체 파라미터를 학습하는 것이 어려워지고요. 다운 스트림 테스크마다 독립적으로 학습된 모델을 저장하고 배포할 때마다 막대한 시간과 컴퓨팅 자원이 필요해진다라는 문제점이 있습니다. 그래서 아까 2절에 설명드렸던 신뢰성 측면에서 봤을 때 인 컨텍스트 러닝은 모델을 따로 튜닝할 필요가 없이 문제를 효과적으로 풀이할 수 있고요. 인컨텍스트 러닝을 위해서 단순히 데모스트레이션과 테스트 인풋만을 모델의 입력으로 사용을 하게 되면 가능해진다라는 장점이 있습니다. 하지만 몇몇 경우에는 랜덤한 레이블을 넣어주더라도 문제를 잘 해결한다라는 연구 결과가 존재를 합니다. 이 말이 무슨 얘기냐 하면 데모스트레이션에 대해서 단순히 어떤 긍정과 부정에 대해서 긍정과 부정도 아닌 이상한 레이블을 넣었음에도 불구하고 이 테스트 인풋을 주어졌을 때 정답을 맞출 수 있다라는 얘기입니다. 바꿔 말하면 수학 문제와 정답 쌍을 주고 공부를 시키는데 문제에 대한 전혀 엉뚱한 답을 주었음에도 정답을 풀어낼 수 있다라는 이러한 연구 결과가 존재한다는 뜻이죠. 랜덤 레이블과 골드 레이블이라는 거는 실제로 골드 레이블은 정답을 준 것이고요. 데모가 없다라는 거는 데모스트레이션이 존재하지 않는다라는 뜻이고, 랜덤 레이블은 정답이 아닌 레이블을 주었음에도 불구하고 디모스트레이션이 없었을 때보다 훨씬 더 잘하는 것을 보실 수가 있겠습니다. 파라미터가 많은 라즐 랭귀지 모델을 효율적으로 학습할 할 수 있는 방법이 없을까라는 질문이 등장을 하는 거죠. 여기에 대한 답이 바로 파라미터 에피션트 파임 튜닝입니다. 그래서 단어를 하나씩 하나씩 살펴보자면 무엇을 하는 것이냐 언어 모델을 파인 튜닝 하겠다. 미세 조정을 더 하겠다라는 것이고요. 근데 어떻게 할 것이냐 파라미터의 에피션트한 막 하는 게 아니라 최대한 효율적으로 하겠다라는 뜻입니다. 그래서 지금부터는 용어가 길기 때문에 파라미터 에피션 파인튜닝을 줄여서 피프티라고 부르도록 하겠습니다. 이런 peft는 모델의 모든 파라미터를 학습하지 않고 일부 파라미터만 파인튜닝 하는 방법론으로서 2019년도부터 효과적인 학습을 위해서 다양한 방법론들이 제한이 되고 있습니다. 가장 대표적인 방법론들은 아래의 네 가지의 접근 방식입니다. 트랜스폼 모델의 모든 파라미터를 지금 우리가 사용하고 있는 LM 모델은 거의 대부분 트랜스포머의 디코더에 기반한 모델이기 때문에 트랜스포머 모델의 모든 파라미터를 업데이트하지 않고 각 방법론 별로 소량의 파라미터를 효과적으로 업데이트하는 방식입니다. 여기서 mha는 멀티헤드 어텐션이고 FFN은 피드 포드 뉴럴 네트워크이라는 트랜스포머의 인코더 디코더 블록에서의 컴포넌트라고 보시면 어댑터 튜닝은 멀티 헤드 어텐션과 피드 포드 뉴얼 네트워크에다가 어댑터라고 하는 모듈을 붙인 것이고요. 프리픽스 튜닝 같은 경우에는 각각의 레이어에 프리픽스라고 하는 항목을 붙여주는 것, 프롬프 튜닝은 인풋의 프롬프트에다가 무엇인가 벡터를 붙여주는 것. 로우 랭크 어댑테이션은 레이어별로 훨씬 더 낮은 랭크로 벡터를 행렬을 전환을 해서 연산량을 줄여주는 것을 의미합니다. 이 PFT에 대해서 하나씩 구체적으로 설명을 드리겠습니다. 첫 번째 어댑터입니다. 어댑터는 기존에 이미 학습이 완료된 모델에 각 레이어의 학습이 가능한 피드 포드 네트워크를 삽입하는 구조입니다. 어댑터 레이어는 트랜스포머의 벡터를 더 작은 차원으로 압축을 하고 비선형 변환을 거쳐서 원래 차원으로 복원하는 병목 구조를 가지고 있습니다. 오른쪽에서 이제 보시자면 왼쪽은 트랜스포머라고 본다면 오른쪽이 어댑터 레이어인데 피드 포드 레이어를 통해서 훨씬 더 벡터를 작은 크기로 압축을 하고 비선형 변환을 한번 한 다음에 원래 차원으로 복원하는 겁니다. 이거 굳이 왜 하느냐 결국은 모델의 파라미터를 줄이기 위해서입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning.json",
        "lecture_name": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning",
        "course": "Generative AI",
        "lecture_num": "3강",
        "lecture_title": "Text Generation 2 Parameter Efficient Tuning",
        "chunk_idx": 1,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:ae603a749437b2b440a17e31cc5d92d8016ac6cb8ec12c6c5e4190cc40b6203c"
      },
      "token_estimate": 1118,
      "char_count": 2046
    },
    {
      "id": "transcript_generative_ai_generative_ai_3강_text_generati_c002_fcbe6b",
      "content": "[Generative AI] [Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning\n\n다. 어댑터는 기존에 이미 학습이 완료된 모델에 각 레이어의 학습이 가능한 피드 포드 네트워크를 삽입하는 구조입니다. 어댑터 레이어는 트랜스포머의 벡터를 더 작은 차원으로 압축을 하고 비선형 변환을 거쳐서 원래 차원으로 복원하는 병목 구조를 가지고 있습니다. 오른쪽에서 이제 보시자면 왼쪽은 트랜스포머라고 본다면 오른쪽이 어댑터 레이어인데 피드 포드 레이어를 통해서 훨씬 더 벡터를 작은 크기로 압축을 하고 비선형 변환을 한번 한 다음에 원래 차원으로 복원하는 겁니다. 이거 굳이 왜 하느냐 결국은 모델의 파라미터를 줄이기 위해서입니다. 그래서 멀티 헤드 어텐션에 해당하는 부분 피드 FRD 네트워크에 해당하는 부분들은 그대로 고정을 시켜놓고 어댑터 레이어에 해당하는 부분만 학습을 시킨다는 뜻이지요. 어댑터 모듈은 파인 튜닝 단계에서 특정한 타겟 테스크에 대해서 최적화되는 것이고요. 나머지 트랜스포머 레이어는 모두 고정이 되는 것입니다. 따라서 이를 통해서 훨씬 더 효율적으로 행렬의 차원이 작은 경우만 학습을 함으로써 효율적인 학습이 가능해지고 위 어댑터라는 개념을 처음 제안한 논문에서는 글루 벤치마크의 9개 테스크의 성능을 평균을 낸 결과 매우 작은 학습 파라미터만으로도 파인튜닝에 근접한 성능을 기록했다는 연구 결과가 있습니다. 여기 보시는 것처럼 x축이 파라미터 학습을 해야 되는 파라미터의 수이고요. 오른쪽이 이제 성능 차이라고 했을 때 파인튜닝을 10에 8승 이상만큼을 한 거와 10의 6승 정도에 그러니까 100분의 1 정도만 학습을 파인튜닝을 어댑터를 통해서 했음에도 불구하고 성능은 거의 유사하다라는 것을 의미합니다. 두 번째는 프리픽스 튜닝이라는 겁니다. 프리픽스라는 게 바로 어떤 무엇인가의 앞쪽에다가 고정적으로 붙인다라는 것이죠. 각 트랜스포머의 레이어에 프리픽스라는 훈련 가능한 벡터를 추가하는 방식입니다. 이거는 가상의 인베딩으로 간주될 수가 있는데요. 원래 파인 튜닝이라면 이 트랜스포머의 모든 이 항목들을 학습을 시켜야 되는데 그게 아니라 프리트레인드 사전 학습된 트랜스포머의 이 벡터들은 고정을 시켜 놓고 그 앞에다가 프리픽스를 붙여줍니다. 이 분홍색 부분만이 학습을 한다라는 뜻이죠. 그래서 각 테스크를 더욱더 잘 풀이하기 위해서 벡터를 최적화를 하고 이거를 기존 모델과 병합할 수 있게 됩니다. 세 번째 프롬프트 튜닝이라는 거는 프리픽스 튜닝과는 다르게 모델의 입력 레이어에 훈련 가능한 프롬프트 벡터를 통합하는 방법입니다. 그래서 여기서 보시면 레이어는 고정이 되어 있는데 인풋과 프롬프트에 대한 노란색 부분만이 학습이 되는 파라미터인 거죠. 근데 여기서의 앞에서 설명드렸던 인풋 문장의 자연어 프럼프팅을 덧붙이는 것과는 약간은 다른 개념으로써 인풋의 인베딩 레이어를 최적화하는 방법론이라고 보시면 되겠습니다. 여기서 보시는 것처럼 프롬프트 자체를 어떤 테스크의 배치마다 태스크가 있을 때 앞에 프롬프트를 붙여주고 해당하는 프롬프트는 여기서 보시는 것처럼 여기 이 테스크 프롬프트에서 이렇게 어 딕셔너리처럼 사용을 할 수 있는 끼워 넣을 수 있는 부분이 되겠습니다. 마지막으로 로우 랭크 어댑테이션 로라 같은 경우에는 사전 학습된 모델의 파라미터를 고정하고 학습 가능한 랭크의 디컴포지션 행렬을 삽입하는 방법입니다. 행렬의 차원을 랭크만큼 줄이는 행렬과 다시 원래의 차원을 크기로 바꿔주는 행렬로 구성이 되고요. 이거를 롤 랭크 키 콤포지션이라고 표현을 합니다. 레이어마다 히든 스테이트의 로라 파라미터를 더해서 파인 튜닝을 하게 됩니다. 최근에 이제 그 PFT 방법론 중에서 가장 널리 쓰이는 것이고요. 여기 보시는 것처럼 왼쪽에 있는 분홍색의 사전 학습된 웨이트 같은 경우에는 이게 굉장히 사이즈가 큽니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning.json",
        "lecture_name": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning",
        "course": "Generative AI",
        "lecture_num": "3강",
        "lecture_title": "Text Generation 2 Parameter Efficient Tuning",
        "chunk_idx": 2,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:ae603a749437b2b440a17e31cc5d92d8016ac6cb8ec12c6c5e4190cc40b6203c"
      },
      "token_estimate": 1034,
      "char_count": 1901
    },
    {
      "id": "transcript_generative_ai_generative_ai_3강_text_generati_c003_fd04e1",
      "content": "[Generative AI] [Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning\n\n다. 행렬의 차원을 랭크만큼 줄이는 행렬과 다시 원래의 차원을 크기로 바꿔주는 행렬로 구성이 되고요. 이거를 롤 랭크 키 콤포지션이라고 표현을 합니다. 레이어마다 히든 스테이트의 로라 파라미터를 더해서 파인 튜닝을 하게 됩니다. 최근에 이제 그 PFT 방법론 중에서 가장 널리 쓰이는 것이고요. 여기 보시는 것처럼 왼쪽에 있는 분홍색의 사전 학습된 웨이트 같은 경우에는 이게 굉장히 사이즈가 큽니다. 랭크 자체가 d 모델 d FID f 웨이트라고 했을 때 모델의 사이즈가 더 작지만 여전히 가로 길이가 크죠. 아주 완벽한 개념은 아닙니다마는 예시 비유로서 들어드리면 이 다각형의 면적이 우리가 학습 시켜야 되는 파라미터의 개수에 비례한다라고 보면 로우 랭크 어댑테이션 같은 경우에는 이 중간에 스몰알이라고 하는 훨씬 더 작은 그 수의 벡터로 압축을 한번 한 뒤에 풀어내는 과정입니다. 이 노란색 부분만 학습을 해서 원래 프리트레이드 된 웨이트에다가 더해주면 이 파인 튜닝이 가능하다라는 것이고요. 가장 널리 쓰이는 방법론이라고 좀 전에 말씀드렸습니다. 여기서 보시는 것처럼 로우 랭크 디컴 포지션을 통해서 사용한 파라미터를 델타w라고 봤을 때 원래 기존의 분홍색에 해당하는 이 웨이트에다가 이 로우 랭크 어댑테이션을 통해서 사전 파인 튜닝이 된 웨이트를 단순히 합쳐주는 겁니다. 이거를 가능하게 하는 이유는 뭐냐 하면 여기에 있는 디프블라고 하는 핑크색에 해당하는 요 윗면의 가로 길이와 노란색에 해당하는 윗면의 가로 길이가 같기 때문에 웨이트를 1 대 1로 대응을 시킬 수가 있고요. 그럼으로 인해서 단순히 더해지는 것만으로써 효과를 볼 수 있다라는 겁니다. 그리고 이 스몰알은 원래 데이터인 행렬인 에하고 비가 가지고 있는 랭크의 엠과 엔이라는 랭크보다 훨씬 더 적은 수의 랭크를 가짐으로써 학습 파라미터의 개수를 줄여준다는 뜻입니다. 로라는 어댑터 레이어에 추가하는 방법은 작은 바틀랙 레이어만 추가하는 경우에도 인퍼런스 레이턴시 다시 말하면 뭔가를 제공 입력을 제공했을 때 출력이 만들어지는 레이턴시가 매우 증가하는 모습을 보였기 때문에 사용하기가 어렵습니다. 반면 로라를 이용하는 경우에는 새롭게 학습한 파라미터를 기존 모델을 단순히 합쳐 줌으로써 추가적인 연산이 필요하지 않고 인퍼런스의 스피드도 유지하면서 모델의 아키텍처를 변형하지 않고 활용할 수 있다는 뜻입니다. 로라는 보시는 바와 같이 기존 방법론 대비 월등하게 높은 성능을 보이고 있고요. 로보타 또는 디볼타와 같은 인코더 모델 뿐만이 아니라 지피티와 같은 디코더 모델에서도 가장 우수한 성능을 기록하고 있다라는 것을 보실 수가 있겠습니다. 또한 175 빌리언 파라미터를 가지고 있는 지피티3에서도 로라가 여러 가지 데이터셋에 대해서도 로라 튜닝을 했을 때 단순히 직접 파인튜닝을 하는 거 프리픽스 인베딩을 하는 거, 레이어에 대해서 인베딩을 하는 거 어댑터를 쓰는 것보다도 성능이 높게 나타나는 것을 이 그림으로써 확인하실 수 있습니다. 또한 이 파라미터 이피션 파인튜닝 같은 경우에는 아래와 같은 방식으로 굉장히 간단하게 적용이 될 수가 있습니다. 어댑터의 경우 그다음에 프리픽스 튜닝의 경우 프롬프트 튜닝의 경우 로라의 경우 이제 수도 코드로서 표현을 한 것이고, 이거는 어떤 모델 구조를 많이 바꾸는 것이 아니라 몇 가지의 이 몇 라인의 함수만으로써 이 피프티를 활용할 수 있기 때문에 여러분들이 오픈 소스 모델을 여러분들의 태스크에 맞게 파인튜닝을 할 때는 적극적으로 활용해 보시는 것을 권장합니다. 또한 이 피프티 모든 방법론 소개해 드렸던 방법론들은 허깅 페이스에서의 라이브러리로 구현이 되어 있기 때문에 실제 학습에서는 굉장히 간편하게 사용될 수 있다라는 팁도 마지막으로 드리겠습니다. 여기까지 해서 세 번째 강의를 마치도록 하겠습니다. 감사합니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning.json",
        "lecture_name": "[Generative AI] (3강) Text Generation 2 Parameter Efficient Tuning",
        "course": "Generative AI",
        "lecture_num": "3강",
        "lecture_title": "Text Generation 2 Parameter Efficient Tuning",
        "chunk_idx": 3,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:ae603a749437b2b440a17e31cc5d92d8016ac6cb8ec12c6c5e4190cc40b6203c"
      },
      "token_estimate": 1054,
      "char_count": 1949
    }
  ]
}