{
  "source_file": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model.json",
  "lecture_name": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model",
  "course": "기타",
  "total_chunks": 6,
  "chunks": [
    {
      "id": "transcript_기타_7강_더_좋은_성능을_위한_기법_1_pretrained_c000_678cef",
      "content": "[강의 녹취록] 과목: 기타 | 강의: 7강 | 제목: 더 좋은 성능을 위한 기법 (1)-Pretrained Model\n\n안녕하세요. 도메인 공통 프로젝트 7강 더 좋은 성능을 위한 기법 프리트레인드 모델 시작하겠습니다. 이번 강의에서는 사전 학습 모델의 중요성 이해하기 대표적인 사전 학습 모델 종류와 특징 살펴보기 마지막으로 허깅페이스 트랜스포머스 모듈 활용법 익히기에 대해서 배워보겠습니다. 먼저 사전 학습 모델의 중요성 이해하기입니다. 사전 학습 모델의 배경인 전이 학습에 대해서 먼저 이야기해 보겠습니다. 일반적으로 새로운 지식을 배울 때 기존에 알고 있던 지식을 활용하면 효율적이라는 부분은 우리가 직관적으로 알고 있습니다. AI도 이미 학습된 지식을 가져와서 이용하게 하자라는 것이 이 전이 학습의 컨셉이라고 이해하시면 되겠는데요. 대규모 데이터셋으로 미리 학습된 모델 사전 학습 모델이라고 하죠. 프리트레인드 모델이라고 합니다. 이 모델들의 지식 가중치를 사용하는 방법으로 새로운 테스크에 맞게 미세 조정하는 학습 방식을 이야기합니다. 밑에 그림에서 보시면 s스 데이터셋라고 하는 어떤 사전에 학습된 커다란 데이터셋을 기반으로 s스 모델을 학습을 시킵니다. 이 과정에서 프리트레인드 사전 학습이 이루어지게 되는데요. 이 모델을 가져와서 우리가 실제 풀고자 하는 타겟 데이터, 이 타겟 데이터에 맞게 미세 조정하는 파인 튜닝 하는 학습 방식입니다. 그림에서 보시면 아시겠지만 솔스 모델에서 가져온 모든 모델을 사용하지는 않을 수 있습니다. 특정 레이어를 freeze 시켜서 재학습되지 않도록 하거나 혹은 마지막에 새로운 레이어를 추가를 하는 방식으로 학습을 하게 됩니다. 전이 학습 과정은 다음 과정을 따르게 됩니다. 먼저 사전 훈련된 모델을 선택하게 됩니다. 내가 풀고자 하는 혹은 우리 팀이 풀고자 하는 관련 작업에 대한 사전 지식이나 기술을 갖춘 모델을 선택합니다. 그다음 사전 훈련된 모델을 구성합니다. 사전 훈련 모델을 새로운 작업 요구 사항에 맞게 재구성을 합니다. 사전 훈련 모델의 특정 계층을 동결 프리즈 하거나 최종 계층을 제거하거나 혹은 새로운 계층을 도입하는 등 여러 가지 방식을 통해서 재구성을 합니다. 마지막으로는 대상 도메인에 대한 모델을 훈련합니다. 새 작업 데이터를 기반으로 모델을 학습 성능 모니터링, 필요하다면 하이퍼 파라미터 등을 조정하게 됩니다. 자연어 처리에서 사전 학습 모델 효과에 대해서 살펴보겠습니다. 먼저 성능 향상입니다. 사전 학습 모델은 대규모 텍스트를 학습하여 언어의 패턴, 문법, 의미론적 관계를 학습한 상태입니다. 특정 테스크에서 처음부터 학습하는 모델보다 뛰어난 성능을 보입니다. 학습 리소스를 단축시킬 수 있습니다. 초기 가중치가 이미 있는 상태이므로 랜덤 가중치로 시작하는 것보다 적은 데이터와 시간으로도 목표한 성능을 달성하기 용이하며, 대규모 데이터로 학습하는 데 필요한 컴퓨팅 자원을 절약할 수 있고, 적은 양의 데이터만으로도 사용 가능하기 때문에 데이터 수집 어려움이 많이 줄어들게 됩니다. 그렇다면 어떤 사전 학습 모델을 선택을 해야 될까요? 사전 학습 모델의 핵심적인 역할 중 하나는 바로 효율적이고 의미론적인 임베딩 생성에 있습니다. NLP 모델에서 단어를 숫자로 표현하는 방식인 인베딩은 모델의 성능에 큰 영향을 미치게 됩니다. 첫 번째로 볼 인베딩은 정적 인베딩, 스테틱 인베딩입니다. 단어 하나의 임베딩 벡터가 항상 동일하게 유지되는 방식입니다. 가장 기본적이고 직관적인 임베딩 방식입니다. 어떤 문맥에서 사용되든지 모든 단어의 벡터는 불변합니다. 정적 인베딩의 한계에 대해서 이야기해 보겠습니다. 워 투 백, 글로브 등 기존의 정적 인베딩은 단어 하나당 하나의 고정된 벡터를 가집니다. 동우미니어나 다이어 예를 들어서 사과가 과일 또는 행위의 경우 문맥적 의미를 반영하지 못한다는 문제가 있고요. 학습 이후 벡터 값이 고정되어 도메인 변화에 적응이 불가능하다는 부분 형태소나 서브워 수준의 표현 부족으로 희귀어 또는 신조어 처리에 한계가 있습니다. 이에 따라 상위 수준 문장 문서를 구성하기 위한 추가적인 구조가 필요합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model.json",
        "lecture_name": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "course": "기타",
        "lecture_num": "7강",
        "lecture_title": "더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "chunk_idx": 0,
        "total_chunks": 6,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:defccd09a27f2b6b52df497a250367a1d45d98d0f9592ae2357760f4d9c5f663"
      },
      "token_estimate": 1108,
      "char_count": 2022
    },
    {
      "id": "transcript_기타_7강_더_좋은_성능을_위한_기법_1_pretrained_c001_fb0ec6",
      "content": "[기타] (7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model\n\n다. 어떤 문맥에서 사용되든지 모든 단어의 벡터는 불변합니다. 정적 인베딩의 한계에 대해서 이야기해 보겠습니다. 워 투 백, 글로브 등 기존의 정적 인베딩은 단어 하나당 하나의 고정된 벡터를 가집니다. 동우미니어나 다이어 예를 들어서 사과가 과일 또는 행위의 경우 문맥적 의미를 반영하지 못한다는 문제가 있고요. 학습 이후 벡터 값이 고정되어 도메인 변화에 적응이 불가능하다는 부분 형태소나 서브워 수준의 표현 부족으로 희귀어 또는 신조어 처리에 한계가 있습니다. 이에 따라 상위 수준 문장 문서를 구성하기 위한 추가적인 구조가 필요합니다. 오른쪽에 있는 예시를 보면 뱅크라고 하는 단어에 대해 서로 다른 문장 혹은 서로 다른 컨텍스트에 있음에도 동일한 임베딩을 갖는 것을 예시로 보여줍니다. 이런 정적 인베딩의 한계점을 보완하기 위해 문맥에 따라 의미를 다르게 표현하는 동적 인베딩을 사용할 수 있습니다. 동적 인베딩, 다이나믹 인베딩이라고 하는 이 방법은 단어의 인베딩 벡터가 문맥에 따라 동적으로 변경되는 방식입니다. RNN, LSTM 기반의 시퀀스 투 시퀀스 모델부터 트랜스포머 기반 모델까지 발전하게 됩니다. 같은 단어라도 문맥에 따라 다른 임베딩 벡터를 가지게 됩니다. 오른쪽에 있는 예시를 보겠습니다. iw 투 더 뱅크, 리버뱅크, 워즈 머디, 랭크 오브 아메리카 이런 식으로 같은 뱅크인 단어가 서로 다른 문장, 서로 다른 문맥이 있을 때 다른 벡터 값을 갖는 것을 보여줍니다. 다음은 대표적인 사전 학습 모델의 종류와 특징을 이해하기입니다. 첫 번째로는 지피티 제너레이티브 프리 트렌드 트랜스포머라고 하는 모델의 종류입니다. 오토 리그레시브 자기회귀 생성 방식입니다. 자기 회귀 생성 방식이란 왼쪽에서 오른쪽으로 단어를 하나씩 예측해 가면서 텍스트를 생성하도록 학습하는 방식입니다. 퓨샷 학습이나 제로샷 학습과 같은 프롬프트 엔지니어링 방식이 각광받고 있습니다. 별도의 파인튜닝 과정 없이 프롬프트에 몇 개의 예시만으로 다양한 테스크를 수행할 수 있게 되는 방식입니다. 다음은 벌츠입니다. 벌츠는 MLM 방식을 사용을 하게 됩니다. 이 마스크 랭귀지 모델 학습 방식은 문장 내 일부 단어를 마스크 토큰으로 가립니다. 그다음 모델에게 이 가려진 단어가 무엇인지 예측하도록 학습을 시킵니다. 예를 들어서 나는 땡땡을 타고 바다로 나갔다 라고 했을 때 이 oo 부분에 배라고 하는 글자가 나올 수 있도록 혹은 베라는 글자가 나올 확률이 높아지도록 모델을 학습시킵니다. 다음은 NSP라고 하는 기법을 또 사용합니다. next ST스 프레딕션이라고 하는데요. 두 개의 문장이 주어졌을 때 원문에서 이어지는 문장인지 아닌지를 예측하도록 학습합니다. 이를 통해 모든 단어가 앞뒤 문맥을 동시에 고려하여 학습할 수 있도록 구성합니다. 다음으로는 GPT와 벌트의 구조를 비교해 보겠습니다. 그 전에 트랜스포머의 인코더와 디코더 구조에 대해서 먼저 살펴보도록 하겠습니다. 트랜스포머의 인코더는 입력된 텍스트를 분석하여 그 의미를 이해하는 역할을 합니다. 주어진 문맥 속에서 단어들의 관계를 파악하고 이를 통해 전체 문장의 숨겨진 의미를 파악하는 데 특화되어 있는 구조입니다. 다음은 디코더입니다. 인코더의 정보를 바탕으로 새로운 텍스트를 생성해 내는 역할을 하는데요. 예측, 번역, 요약 등 새로운 결과물을 만들어내는 데 주로 사용합니다. GPT는 트랜스포머의 디코더를 사용하여 생성 능력에 특화되어 있는 구조입니다. gpt2는 오픈 소스인 반면 지피티3, 지피티4와 같은 최신 모델은 가중치가 비공개되어 있고 에피로만 사용이 가능합니다. 최근 지피티 5스스 같이 공개된 모델도 존재는 합니다. 유료 파인튜닝을 지원하지만 자원 소모 혹은 비용이 매우 높을 수 있습니다. 다음은 폴트입니다. 폴트는 트랜스포머 인코더 구조를 사용하여 문장 이해 능력의 특화 라이브러리를 통한 쉬운 접근 및 활용이 가능합니다. 다음은 로v타입니다. 월트의 사전 학습 방식을 최적화하여 개선하고 더 많은 데이터로 더 긴 학습 시간을 사용한 모델입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model.json",
        "lecture_name": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "course": "기타",
        "lecture_num": "7강",
        "lecture_title": "더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "chunk_idx": 1,
        "total_chunks": 6,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:defccd09a27f2b6b52df497a250367a1d45d98d0f9592ae2357760f4d9c5f663"
      },
      "token_estimate": 1096,
      "char_count": 2019
    },
    {
      "id": "transcript_기타_7강_더_좋은_성능을_위한_기법_1_pretrained_c002_9e80b4",
      "content": "[기타] (7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model\n\n다. gpt2는 오픈 소스인 반면 지피티3, 지피티4와 같은 최신 모델은 가중치가 비공개되어 있고 에피로만 사용이 가능합니다. 최근 지피티 5스스 같이 공개된 모델도 존재는 합니다. 유료 파인튜닝을 지원하지만 자원 소모 혹은 비용이 매우 높을 수 있습니다. 다음은 폴트입니다. 폴트는 트랜스포머 인코더 구조를 사용하여 문장 이해 능력의 특화 라이브러리를 통한 쉬운 접근 및 활용이 가능합니다. 다음은 로v타입니다. 월트의 사전 학습 방식을 최적화하여 개선하고 더 많은 데이터로 더 긴 학습 시간을 사용한 모델입니다. NSP 테스크가 성능 향상에 큰 기여를 하지 않는다고 판단하여 제거하는 대신 엠엘엠 테스크에 집중하게 된 모델입니다. 폴트는 사전 학습 단계에서 마스킹 패턴을 한 번으로 고정하지만 로버타는 학습 데이터가 모델에 주입될 때마다 다른 마스킹 패턴을 적용하는 다이나믹 마스킹을 사용합니다. 이를 통해 더 다양한 더 복잡한 패턴을 잘 학습할 수 있게 됩니다. 다음은 효율성을 위한 경량화에 집중한 알버트 모델에 대해서 이야기해 보겠습니다. 파라미터를 줄여 학습 속도를 올리기 위해 다음과 같은 테크닉을 사용합니다. 거대한 인베딩 행렬을 2개의 행렬로 분해하고 히든 레이어와 단어 임베딩을 분리하여 학습해야 되는 파라미터 수를 감소시켰습니다. 기존 트랜스포머에서 각 레이어 간 같은 파라미터를 공유하도록 변경하였고, 이를 통해 모델 크기 및 메모리 사용량 그리고 학습 시간을 효율화하는 개선점이 있었습니다. 또한 문장 사이의 순서를 학습하여 문장 간의 일관성을 효율적으로 학습할 수 있도록 합니다. 에오피를 통해 실제 담화 흐름에서 앞뒤 문장 순서가 자연스러운지를 학습합니다. 다음은 디스티 v트입니다. 지식을 증여하는 널리지 디스틸레이션 기법을 적용한 경량화 모델입니다. 벌트 모델을 티처 모델로 볼트 모델의 출력을 학생 모델인 디스트리 버트가 모방하도록 학습을 합니다. 이를 통해 벌트 베이스 모델에 비해 파라미터 수가 40% 적어 추론 속도가 약 60% 더 빨라지게 되는 결과를 얻었습니다. 다음으로는 라마입니다. 라즐 랭귀지 모델 메타 AI라고 하는 모델이고요. 사전 학습 방식을 따릅니다. 지피티와 유사하게 오토 리그레시브 생성 방식입니다. 세븐빌리언, 퍼틴 빌리언 혹은 다른 여러 가지 버전에 따라 자원 요구량이 다양합니다. 당연히 파라미터 수가 많으면 많을수록 높은 성능을 가지고 있습니다. 오픈 소스 및 접근 방식에서는 gpt3, 지피티4와 달리 가중치 자체가 연구 목적으로 공개되었다는 점이 핵심적인 특징입니다. 연구 라이선스로 공개되어 있어 다양한 실험 가능 연구 목적 외 상업적 사용은 제한됩니다. 다음은 허깅페이스 트랜스포머스 모듈 사용법 익히기입니다. 허깅페이스 트랜스포머스 라이브러리는 많은 트랜스포머 계열의 모델들을 쉽게 사용할 수 있도록 다양한 기능을 제공하는 라이브러리입니다. 관련된 코드와 사전 학습 모델을 쉽게 다운로드, 파인 튜닝 할 수 있도록 지원합니다. LLM의 배포 및 접근성 측면에서 주요 LLM들은 허깅페이스 같은 플랫폼을 통해 사전 학습 모델의 형태로 배포하게 됩니다. 허깅페이스는 라마 연구 라이선스나 블룸 오픈 라이선스처럼 가중치를 공개한 오픈 소스 대형 모델들을 제공하여 연구 및 개발 커뮤니티가 직접 모델을 분석하고 커스터마이징 할 수 있도록 돕습니다. 파인 튜닝 용이성 측면에서는 적은 수의 데이터를 이용한 로컬 파인튜닝 학습으로도 높은 성능을 기대할 수 있습니다. 문장 분류, 질의응답, 개체명 인식 등에 맞춰 마지막 레이어를 추가하여 학습하면 됩니다. 다음은 허깅페이스 트랜스포머스 라이브러리에 있는 파이프라인에 대해서 설명드리겠습니다. 사전 훈련된 모델을 추론을 수행할 때 사용하는 인터페이스입니다. 사용자가 모델 코드를 직접 작성하거나 복잡한 설정을 할 필요 없이 특정 테스크를 위한 사전 훈련된 모델과 토크나이저를 자동으로 다운로드하고 캐시하여 사용합니다. 여러 모달리티 자연어 처리, 컴퓨터, 비전, 오디오 혹은 멀티 모델에서 다양한 과업을 기본적으로 지원합니다. 사용 방법은 다음과 같습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model.json",
        "lecture_name": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "course": "기타",
        "lecture_num": "7강",
        "lecture_title": "더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "chunk_idx": 2,
        "total_chunks": 6,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:defccd09a27f2b6b52df497a250367a1d45d98d0f9592ae2357760f4d9c5f663"
      },
      "token_estimate": 1115,
      "char_count": 2042
    },
    {
      "id": "transcript_기타_7강_더_좋은_성능을_위한_기법_1_pretrained_c003_f78858",
      "content": "[기타] (7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model\n\n다. 다음은 허깅페이스 트랜스포머스 라이브러리에 있는 파이프라인에 대해서 설명드리겠습니다. 사전 훈련된 모델을 추론을 수행할 때 사용하는 인터페이스입니다. 사용자가 모델 코드를 직접 작성하거나 복잡한 설정을 할 필요 없이 특정 테스크를 위한 사전 훈련된 모델과 토크나이저를 자동으로 다운로드하고 캐시하여 사용합니다. 여러 모달리티 자연어 처리, 컴퓨터, 비전, 오디오 혹은 멀티 모델에서 다양한 과업을 기본적으로 지원합니다. 사용 방법은 다음과 같습니다. 파이프라인 함수에 수행하고자 하는 태스크를 지정하여 인스턴스를 생성합니다. 예를 들어 감정 분석을 위해 파이프라인 센티멘트 아네시스와 같이 사용하면 됩니다. 생성된 클래스 파이어 객체에 대상 텍스트를 전달하여 추론을 수행합니다. 파이프라인 예제를 보겠습니다. 텍스트 생성용 파이프라인이고 결과는 리스트 형태로 변환되며 첫 번째 결과에 제너레이티드 텍스트를 사용하시면 됩니다. 이 예제에 사용한 옵션을 설명드리면 모델은 gpd2 GPU는 0번 디바이스 마이너스 1을 넣는 경우는 CPU가 됩니다. 입력 길이 제한을 넣었고요. 생성 결과 수 제한을 넣었습니다. 오른쪽 예시를 보시면 모델 이름에 오픈 AI, 커뮤니티 SLA시 gpt2라는 이름으로 파이프라인 객체를 생성을 했고요. 디바이스에 제로를 넣었기 때문에 0번 GPU에서 실행이 됩니다. 그다음 파이프라고 하는 이 인스턴스에 아이캔 NDS al 데이라고 하는 텍스트를 집어넣고 트렁케이션 2 넘 리턴 시퀀시스 1이라고 하는 값을 전달하여 결과를 반환합니다. 생성된 결과는 다음과 같습니다. 다음 예제로는 제로샷 분류를 보겠습니다. 미리 정의된 레이블에 대해 추가 학습 없이 즉시 다중 클래스로 분류될 수 있습니다. 오른쪽 예시에서 보면 캔디데이트 라벨스 라고 하는 부분에서 파서브 인파서브이라고 하는 라벨을 전달해 보겠습니다. 입력은 기존과 동일한 아이캔 두디스 올 데이를 넣겠습니다. 여기서 결과를 받는 리졸트를 확인을 해보면 모델이 선택할 수 있는 라벨 후보를 입력을 받아서 라벨별 스코어를 반환합니다. 결과를 확인해 봤을 땐 파서블이라는 라벨이 선택된 것을 보실 수가 있습니다. 다음은 오토 클래스입니다. 오토 클래스에는 오토 토크나이저, 오토 모델이 있습니다. 엘엘엠을 포함한 다양한 트랜스포머 계열 모델의 접근성과 활용성을 크게 향상시키는 핵심 기능이 됩니다. 사전 학습 모델의 아키텍처와 관련된 토크나이저를 자동으로 가져와 로드하는 바로 가기 역할이다 정도로 이해하시면 됩니다. 대형 모델들을 직접 개발할 필요 없이 손쉽게 로드하고 활용할 수 있게 하여 대규모 데이터 컴퓨팅, 파워 시간 등의 장벽을 극복하고 조직이 맞춤형 엠엘을 채택할 수 있도록 돕습니다. 먼저 오토 토크나이저입니다. 텍스트를 모델 입력에 필요한 숫자 배열 형태로 전처리하는 역할을 합니다. 단어를 어디서 끊을지, 어느 수준까지 나눌지와 같은 토크나 규칙들이 포함되어 있습니다. 퍼트 모델에는 월드 피스 토크나이저가, 지피티 모델에는 바이트 페어 인코딩 토크나이저가 사용되는 등 모델마다 다른 토크나이저가 활용됩니다. 모델이 사전 훈련된 모델과 동일한 모델 이름으로 토크나이저를 인스턴스화해야 합니다. 다음은 오토 모델입니다. 사전 훈련된 인스턴스를 간단하고 통합된 방법으로 로드합니다. 특정 과업에 맞는 알맞은 모델을 선택합니다. 예를 들어 텍스트 또는 시퀀스 분류를 위해서는 오토 모델 폴 시퀀스 커시피케이션을 로드해야 합니다. 오토 토크나이저 예제를 보겠습니다. 오른쪽 예시에서 오토 토크나이저, 프럼 프리트레인드에서 구글 버트 버트 베이스 언 케이스라고 하는 사전 학습 버츠 모델의 토크나이저를 로드를 합니다. 문장을 월드 피스 기반으로 토크화를 하고 각 토큰을 정수 인덱스로 매핑합니다. 매핑된 결과는 다음과 같습니다. 인풋 아이디스 각 토큰에 대한 정수 아이디 리스트입니다. 토큰 타입 아이디스, 문장 구분 아이디입니다. 단일 문장에서는 모두 0으로 들어갑니다. 어텐션 마스크 각 토큰이 실제 입력인지 혹은 패딩인지를 표시를 합니다. 그 결과가 오른쪽에서 보여지고 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model.json",
        "lecture_name": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "course": "기타",
        "lecture_num": "7강",
        "lecture_title": "더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "chunk_idx": 3,
        "total_chunks": 6,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:defccd09a27f2b6b52df497a250367a1d45d98d0f9592ae2357760f4d9c5f663"
      },
      "token_estimate": 1120,
      "char_count": 2046
    },
    {
      "id": "transcript_기타_7강_더_좋은_성능을_위한_기법_1_pretrained_c004_804502",
      "content": "[기타] (7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model\n\n다. 오른쪽 예시에서 오토 토크나이저, 프럼 프리트레인드에서 구글 버트 버트 베이스 언 케이스라고 하는 사전 학습 버츠 모델의 토크나이저를 로드를 합니다. 문장을 월드 피스 기반으로 토크화를 하고 각 토큰을 정수 인덱스로 매핑합니다. 매핑된 결과는 다음과 같습니다. 인풋 아이디스 각 토큰에 대한 정수 아이디 리스트입니다. 토큰 타입 아이디스, 문장 구분 아이디입니다. 단일 문장에서는 모두 0으로 들어갑니다. 어텐션 마스크 각 토큰이 실제 입력인지 혹은 패딩인지를 표시를 합니다. 그 결과가 오른쪽에서 보여지고 있습니다. 다음은 오토 모델 예제입니다. 오른쪽 예시에서 보시면 모델 이름을 디스티벌트 디스티버트 베이스 언 케이스트라는 모델을 사용합니다. 이전에 설명드렸던 것과 동일하게 오토 토크나이저와 오토 모델에는 동일한 모델 이름을 전달해야 됩니다. 그래서 예시에서도 프럼 프리 트레인트라는 메서드를 호출할 때 동일한 모델 이름을 전달하는 것을 보실 수가 있습니다. 다음으로는 이제 입력 텍스트를 토크나이저 방금 생성한 토크나이저에 전달을 해서 인풋 벡터를 만들어 냅니다. 인풋 벡터를 모델에 전달하는 것으로 그 모델의 로지 값을 만들어 낼 수 있고, 소프트맥스를 통해서 결과 확률을 얻어낼 수 있습니다. 여기에서 사용하는 디스트리버트 디스트리버트 베이스 언 케이스드는 특정 목적의 태스크로 파인튜닝 되어 있지 않은 모델이기 때문에 사실 여기에서 출력되는 로지이나 예측 확률은 의미 없는 값입니다. 그래서 여러분들이 실제로 사용하실 때는 추가적인 파인 튜닝이 반드시 필요하다는 점 염두에 두시면 좋겠습니다. 다음은 트레이너입니다. 트레이너는 모델 훈련을 최적화하는 클래스입니다. 훈련 루프를 효율적으로 관리하고 대규모 언어 모델을 파인튜닝 하는 데 필수적인 기능을 제공합니다. 분산 학습과 같은 고급 기능을 추가로 제공하여 대규모 모델 훈련 시 자원 효율성을 높여줍니다. 손실 함수 옵티마이저, 스케줄러와 같은 훈련 루프의 기능을 변경 가능합니다. 콜백을 사용하여 훈련 루프를 바꾸지 않으면서도 다른 라이브러리와 통합하거나 훈련 진행 상황을 보고받거나 조기에 훈련을 중단하는 것이 가능합니다. 다음으로는 트레이너 예제에 대해서 보겠습니다. 이전에 배웠던 것과 같이 오토 토크나이저, 오토 모델을 통해서 우리가 사용할 모델을 불러옵니다. 멀티 베이스 케이스 모델의 텍스트 처리 규칙을 따르는 토크나이저를 로드합니다. 이 토크나이저는 자연어를 모델이 이해하는 숫자 형태로 변환하는 역할을 합니다. 다음과 같이 벌트 베이스 케이스 모델의 아키텍처와 대규모 데이터셋으로 학습된 가중치를 가진 모델 인스턴스를 가져올 수 있습니다. 이는 오른쪽 예제의 맨 밑에 해당합니다. 데이터 셋은 1점부터 5점까지의 리뷰 평점을 나타내는 데이터이고요. 오토 토크나이저를 사용해서 텍스트를 토큰화합니다. 옵션을 살펴보면 트렁케이션 트루 텍스트가 모델의 최대 입력 길이를 초과하는 경우 자동으로 자르게 되어 있고요. 배치 트루 여러 샘플을 한 번에 처리해서 속도를 향상시킬 수 있습니다. 분리된 트레인 테스트 셋을 다음과 같이 구성합니다. 정확도를 평가 매트릭으로 설정을 하고요. 로지 값이 높을수록 모델이 해당 클래스라고 강력하게 예측하고 있음을 의미합니다. 로짓은 음수이거나 양수일 수 있고 합이 1이 아닐 수 있습니다. 매트릭은 로짓을 토대로 추정 라벨과 실제 라벨의 일치 정확도로 설정합니다. 이는 오른쪽에 있는 컴퓨터 매트릭스라고 하는 함수로 정의할 수 있습니다. 그다음 트레이닝 아규먼츠의 모델을 저장할 출력 경로 그리고 평가 주기 등을 설정합니다. 트레이너 객체는 모델 데이터셋 매트릭 등을 받아 학습과 평가 루프를 자동화합니다. 트레인 메소드 호출로 지정한 설정에 따라 파인튜닝을 수행하며 평가 및 체크 포인트를 저장하게 됩니다. 의미 문장 아캔두디스 올데이라는 텍스트를 추정하도록 합니다. 입력 값을 토크나이징하고 버드 모드에 전달합니다. 예측된 리뷰 점수를 출력합니다. 이번 강의를 요약해 보겠습니다. 먼저 우리는 사전 학습 모델의 중요성에 대해서 배웠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model.json",
        "lecture_name": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "course": "기타",
        "lecture_num": "7강",
        "lecture_title": "더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "chunk_idx": 4,
        "total_chunks": 6,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:defccd09a27f2b6b52df497a250367a1d45d98d0f9592ae2357760f4d9c5f663"
      },
      "token_estimate": 1126,
      "char_count": 2037
    },
    {
      "id": "transcript_기타_7강_더_좋은_성능을_위한_기법_1_pretrained_c005_3d78eb",
      "content": "[기타] (7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model\n\n다. 그다음 트레이닝 아규먼츠의 모델을 저장할 출력 경로 그리고 평가 주기 등을 설정합니다. 트레이너 객체는 모델 데이터셋 매트릭 등을 받아 학습과 평가 루프를 자동화합니다. 트레인 메소드 호출로 지정한 설정에 따라 파인튜닝을 수행하며 평가 및 체크 포인트를 저장하게 됩니다. 의미 문장 아캔두디스 올데이라는 텍스트를 추정하도록 합니다. 입력 값을 토크나이징하고 버드 모드에 전달합니다. 예측된 리뷰 점수를 출력합니다. 이번 강의를 요약해 보겠습니다. 먼저 우리는 사전 학습 모델의 중요성에 대해서 배웠습니다. 미리 학습된 모델의 지식을 새로운 과제에 맞게 재활용하는 방식인 전이 학습에 대해서 이야기했습니다. 전이 학습은 높은 성능, 적은 데이터 자원으로도 빠른 학습 데이터 부족 문제를 완화시킵니다. 또한 정적 인베딩의 한계에 대해서도 이야기를 했습니다. 다이어와 희귀어 문제 문맥을 잘 반영하지 못하는 부분에 대해서도 이야기를 했었고요. 이를 극복하기 위해 동적 인베딩이 필요하다라고 이야기했습니다. 다음으로는 대표적인 사전 학습 모델인 지피티 종류와 벌 모델 종류에 대해서 이야기해 봤습니다. GPT는 트랜스포머의 디코더를 기반으로 구성되어 있으며 생성 능력에 특화되어 있습니다. 단순히 프롬프트를 제공하는 것으로 퓨샷, 제로샷 학습이 가능합니다. FT는 인코더 기반 모델로 문맥 이해에 강점이 있으며 MLM, NSP 기반 방식으로 모델을 학습합니다. 마지막으로는 허깅페이스 트랜스포머스 라이브러리에 대해서 이야기를 했는데요. 다양한 트랜스포머 기반 모델을 표준화된 방식으로 쉽게 불러오고 파인 튜닝이 가능하도록 도와주는 라이브러리였습니다. 그중 파이프라인은 감정 분석, 텍스트 생성, 제로샷 분류 등 손쉬운 추론을 지원하는 인터페이스였었고요. 오토, 토크나이저, 오토 모델 등은 모델별 토크나이저 및 모델 구조를 자동으로 로드해 주는 인터페이스였습니다. 마지막으로 트레이너는 학습, 루프, 평가, 분산 학습 등 효율적인 파인트윈을 지원하기 위한 인터페이스입니다. 이번 강의는 여기까지입니다. 고생 많으셨습니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model.json",
        "lecture_name": "(7강) 더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "course": "기타",
        "lecture_num": "7강",
        "lecture_title": "더 좋은 성능을 위한 기법 (1)-Pretrained Model",
        "chunk_idx": 5,
        "total_chunks": 6,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:defccd09a27f2b6b52df497a250367a1d45d98d0f9592ae2357760f4d9c5f663"
      },
      "token_estimate": 582,
      "char_count": 1065
    }
  ]
}