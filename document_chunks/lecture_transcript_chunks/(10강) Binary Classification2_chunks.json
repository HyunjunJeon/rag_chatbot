{
  "source_file": "(10강) Binary Classification2.json",
  "lecture_name": "(10강) Binary Classification2",
  "course": "Machine Learning",
  "total_chunks": 3,
  "chunks": [
    {
      "id": "transcript_machine_learning_10강_binary_classification2_c000_ef689a",
      "content": "[강의 녹취록] 과목: Machine Learning | 강의: 10강 | 제목: Binary Classification2\n\n우선 토치를 임포트하고 구강에서 수행했던 코드들을 실행을 할 수 있도록 하겠습니다. 네 수행했던 코드들이 꽤 많죠 네 그래서 모델이라는 인스턴스까지 생성을 해 주면 우리가 구강에서 수행했던 코드들을 모두 수행했다고 볼 수 있겠습니다. 우리가 이번 10강을 통해서 미진 교차 엔트로피를 유도해 왔었는데요. 그 유도 과정이 굉장히 복잡했었습니다. 하지만 엔앤댓 모듈 클래스에서 이진 블루 모델의 손실 함수인 이진 교체 엔트로피 즉 바이너리 크로스 엔트로피 로스트를 정의하는 것은 간단합니다. 엔앤닷 모듈 클래스에서 제공하는 함수로 엔엔 닷 바이너리 크로스 엔트로피 로스를 사용하면 이 한 줄로 손실 함수를 정의할 수가 있겠습니다. 그리고 또 최적화를 정의해 줘야 되는데요. 최적화를 정의하기 위해서 토치 닷 옵티마이저 모듈을 인포트해 주고 그리고 확률적 경사 화법을 구현하는 옵티마이저 닷 스토캐스틱 그레디언트 디센트 최적화 함수를 작성해 주고 그 옵션 값으로 모델의 파라미터들을 반환하는 메서드와 또 학습률을 정하는 매개 변수를 작성해 주고 이를 옵티마이저에 할당하면 되겠습니다. 7강과 8강에서 배웠던 내용과 같죠 네 그래서 이 부분도 우리가 실행을 해 주도록 하겠습니다. 이제 그 애폭에 대해서 또 살펴보고자 하는데요. 네 에폭 수를 설정해 보겠습니다. 에폭 수는 5000 정도로 설정을 하도록 하고요. 그리고 손실 값을 저장해야 하니까 그 손실 값을 저장할 수 있는 그 빈 공간에 리스트를 작성해 주겠습니다. 그리고 이제 포문을 통해서 그 에폭이 우리가 설정한 수만큼 반복할 수 있도록 해주고요. 그리고 모델 다 트레인 이 메서드를 통해서 학습 모드를 설정해 주도록 하겠습니다. 그리고 현재 에폭 동안 손실을 초기화 할 수 있도록 이 일곱 번째 줄을 작성하도록 하겠습니다. 그리고 우리가 앞에서 그 데이터 로더 인스턴스를 만들어 줬었는데요. 프레임 언더 스코어 로더 인 이제 데이터 로드의 인스턴스로 그 배치 단위인 이 데이터를 가져오는 이제 코드를 이와 같이 작성해 주도록 하겠습니다. 그래서 이전 배치에서 기울기를 먼저 초기화해 주고요. 그리고 모델의 입력 배치를 잘 전달해서 아웃풋을 이제 생성하도록 하겠습니다. 다시 말해서 이 모델에다가 배치 언더 스코어 피쳐스를 입력해 주면 이제 이것이 전달돼서 아웃풋이 나오겠죠 즉 예측을 생성할 겁니다. 네 그래서 이와 같이 예측 값도 우리가 생성 할 수가 있고요. 그럼 이제 모델의 예측값 즉 아웃풋하고 그리고 실제 레이블 배치의 언더 스코어 라벨 이 간에 이제 손실을 계산해 줄 수가 있겠죠. 그게 바로 이 11번째 줄입니다. 그러고 나서 로스톱 백워드를 통해 우리가 역전파를 수행하면 되겠습니다. 즉 현재 손실에 대한 경사를 이제 계산해 주겠다는 것이죠. 그리고 계산된 경사를 사용해서 모델의 파라미터를 업데이트해 주고요. 그것은 이제 옵티마이저 닷 스텝 가지고 이제 할 수가 있겠죠. 네 이 코드 가지고 우리가 모델 파라미터 업데이트해 줄 수가 있습니다. 그리고 이제 로스 닷 아이템을 통해서 손실 값을 텐서에서 숫자 값으로 추출해서 현재 배치의 손실을 에폭 언더스코어 로스에 계속해서 누적을 시키도록 하겠습니다. 그리고 이제 에fc의 손실도 이제 기록을 해야 하잖아요. 그래서 에폭에 손실 기록을 또 출력할 수 있는 코드로서 현재 폭의 평균 손실을 계산해서 로스 언더스쿨 리스트에 이제 추가를 시키도록 하겠습니다. 그래서 이 코드가 바로 네 현재 16번째 줄의 코드예요. 네 이 코드가 현재 에폭의 평균 손실을 계산해서 로스 언더스코어 리스트에 추가시키는 코드입니다. 그리고 이제 에폭 수가 너무 많으면 또 이제 우리가 출력되는 게 복잡하잖아요. 근데 에폭수가 500이니까 꽤 많다고 볼 수 있거든요. 그래서 에폭 번호가 100의 배수일 때마다 프린트 문을 작성해 주고 또 에폭 번호와 그리고 손실 값을 출력할 수 있도록 이 코드를 작성해서 우리가 그 손실값을 출력하도록 하겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(10강) Binary Classification2.json",
        "lecture_name": "(10강) Binary Classification2",
        "course": "Machine Learning",
        "lecture_num": "10강",
        "lecture_title": "Binary Classification2",
        "chunk_idx": 0,
        "total_chunks": 3,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:e23cac0b5b1d905def46585e5da45eaea9061c7f5f2c045040cd680aac3e0a73"
      },
      "token_estimate": 1077,
      "char_count": 1995
    },
    {
      "id": "transcript_machine_learning_10강_binary_classification2_c001_f0c4b9",
      "content": "[Machine Learning] (10강) Binary Classification2\n\n다. 그래서 이 코드가 바로 네 현재 16번째 줄의 코드예요. 네 이 코드가 현재 에폭의 평균 손실을 계산해서 로스 언더스코어 리스트에 추가시키는 코드입니다. 그리고 이제 에폭 수가 너무 많으면 또 이제 우리가 출력되는 게 복잡하잖아요. 근데 에폭수가 500이니까 꽤 많다고 볼 수 있거든요. 그래서 에폭 번호가 100의 배수일 때마다 프린트 문을 작성해 주고 또 에폭 번호와 그리고 손실 값을 출력할 수 있도록 이 코드를 작성해서 우리가 그 손실값을 출력하도록 하겠습니다. 그래서 이렇게 우리가 그 4 수에 따른 손실 값을 얻어낼 수가 있겠고요. 이제 그 손실 함수 즉 그 우리가 손실값의 변화죠. 다시 말해서 손실값의 변화를 시각화해 보도록 하겠습니다. 우선 메플릿 파이플롯 모드를 임포트해 주시고요. 예 관례적으로 PLT로 줄여 쓴다고 말씀을 드렸었죠. 그리고 PLT 피규어 이 함수를 통해서 플롯을 생성해 주고요. 그리고 PLT 닷 플로트 그리고 그 안에 옵션 값을 로스 언더 스코어 리스트 그리고 라벨은 트레인 로스 네 이 코드를 통해서 우리가 옵션 값으로 로스 언더 스코어 리스트 손실 값에 저장된 리스트의 선 그래프를 그려주고 그리고 또 법내에서 사용될 텍스트로 트레인 로스를 설정해 주도록 하겠습니다. 그리고 이제 x축 라벨 그러니까 x 라벨은 이제 에폭으로 이제 작성을 해 주고요. 또 y축 라벨은 로스로 작성해 주는 이 두 가지 코드를 우리가 작성해 주시면 되겠고요. 그다음에 피어티 더 레전드를 통해서 우리가 트레인 로스라는 본매를 추가할 수 있도록 하겠습니다. 레전드 자체가 범이라는 뜻이잖아요. 네 그리고 페어티 닷 그리드 이것을 이제 트루로 해줘서 그리드를 이제 작성을 해 주고요. 그리드를 이제 이렇게 만들어 주겠다는 겁니다. 그다음에 타이틀 또한 피어티 닷 타이틀 함수를 통해서 우리가 작성을 해 줄 건데 타이틀은 로스 트렌드로 하도록 하겠습니다. 그리고 마지막으로 해당 그래프를 볼 수 있도록 피엘티 닷 쇼 함수를 작성합니다. 결국 그 손실값 변화의 시각화는 그 8강에서의 내용과 거의 유사하다고 볼 수가 있겠습니다. 이렇게 해서 실행을 해주면 우리가 학습을 마칠 수가 있겠습니다. 이제 우리가 9강에서 구축하고 10강에서 학습을 완료한 이진 분류 모델을 토대로 테스트를 진행해 보도록 하겠습니다. 모델을 평가 모드로 전환하기 위해서 모델 닷 이밸류에이션 메서드를 작성해 주시고요. 그리고 블록 내부의 코드가 기울기 계산 없이 실행이 되도록 위드 토치 닷 노우 언더 스콜 그레드를 설정해 주겠습니다. 이때 이제 모델의 테스트 특징 변수 즉 x 언더 스콜드 테스트를 입력했을 때 그 예측값 프레딕션스를 계산하는 코드를 작성해 주시고요. 그리고 그 예측 값인 프레딕션스가 0.5보다 크면 1 그렇지 않으면 0으로 변환하는 코드를 이제 작성해서 이진 분류 결과를 생성해내도록 하겠습니다. 이렇게 해서 이제 이진 분류 결과를 생성해 냈으면은 예측 결과와 그 실제 라벨 즉 목표 변수 값을 비교해 봐야 되겠죠. 그러기 위해서 우리가 테스트 목표 변수 텐서를 n파이로 변환을 해주는 이 11번째 줄의 코드를 작성하고 이것을 이제 액추 언더스코어 라벨스 이제 변수에다가 할당을 해 주겠습니다. 이제 객체가 되겠죠 마찬가지로 이제 프레딕티드 언더스코어 라벨스도 우리가 넌 파이 배열로 이제 변환을 하고 그러한 것을 이제 프레딕티드 언더스코어 라벨스라는 변수에 넣어주는 코드 편을 작성해 주도록 하겠습니다. 그러면 이제 우리가 두 객체가 생성이 된 건데요. 네 그리고 이 넘파이 배열로 변환한 이 두 객체를 플랫t 메서드를 통해서 1차원 배열로 출력을 해 주겠습니다. 도대체 왜 1차원 배열로 출력을 할까라고 생각을 하실 수가 있을 텐데요. 실제로 우리가 출력을 해보면 1차원 배열로 출력이 되니까 어떻나요? 비교하기가 너무 좋죠. 그래서 이러한 이유에서 플레톤 함수를 사용해서 1차원 배열로 출력을 한 것입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(10강) Binary Classification2.json",
        "lecture_name": "(10강) Binary Classification2",
        "course": "Machine Learning",
        "lecture_num": "10강",
        "lecture_title": "Binary Classification2",
        "chunk_idx": 1,
        "total_chunks": 3,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:e23cac0b5b1d905def46585e5da45eaea9061c7f5f2c045040cd680aac3e0a73"
      },
      "token_estimate": 1052,
      "char_count": 1966
    },
    {
      "id": "transcript_machine_learning_10강_binary_classification2_c002_9f51a6",
      "content": "[Machine Learning] (10강) Binary Classification2\n\n다. 그러면 이제 우리가 두 객체가 생성이 된 건데요. 네 그리고 이 넘파이 배열로 변환한 이 두 객체를 플랫t 메서드를 통해서 1차원 배열로 출력을 해 주겠습니다. 도대체 왜 1차원 배열로 출력을 할까라고 생각을 하실 수가 있을 텐데요. 실제로 우리가 출력을 해보면 1차원 배열로 출력이 되니까 어떻나요? 비교하기가 너무 좋죠. 그래서 이러한 이유에서 플레톤 함수를 사용해서 1차원 배열로 출력을 한 것입니다. 이제 마지막으로 그 예측 결과를 시각화하기 위해서 피레티다 피규어 함수를 통해 플롯을 생성해 주고요. 그리고 이제 산점도를 그려줄 건데 산점도를 그러려면 이제 PRT 닷 스케터 함수를 사용해야 되겠죠. 그리고 그 옵션 값으로 레인지 그리고 렌 액추얼 언더 스쿨 라벨스 액추 언더 스콜 라벨스는 아까 이제 예측 결과를 뽑아낸 거죠. 예 이것을 x축 좌표로 설정을 해주고요. 액추얼 언더 스쿨 라벨스를 y축 좌표로 설정을 하겠습니다. 이때 컬러는 블루로 해주고 그리고 라벨은 액추얼 라벨스로 설정하도록 하겠습니다. 즉 법렛에서 사용할 레이블을 얘기한 거고요. 실제로 결과를 보면 범 넷에서 사용할 레이블을 액추얼 라벨스라고 되어 있는 거 보이시고 그것이 파란색 점인 것도 알 수가 있겠습니다. 그래서 파란색 점들이 이 찍혀 있죠. 나중에 결과를 도출하면 이렇게 또 등장을 할 겁니다. 그다음에 이제 또 다른 프레딕트드 라벨스를 설정해 줘야 되겠죠. 우리가 앞에서 한 건 액추얼 라벨스를 설정해 준 것이고요. 그래서 프레딕트드 라벨스를 설정해 주기 위해서 옵션 값으로 그러니까 피어티닷 스켈터의 옵션 값으로 레인지 렌 프레딕티드 언더스코어 라벨스를 이제 x축 좌표로 설정을 해주고요. 그리고 프레딕티드 라벨스를 y축 좌표로 설정을 합니다. 그리고 이때 데이터 포인트를 그 레드로 해주되 그것이 빨간 x자 마커야 돼요. 그러니까 빨간색 x자 마커로 설정해 주겠다는 겁니다. 그리고 이를 법내에서 사용할 레이블로 이제 프레딕티드 라벨스를 사용하면 되겠습니다. 즉 프레딕트 라벨스를 이제 그 법률에서 사용할 레이블로 설정하겠다는 것이죠. 실제로 보면은 이와 같이 설정되는 것을 볼 수가 있겠습니다. 그리고 이제 x 레벨 함수를 통해서 샘플 인덱스를 x축 라벨로 이제 우리가 지정을 해주고요. 요 와 레벨 함수를 통해서 그리고 와 라벨을 이제 라벨로 설정을 했죠. 그래서 라벨을 y축 라벨로 이제 설정하도록 하겠습니다. 그리고 이제 레전드 함수를 통해서 이와 같이 번뇌를 뿌려주게 되고요. 또 이제 타이틀 함수를 통해서 우리가 액추얼 벌서스 프레딕티드 라벨스라는 타이틀을 설정해 주도록 하겠습니다. 그리고 쇼 함수를 통해서 이제 플룻을 출력해 주면은 테스트 시각화가 마무리되는 것을 알 수가 있겠습니다. 그래서 실행을 해줘서 이렇게 테스트 시각화를 마무리하도록 하겠습니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(10강) Binary Classification2.json",
        "lecture_name": "(10강) Binary Classification2",
        "course": "Machine Learning",
        "lecture_num": "10강",
        "lecture_title": "Binary Classification2",
        "chunk_idx": 2,
        "total_chunks": 3,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:e23cac0b5b1d905def46585e5da45eaea9061c7f5f2c045040cd680aac3e0a73"
      },
      "token_estimate": 769,
      "char_count": 1433
    }
  ]
}