{
  "source_file": "(9강) Binary Classification1.json",
  "lecture_name": "(9강) Binary Classification1",
  "course": "Machine Learning",
  "total_chunks": 4,
  "chunks": [
    {
      "id": "transcript_machine_learning_9강_binary_classification1_c000_913ae0",
      "content": "[강의 녹취록] 과목: Machine Learning | 강의: 9강 | 제목: Binary Classification1\n\n저희가 크레인 데이터란 패치 데이터를 가르치면 설치 데이터는 트레인 데이터에 포함되지 않은 클래스 데이터를 공급하게 그러면 에 대해 프리트를 살펴보도록 하겠습니다. 확인할 수가 있겠습니다. 그리고 이제 테스트 데이터를 입력하자 연기를 전환하는 함수 마지막 소득권 발표를 보도록 하겠습니다. 다시 말해 시트 입력할 때 원래의 단위로 하는 코드입니다. 자 그러면 이제 포스트 데이터 코드 체크를 입력하겠습니다. 우선 우리가 7강과 8강에서 선형회기 모델 학습을 위해 실행했었던 코드들을 모두 실행해 주도록 하겠습니다. 이제 테스트를 진행해 볼 것인데요. 우리가 8강에서 트레이닝 데이터를 표준화해 주었기 때문에 테스트 데이터 또한 표준화를 진행해 주셔야 되겠죠 네 그래서 이 테스트 데이터를 입력받아 예측된 샐러리를 반환하는 함수를 우리가 정의해 주어야 될 텐데요. 그게 바로 다섯 번째 줄이 되겠습니다. 그리고 제가 슬라이드에서 설명드렸듯이 테스트 데이터를 표준화하는 코드가 있어야 될 텐데 그것이 바로 일곱 번째 줄이 되겠고요. 또 그 표준화한 테스트 데이터를 텐서로 변환해서 디바이스로도 보내줘야 되겠죠 네 그 코드가 바로 여덟 번째 줄이 되겠습니다. 이제 그 모델을 사용해서 예측하는 코드 블록을 살펴보고자 하는데요. 먼저 모델 닷 이밸류에이션 메서드를 통해서 평가 모드로 전환을 해주고요. 그리고 위드 토치 닷 노우 언더스쿨 그레드 이 코드를 통해서 코드 블록 내에서 그 그레디언트를 계산하지 않는 이제 그런 설정을 해주고 또 우리가 학습시켰던 그 모델 있죠 네 이 모델의 테스트 언더 스콜 텐서를 입력해서 그 출력 결과를 프레딕션스 언더 스쿨 스케일드 저장해 주면 되겠습니다. 그런데 이제 여기서 그 예측이 다 끝났다라고 생각하시는 분도 계실 수가 있겠는데요. 하지만 그렇지가 않습니다. 왜냐하면 그 프레딕션 언더스쿨 스케드에 저장된 값은 표준화가 되어 있는 값이기 때문에 우리가 원하는 값이 아닙니다. 따라서 표준화를 해제시켜 주는 것이 필요합니다. 그래서 우리는 스칼라 언더스쿨 티 닷 인버스 언더스쿨 트랜스폼 즉 트랜스폼 한 것을 인벌스 해 주어서 표준화를 해제하는 것이 필요하겠습니다. 그렇게 해서 이제 프레딕션에 반환하시면 이제 되겠고요. 네 그리고 이제 테스트 데이터를 우리가 넌 파이 배열로 이제 변환을 해준 후에 테스트 언더스콜 이어스 언더스콜 익스피리언스에 저장을 해 주시고요. 그리고 이 해당 변수를 프레딕트 언더스쿨 테스트 언더스쿨 데이터 함수에 넣어주어서 그 결과 값을 프레딕 팁 언더 스크롤 셀러리스에다가 저장을 해 주시면 되겠습니다. 그러고 나서 이제 우리가 테스트 언더스쿨 이어스 언더스쿨 익스프리언스 하고 이제 프리딕트 언더스쿨 세러리스 이렇게 쌍으로 묶어주고 그리고 각각의 이어스 익스페리언스하고 그리고 샐러리를 포매팅 해서 출력을 해 주시면 되겠습니다. 그래서 실제로 이제 출력을 해보면요. 네 리얼스 익스피리언스가 1.0일 때 프레딕트 셀러리는 3만 4298이 나오고요. 리얼스 익스피리언스가 2.0일 때 프로젝티드 셀러리는 4만 3748이 나옵니다. 그리고 이어스 익스피리언스가 7.0일 때는 프로젝티드 셀러리가 9만998이 나오는 것을 우리가 확인할 수가 있겠습니다. 이렇게 해서 우리가 테스트를 마무리할 수가 있겠습니다. 피트를 입력해 주 선러리는 라면을 가지면 추려진 데이터를 접하고 저이들은 이 부분 그리고 이러한 데이터를 반듯하게 학습할 수 있는 이 면을 깎지 않는 그러고 나서 rn은 크렌 데이터에 포함되지 않은 포스트 데이터에 대해서 원 지 라고 기자들이 제 독재로 존재하는 이 문제를 모든 국민분들이 생각할 수 있도록 하겠습니다. 이번 슬라이드에서 제시한 국민들에게는 복지와는 다른 것으로 과연 인공지능 의료를 선택하게 됩니다. 도 내지 마시면은 보는 것처럼 코인 데이터는 포함되지 않은 포인트 등이 저와 있을 때 그러면 이제부터 이 과정을 말씀드리고 사태를 보겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(9강) Binary Classification1.json",
        "lecture_name": "(9강) Binary Classification1",
        "course": "Machine Learning",
        "lecture_num": "9강",
        "lecture_title": "Binary Classification1",
        "chunk_idx": 0,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:9dfb4afb8d79a4b8b46f5e3c8f28a22c89dc36444bebbe0f5eb2717f9c51897b"
      },
      "token_estimate": 1080,
      "char_count": 1986
    },
    {
      "id": "transcript_machine_learning_9강_binary_classification1_c001_0ab661",
      "content": "[Machine Learning] (9강) Binary Classification1\n\n다. 이번 슬라이드에서 제시한 국민들에게는 복지와는 다른 것으로 과연 인공지능 의료를 선택하게 됩니다. 도 내지 마시면은 보는 것처럼 코인 데이터는 포함되지 않은 포인트 등이 저와 있을 때 그러면 이제부터 이 과정을 말씀드리고 사태를 보겠습니다. 먼저 트램 계획을 살펴보십시오. 지금 기에서는 네 7강에서와 같이 해글에서 uciml이라는 유저의 아이리스 데이터셋을 다운로드 받아서 아이리스 파일의 압축을 해제해 주도록 하겠습니다. 네 실행을 시켜 주시고요. 이제 그 트레이닝 데이터를 불러오고자 하는데요. 그 판더스 라이브러리를 임포트하고 그리고 아이스 데이터 셋을 불러올 건데요. 여기까지는 우리가 다 같습니다. 근데 이제 그 아리스 데이스터 셋을 이제 열어보면은 변수들이 굉장히 여러 가지인데 그 여러 가지 변수들 중에서 우리는 이제 페탈랜스 센티미터하고 스피시스만 이제 뽑아오고자 합니다. 그래서 이 페탈렌스 열과 스피시스 열에만 접근해서 그 df라는 데이터 프레임을 구성하기 위해서 우리가 그 헤더는 0이라는 옵션 값 뒤에다가 이와 같이 입력을 해 주시면 되겠습니다. 그래서 실행을 해 주고요. 네 그러면 페탈랭스 열하고 스피시스 열만 뽑힌 것을 알 수가 있겠습니다. 다시 그 디프 데이터 프레임에서 그 스피시스 열의 값이 아이리스 세토사 또는 아이리스 버지컬라인 핵만 필터링해서 이제 필터드 언더스쿨 데이터라는 데이터 프레임에 저장을 해 주겠습니다. 이와 같이 필터링을 해주는 이유는 사실 이제 9강하고 10강에서는 이진 분류 시스템에 대해서 살펴볼 것이기 때문입니다. 그래서 아이스 데이터 셋은 종류가 3종이거든요. 근데 그중에서 버즈니카 종을 제외하고 세토사와 버지칼라 종만 필터링을 하도록 하겠습니다. 그리고 이제 필터드 언더스쿨 데이터는 제가 이제부터는 필터드 언더스콜 df로 우리가 부르도록 하겠습니다. 그래서 이제 해당 데이터 프레임을 출력해 보면 다음과 같습니다. 그래서 아리스 세토사하고 아리스 버지칼라만 이렇게 출력이 되는 것을 확인할 수가 있겠습니다. 텍스트 형태의 레이블을 컴퓨터에게 익숙한 이선형 숫자의 레이블로 변환을 해주기 위해서 필터 언더스쿨 디프 데이터 프레임에서 스피스에 접근을 하고 그리고 다시 스페시스 열에서 아리스 세토사 그리고 아리스 버지칼라가 있을 텐데 그중에 아리스 세토사에는 0에다가 매핑을 해주고 아리스 버지칼라에는 1에다 매핑을 해준 후에 다시 필터 언더스쿨 디프 스피시스 대체해 주는 코드를 작성해 주도록 하겠습니다. 네 그리고 이걸 실행해 보면 이제 이와 같이 경고문이 뜨는 게 보이실 텐데요. 사실 이 원본 데이터 프레임의 복사본이 아니기 때문에 해당 경고문을 무시하고 진행하더라도 이후에 문제가 발생하지는 않습니다. 하지만 여기서 공고해 준 바와 같이 록 인덱서를 사용해 볼 수 있도록 하겠습니다. 그럼 변수명을 우리가 이거 대신에 df 닷 럭 해 주시고 그리고 여기다가 콜론 통마를 작성해 주시면 되겠죠. 실행을 해보겠습니다. 그럼 경고문이 사라진 것이 보이겠습니다. 그럼 이제 특징 변수와 목표 변수를 각각 추출해 볼 수 있도록 하겠습니다. 이를 위해 이제 데이터 프레임에서 특징 변수 페탈 랭스 센티미터 열을 선택해서 2차원 배열로 변환을 해 주겠습니다. 네 스퀘어 블라켓이 2개죠 네 그래서 2차원으로 변환해 주는 것이고요. 그리고 스피시스 열을 선택해서 1차원 배열로 변환을 해 주겠습니다. 여기서 이 페탈러 센티미터 열을 2차원 배열로 변환을 해 주었는데 이는 표준화 그러니까 데이터를 표준화할 때 2차원 배열을 요구했기 때문입니다. 우리가 8강에서 배웠었죠 혹시 이 부분이 기억이 나지 않으신다면 그 8강에 1.4절 그 데이터 표준화를 다시 보고 오시면 좋을 것 같습니다. 그러면 이제 실행을 해보도록 하겠습니다. 네 실행을 하면은 이제 우리가 그 목표 변수를 이제 이상형 레이블로 매핑하고 특징 변수와 목표 변수를 추출하는 코드 표현을 이제 완성이 되겠습니다. 그럼 실습을 여기까지 하도록 하겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(9강) Binary Classification1.json",
        "lecture_name": "(9강) Binary Classification1",
        "course": "Machine Learning",
        "lecture_num": "9강",
        "lecture_title": "Binary Classification1",
        "chunk_idx": 1,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:9dfb4afb8d79a4b8b46f5e3c8f28a22c89dc36444bebbe0f5eb2717f9c51897b"
      },
      "token_estimate": 1083,
      "char_count": 1993
    },
    {
      "id": "transcript_machine_learning_9강_binary_classification1_c002_fb703a",
      "content": "[Machine Learning] (9강) Binary Classification1\n\n다. 여기서 이 페탈러 센티미터 열을 2차원 배열로 변환을 해 주었는데 이는 표준화 그러니까 데이터를 표준화할 때 2차원 배열을 요구했기 때문입니다. 우리가 8강에서 배웠었죠 혹시 이 부분이 기억이 나지 않으신다면 그 8강에 1.4절 그 데이터 표준화를 다시 보고 오시면 좋을 것 같습니다. 그러면 이제 실행을 해보도록 하겠습니다. 네 실행을 하면은 이제 우리가 그 목표 변수를 이제 이상형 레이블로 매핑하고 특징 변수와 목표 변수를 추출하는 코드 표현을 이제 완성이 되겠습니다. 그럼 실습을 여기까지 하도록 하겠습니다. 트레이닝 데이터와 테스트 데이터를 분할하기 위해 사이클론 닷 모델 언더스쿨 셀렉션 모듈에서 트레인 언더스쿨 테스트 언더스쿨 스펠릿 함수를 인포트하도록 하겠습니다. 트레인 언더스크롤 테스트 언더스쿨 스프릿 함수의 옵션 값을 살펴보면 스콤마 티 콤마 테스트 언더스크롤 사이즈는 0.2 그리고 랜덤 언더 스크롤 스테이트는 42라고 작성이 되어 있는데요. x하고 t 이것은 이제 특징 변수 x하고 목표 변수 t죠. 그래서 특징 변수 x와 목표 변수 t를 스플릿 섞되 그 트레이닝 데이터 대 테스트 데이터는 8 대 2의 비율로 설정을 하고 난수 시드는 이제 랜덤 언더 스쿨 스테이트 이것은 42로 설정하겠다는 것입니다. 여기서 42는 관습적으로 사용되는 숫자라고 말씀을 드렸습니다. 그래서 이것을 실행해 주시면 우리가 데이터를 분할할 수가 있겠습니다. 사실 데이터 표준화는 우리가 8강에서 살펴보았었습니다. 사이캔 런에 스탠다드 스칼라를 임포트해 주고요. 그리고 스탠다드 스칼라 인스턴스를 생성해 주면 되겠습니다. 그다음 줄 보시면 스칼라 닷 잇 언더스쿨 트랜스폼 메서드가 이제 나와 있는데 이 메서드를 통해서 우리가 평균과 표준 편차를 계산하고 표준화를 할 수가 있습니다. 우리가 8강에서는 리쉐인 메서드를 통해서 데이터를 2차원 배열로 변환을 해 주었었는데요. 여기서는 이제 하지 않고 있죠. 왜냐하면 앞에서 특징 변수 스를 추출하는 과정에서 2차원 배열로 변환을 해주었기 때문입니다. 테스트 데이터도 마찬가지로 특징 변수를 표준화해 주시면 되겠고요. 네 그러면 이제 실행을 할 수 있도록 하겠습니다. 네 그러면 데이터 표준화는 여기까지 진행하면 될 것 같습니다. 데이터를 텐서로 이제 변환해 주려고 하는데요. 데이터를 텐서로 변환해 주기 위해서 여기서 보시면 토치닷 텐서 함수를 사용하고 있고요. 이 토치닷 텐서 함수의 아규먼트로 특징 변수와 목표 변수의 트레인 데이터와 테스트 데이터들을 각각 입력해 주고 있습니다. 그리고 매개 변수로는 모두 이제 32비트 부동 소수점을 입력해 주었습니다. 여기서 이제 목표 변수에 이제 트레인 데이터하고 테스트 데이터를 좀 살펴볼 필요가 있는데요. 이 목표 변수의 트레인 데이터와 테스트 데이터 경우에는 모두 언스퀴즈 함수를 통해서 엔 1열에 2차원 텐서로 변환을 해주고 있습니다. 그러면 이제 실행을 해보도록 하겠습니다. 네 이제 이렇게 해서 우리가 실행을 해 줬고요. 데이터를 다 텐서로 변환을 해주었습니다. 그러면 이제 커스텀 데이터셋 클래스를 만들고 데이터 로드를 만들어서 배치 사이즈를 설정하는 방법에 대해 살펴보도록 하겠습니다. 먼저 토치닷 유트스 데이터 모듈을 인포트 해 주시고요. 그리고 데이터 셋을 상속받는 커스텀 데이터셋을 이제 정리를 해주어야 되는데요. 근데 이제 데이터 셋을 상속받았으므로 이닛 그리고 랜 겟 아이템 함수를 재정의해 주셔야겠습니다. 먼저 우리는 이닛 함수를 통해서 입력으로 들어온 피처스 그리고 라벨스를 클래스의 내부 변수로 저장해 주는 간단한 코드를 이제 구현해 줄 수가 있겠고요. 두 번째로 렌 함수를 통해서 데이터의 크기를 반환해 주는 코드를 구현해 줄 수가 있겠습니다. 마지막으로 겟 아이템 함수를 통해서 매개 변수로 들어온 인덱스에 대해 인덱스에 해당하는 피처 스와 라벨 스를 반환해 주는 코드를 구현해 줄 수가 있겠습니다. 그리고 이제 이를 실행하면은 우리가 원하는 커스텀 데이터셋 클래스를 완성할 수가 있겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(9강) Binary Classification1.json",
        "lecture_name": "(9강) Binary Classification1",
        "course": "Machine Learning",
        "lecture_num": "9강",
        "lecture_title": "Binary Classification1",
        "chunk_idx": 2,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:9dfb4afb8d79a4b8b46f5e3c8f28a22c89dc36444bebbe0f5eb2717f9c51897b"
      },
      "token_estimate": 1093,
      "char_count": 2016
    },
    {
      "id": "transcript_machine_learning_9강_binary_classification1_c003_6bfb0d",
      "content": "[Machine Learning] (9강) Binary Classification1\n\n다. 먼저 우리는 이닛 함수를 통해서 입력으로 들어온 피처스 그리고 라벨스를 클래스의 내부 변수로 저장해 주는 간단한 코드를 이제 구현해 줄 수가 있겠고요. 두 번째로 렌 함수를 통해서 데이터의 크기를 반환해 주는 코드를 구현해 줄 수가 있겠습니다. 마지막으로 겟 아이템 함수를 통해서 매개 변수로 들어온 인덱스에 대해 인덱스에 해당하는 피처 스와 라벨 스를 반환해 주는 코드를 구현해 줄 수가 있겠습니다. 그리고 이제 이를 실행하면은 우리가 원하는 커스텀 데이터셋 클래스를 완성할 수가 있겠습니다. 앞에서 커스텀 데이터셋 클래스를 정의해 주었었는데요. 그럼 이제 다음과 같이 아이스 데이터셋 클래스를 생성하면 트레인 데이터셋과 테스트 데이터셋이라는 인스턴스를 생성할 수가 있겠습니다. 이렇게 생성된 데이터셋 인스턴스를 우리가 원하는 배치 크기를 지정해 준 후에 데이터 로더 클래스를 이용해서 우리가 원하는 트레인 언더스코어 로더와 테스트 언더 스코어 로더라는 데이터 로더 인스턴스를 만들어 줄 수가 있겠습니다. 이렇게 되면 우리가 만들어준 데이터 로더 인스턴스를 통해서 원래 데이터를 설정한 배치 크기만큼 묶어줄 수가 있습니다. 네 그럼 코드를 실행하고 마무리해 보도록 하겠습니다. 이진 분류 모델 구축을 위한 코드 페어는 7강에서 선형회기 모델 구축을 위한 코드 표현과 그 방식이 거의 동일합니다. 이진 분류 모델 구축을 위해 토치 닷 뉴럴 네트워크 모듈을 임포트하고 그리고 뉴럴 네트워크 단 모듈을 상속받을 수 있도록 바이너리 클래시피케이션 모델 클래스에 선언을 해 줍니다. 그러고 나서 생성자 메서드로 미닛 메서드를 정의해 주시고요. 부모 클래스의 속성 및 메서드를 자식 클래스에서 받아올 수 있도록 설정하기 위해 슈퍼 함수를 불러주시고 바이너리 클래시피케이션 모델과 셀프를 아규먼트로 전달하시면 되겠습니다. 그리고 나서 셀프 닷 레이어 언더스코어 1은 뉴럴 네트워크 리니어 1 콤마 1이라는 이제 코드가 있는데요. 이것은 함수의 호출의 결과를 객체의 속성에 할당하는 코드로서 뉴럴 네트워크 닷 리니어 클래스 안에 1 콤마 1은 생성자 메서드에 전달되는 아규먼트로서 앞의 1은 입력 차원, da1은 출력 차원을 의미한다고 제가 지난번에 말씀을 드렸습니다. 그런데 이진 분류 모델에서는 선형 회기 모델의 출력 값이 다시 시그모이드 함수의 입력 값으로 들어가야 하기 때문에 셀프 닷 시그모이드는 뉴럴 네트워크 닷 시그모이드 속성 코드를 추가로 작성을 해 주셔야 합니다. 이제 순전파 메소드로 푸드 메소드를 정의해 주고 앞에서 생성한 셀프 닷 레이어 언더스코 1 객체에 입력 데이터 x를 넣어주어서 출력 값으로 c를 받고 다시 지를 셀프 닷 시그모이드 객체에 입력하여 결과값으로 y를 바나나는 코드 블록을 완성함으로써 이진 분류 모델을 구축할 수가 있겠습니다. 그리고 이 클래스를 바탕으로 인스턴스 모델을 생성해 주시면 되겠습니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(9강) Binary Classification1.json",
        "lecture_name": "(9강) Binary Classification1",
        "course": "Machine Learning",
        "lecture_num": "9강",
        "lecture_title": "Binary Classification1",
        "chunk_idx": 3,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:9dfb4afb8d79a4b8b46f5e3c8f28a22c89dc36444bebbe0f5eb2717f9c51897b"
      },
      "token_estimate": 796,
      "char_count": 1466
    }
  ]
}