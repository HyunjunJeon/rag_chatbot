{
  "source_file": "(3강) Creating Tensors.json",
  "lecture_name": "(3강) Creating Tensors",
  "course": "PyTorch",
  "total_chunks": 4,
  "chunks": [
    {
      "id": "transcript_pytorch_3강_creating_tensors_c000_8bec0e",
      "content": "[강의 녹취록] 과목: PyTorch | 강의: 3강 | 제목: Creating Tensors\n\n먼저 영어로 초기화된 텐서를 생성하는 코드 표현 실습을 진행해 보겠습니다. 토치 닷 제스 함수의 아규먼트로 o를 입력해 주고 이를 변수 a에 할당한 후에 a를 출력해 보겠습니다. 그러면 0으로 초기화된 요소 5개를 가지고 있는 1차원 텐서 a가 출력됨을 확인할 수가 있겠습니다. 크기를 살펴보면은 요소가 5개니까 5가 나오는 것 알 수가 있겠고요. 데이터 타입도 살펴보면 32비트 부동 소수점 수임을 알 수가 있겠습니다. 이번에는 토치 헤드 제로스 함수의 아규먼트로 스퀘어 블라켓 2 콤마 3을 입력하고 이를 변수 피에 할당한 후에 비를 출력해 보겠습니다. 그러면 0으로 초기화된 요소가 2행 3열로 이루고 있는 2차원 텐서 b가 출력됨을 확인하실 수가 있겠습니다. 크게 살펴볼까요? 이를 살펴보면 2행 3열인 거 알 수가 있겠고요. 그리고 데이터 타입 또한 32비트 부동 소수점 수임을 알 수가 있겠습니다. 이번에는 토치 닷 제로즈 함수의 아규먼트로 스퀘어 블라켓 3 콤마 2 콤마 4를 입력하고 이를 변수 c에 할당한 후에 c를 출력해 보겠습니다. 그러면 0으로 초기화된 요소가 3개의 이행 사유를 이루고 있는 3차원 텐서 씨가 출력됨을 확인하실 수가 있겠습니다. 이제 1로 초기화된 텐서를 생성하는 코드 표현 실습을 진행해 보고자 하는데요. 사실 1로 초기화된 텐서는 토치 제루스 함수 대신에 토치 원스 함수를 사용하시면 되고 메커니즘은 같기 때문에 실행만 해보고 지나가도록 하겠습니다. 그래서 1로 초기화된 요소를 3개 가지고 있는 1차원 텐서 뒤를 출력해 보고요. 그리고 1로 초기화된 요소가 3개 3행 2열이죠. 그냥 네 3행 2열을 이루고 있는 2차원 텐서 1을 출력해 보았고요. 그리고 1로 초기화된 요소가 3개의 2행 3열을 이루고 있는 3차원 텐서 프가 출력됐음을 우리가 확인할 수가 있겠습니다. 그렇죠? 네 이렇게 3개의 이행 3열인 거 확인 가능하시죠? 네 이제 그 크기와 자르기 같은 0으로 초기화된 펜서로 변환하는 코드 표현 실습을 진행해 보도록 하겠습니다. 먼저 데이터 타입이 32비트 부동 소수점 수이면서 1로 초기화된 요소가 3행 2열을 이루고 있는 2차원 텐서 1을 데이터 타입도 32비트 부동 소수 수이면서 크기도 같은 0으로 초기화된 텐서로 변환을 해보도록 하겠습니다. 이를 위해서는 이제 토치 닷 제로스 언더 스코어 라이 함수를 입력해 주시면 되고요. 네 아규먼트로 변환하고자 하는 이제 텐서 1을 입력하고 그리고 변수 치에 할당해 주시면 지는 데이터 타입이 32비트 부동 소수점 수이면서 0으로 초기화된 요소가 3인 이하를 이루고 있는 2차원 텐서로 변환이 된다는 것을 확인할 수가 있겠습니다. 반대로 이제 데이터 타입이 32비트 부동소수점 쓰이면서 0으로 초기화된 요소가 2행 3열을 이루고 있는 2차원 텐서 비를 32비트 부동 소수점 쓰이면서 크기도 같은 1로 초기화된 텐서로 변환을 해보도록 하겠습니다. 유사하게 토치 닷 원스 언더스코 라이 함수를 입력해 주시면 되겠고요. 아규먼트로 변환시키고자 하는 텐서 b를 입력해서 변수 h에다가 할당을 해 주시면 되겠습니다. 그러면은 이제 h는 데이터 타입이 32비트 부동소수점 수이면서 1로 초기화된 요소가 2행 3열을 이루고 있는 2차원 텐서가 이렇게 변환된다는 것을 확인할 수가 있겠습니다. 01 폐구간의 연속 균등 분포 난수 텐서를 생성하기 위해서는 랜덤 함수를 사용하면 된다고 말씀을 드렸었는데요. 여기서 아규먼트를 3을 줬으니 요소가 3개인 1차원 텐서가 생성될 것이고 실제로 출력을 해보면 0과 1의 폐 구간의 난수들로 출력이 되는 것을 확인하실 수가 있겠습니다. 크기를 2행 3열로 주고 싶다면 아규먼트로 스퀘어 블라켓 이 콤마 3으로 주시면 되겠고 출력 결과 0과 1 폐구간의 난수 드림을 확인할 수가 있겠습니다. 이번에는 표준 정규분포 난수 텐서를 생성하는 코드 표현에 대해 살펴보도록 하겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(3강) Creating Tensors.json",
        "lecture_name": "(3강) Creating Tensors",
        "course": "PyTorch",
        "lecture_num": "3강",
        "lecture_title": "Creating Tensors",
        "chunk_idx": 0,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:0e3e081f436ab910f90a71b0e5691d399f9927fc50b35f98463fedf00ce41dc1"
      },
      "token_estimate": 1032,
      "char_count": 1956
    },
    {
      "id": "transcript_pytorch_3강_creating_tensors_c001_c3ec6d",
      "content": "[PyTorch] (3강) Creating Tensors\n\n다. 01 폐구간의 연속 균등 분포 난수 텐서를 생성하기 위해서는 랜덤 함수를 사용하면 된다고 말씀을 드렸었는데요. 여기서 아규먼트를 3을 줬으니 요소가 3개인 1차원 텐서가 생성될 것이고 실제로 출력을 해보면 0과 1의 폐 구간의 난수들로 출력이 되는 것을 확인하실 수가 있겠습니다. 크기를 2행 3열로 주고 싶다면 아규먼트로 스퀘어 블라켓 이 콤마 3으로 주시면 되겠고 출력 결과 0과 1 폐구간의 난수 드림을 확인할 수가 있겠습니다. 이번에는 표준 정규분포 난수 텐서를 생성하는 코드 표현에 대해 살펴보도록 하겠습니다. 표준 정규분포 난수 텐서를 생성하기 위해서는 랜덤 노말 함수를 사용하면 되고요. 그리고 랜드 즉 랜덤 함수처럼 아규먼트로 이와 같이 3을 입력해 주면 요소가 3개인 1차원 텐서가 생성이 되겠습니다. 실제로 출력을 해 보면 표준 정규분포 구간의 난수들이 출력되는 것을 확인하실 수가 있겠습니다. 마찬가지로 그 아규먼트로 스퀘어 블라켓 2 콤마 3을 주면 크기가 2행 3열이면서 요소들은 표준 정규분포 구간의 난수들로 우리가 출력이 되는 것을 이와 같이 확인할 수가 있겠습니다. 이제 01 폐구간에 연속 균등 분포 난수 텐서나 표준 정규 분포 난수 텐서로 변환하는 실습을 진행해 보도록 하겠습니다. 우선 크기와 자료형이 01 해구 간의 연속 균등 분포 난수 텐서로 변환하기 위해서는 초치 닷 랜드 그리고 언더스코어 라이크 함수를 입력해 주시면 되겠습니다. 그리고 또 아규먼트로는 그 변환시키고자 하는 텐서 k를 입력해서 변수 m에다가 할당을 해 주시면 m은 0과 1의 폐구간의 연속 균등 분포 난수 텐서로 변환이 됨을 확인할 수가 있겠습니다. 실제로 한번 출력을 해보죠. 네 그러면 이와 같이 나온다는 것을 확인할 수가 있겠죠. 마찬가지로 표준 정규분포 난소 텐서로 변환하기 위해서는 토치 다 또 랜덤 노말 랜드 앤 언더 스컬 라이크 함수를 사용하여 출력을 하시면 되겠습니다. 지정된 범위 내에서 초기화된 텐서를 생성하는 함수는 어레인지 함수를 사용한다고 말씀을 드렸으며 시작값은 1 그리고 끝 값은 11 간격은 2로 설정을 해줄 수가 있겠습니다. 그리고 실제로 출력을 해보면 이와 같이 1 3, 5, 7 9로 간격이 2이면서 시작 값은 1 그리고 끝 값은 11 끝값은 포함하지 않으니까 11일 바로 앞까지 우리가 출력을 하는 거니까 부로 출력이 된 것을 아실 수가 있죠. 네 그래서 실제로 이와 같이 출력이 되는 것도 확인할 수가 있겠습니다. 4개 변수로 스타트는 엔드는 스태븐과 같이 입력하지 않고 숫자만 이렇게 입력을 하셔도 실제로 출력을 해보면 네 같은 결과가 나온다는 것을 확인할 수가 있겠습니다. 그리고 간격을 우리가 또 0.5와 같이 소수로 입력하여 출력을 하는 것도 가능합니다. 실제로 출력된 값을 살펴보면 이와 같이 1 1.5 2 2.5 3 3.5와 같이 출력이 된다는 것을 확인할 수가 있겠습니다. 마찬가지로 또 매개 변수 없이 숫자만 입력하셔도 이와 같이 모방하다는 것도 알 수 있겠습니다. 그리고 제가 또 추가로 하나 설명드리고 싶은 것이 있는데요. 이와 같이 간격을 우리가 정수를 줬을 때 실제로 그 데이터 타입을 보면요. 네 그 값들이 네 인테저 64비트로 이루어져 있는 것을 볼 수가 있겠습니다. 데이터 타입이 인테저 64비트라는 얘기죠. 그런데 간격을 소수로 주게 되면은 네 결괏값이 어쩔 수 없이 그 실수형 즉 부동 소수 점수로 나올 수밖에 없겠죠. 그렇기 때문에 그때 또 데이터 타입을 살펴보면은 정수형이 아니라 플루트 32비트라는 것을 알 수가 있겠습니다. 그래서 이러한 부분도 또 여러분들께서 또 추가로 알아두시면 좋을 것 같습니다. 이러한 마음은 체계화될 수 있는 성과를 낼 수 있습니다. 그러면 체계화되어 있지 않으면 성과를 항상 인천에 빠뜨리도록 하겠습니다. 표기화되지 않은 텐서를 생성하는 함수는 토치 닷 mt라고 말씀을 드렸었습니다. 그리고 생성하고자 하는 텐서의 요소의 개수 5를 이와 같이 아규먼트로 입력을 해 주시고 출력하게 되면 요소가 5개인 초기화되지 않은 캔서 큐를 생성할 수가 있겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(3강) Creating Tensors.json",
        "lecture_name": "(3강) Creating Tensors",
        "course": "PyTorch",
        "lecture_num": "3강",
        "lecture_title": "Creating Tensors",
        "chunk_idx": 1,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:0e3e081f436ab910f90a71b0e5691d399f9927fc50b35f98463fedf00ce41dc1"
      },
      "token_estimate": 1079,
      "char_count": 2028
    },
    {
      "id": "transcript_pytorch_3강_creating_tensors_c002_107f7c",
      "content": "[PyTorch] (3강) Creating Tensors\n\n다. 그래서 이러한 부분도 또 여러분들께서 또 추가로 알아두시면 좋을 것 같습니다. 이러한 마음은 체계화될 수 있는 성과를 낼 수 있습니다. 그러면 체계화되어 있지 않으면 성과를 항상 인천에 빠뜨리도록 하겠습니다. 표기화되지 않은 텐서를 생성하는 함수는 토치 닷 mt라고 말씀을 드렸었습니다. 그리고 생성하고자 하는 텐서의 요소의 개수 5를 이와 같이 아규먼트로 입력을 해 주시고 출력하게 되면 요소가 5개인 초기화되지 않은 캔서 큐를 생성할 수가 있겠습니다. 하지만 해당 텐서의 요소의 값들이 마음에 들지 않을 수가 있겠죠. 그래서 그때 해당 텐서의 요소의 값들을 다른 요소의 값으로 변경하고 싶을 때 사용하는 함수가 토치 닷 필 언더 스코어이며 이 함수에 전달되는 값으로 아까 생성한 텐서 큐와 아규먼트로 3.0을 입력하고 출력을 하게 되면 펜서 큐의 요소들이 3.0으로 변경되는 것을 확인할 수가 있겠습니다. 그리고 토치닷 엠티의 아규먼트로 2행 3열의 사이즈를 입력하고 출력하는 것도 가능하고요. 그리고 토치 닷 휠 언더스코어 함수를 사용해서 해당 텐서의 요소의 값들을 아래와 같이 변경하는 것도 가능하겠습니다. 리스트 데이터로부터 텐서를 생성하기 위해서는 우선 리스트 데이터를 생성을 해주고 토치 닷 텐서 함수를 통해서 리스트를 텐서로 생성이 가능합니다. 출력하면 텐스로 변환된 것이 보이시죠. 또 넌 파이 데이터로부터 이제 텐서를 생성하기 위해서는 우선 넌 파이 데이터를 생성을 해 주고요. 그리고 토치 닷 프럼 언더스코어 넌 파이 함수를 통해서 넌 파이 데이터를 이제 텐서로 생성할 수도 있습니다. 실제로 우리가 출력을 해보면 넌 파이 데이터가 텐서 데이터로 바뀐 것을 우리가 확인할 수가 있겠습니다. 그리고 이제 넘파이 데이터 같은 경우에는 정수형 데이터가 나오기 때문에 우리가 플롯 메서드를 통해서 그 부동 소수점 타입으로 변환을 해줄 수도 있습니다. 그래서 이와 같이 토치 닥 프록 언더 스크롤 넘 파이 그리고 플롯 네 이 메서드를 사용하면은 우리가 구동 소수점 타입으로도 변환할 수 있다는 것을 알아두시면 되겠습니다. 먼저 정수형 CPU 텐서를 생성하기 위해서는 토치 닷 인tes 텐서 함수를 사용하면 되겠습니다. 출력을 해보면 부호가 있는 32비트 정수형 데이터 타입임을 알 수가 있겠습니다. 그리고 a b c d 각각의 변수의 이제 1 2 3 4 5 값을 이제 각각 할당해 주는 거죠. 네 이렇게 할당한 후에 출력하는 것도 가능합니다. 그래서 출력을 해보면 동일한 결과가 나온다는 것을 확인할 수가 있겠습니다. 이제 실수형 CPU 텐서를 생성하기 위해서 이제 토치 닷 플롯 텐서 함수를 사용하면 되겠는데요. 네 출력을 한번 해보겠습니다. 출력을 해보면 이제 이 각각의 요소들을 보면은 1 2점 3점과 같이 네 실수형 값으로 생성되었음을 우리는 확인할 수가 있겠습니다. 이제 텐서 복제에 대해서 살펴볼 건데요. 먼저 1 2 3 4 5 6 요소를 가진 1차원 텐서 스를 생성하도록 하겠습니다. 예 그랬을 때 우리가 클론 메서드의 반환 값을 변수 와에 할당할 경우에 센서가 이제 복제된다는 것을 알 수가 있겠고요. 그리고 또 다른 또 텐서 복제 방법이 있는데요. 디테치 메서드의 반환 값을 또 뒤에 또 할당을 하게 되면은 똑같이 이제 텐서가 복제됨을 확인하실 수가 있겠습니다. 훨씬 더 빠른 로 3는 것을 발표가 있었습니다. AI 인증서 국회에 사용하는 또 다른 이유는 문제가 있기 때문입니다. 국회에 가입한 사회의 다른 것인 이 있습니다. 그럼 이 보험은 분리자 행사가 수입자가 현재 어떤 급여의 가 있는지 확인하지 못해 수입자를 형성한 이후 관리권이 부여했어야 부과할 수 있으로 사용되는 1 2 3의 요소를 가진 1차원 텐서 a를 생성했을 때 a 닷 디바이스의 어트리뷰트를 출력을 해보면 현재 CPU 디바이스에 있음을 확인하실 수가 있겠습니다. 이제 현재 환경이 쿠다를 사용할 수 있는 환경인지 확인해 보기 위해 토치 닷 쿠다 닷 이스 언더스쿨 어베이러블 함수를 사용해 보도록 하겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(3강) Creating Tensors.json",
        "lecture_name": "(3강) Creating Tensors",
        "course": "PyTorch",
        "lecture_num": "3강",
        "lecture_title": "Creating Tensors",
        "chunk_idx": 2,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:0e3e081f436ab910f90a71b0e5691d399f9927fc50b35f98463fedf00ce41dc1"
      },
      "token_estimate": 1066,
      "char_count": 1996
    },
    {
      "id": "transcript_pytorch_3강_creating_tensors_c003_a7c6ad",
      "content": "[PyTorch] (3강) Creating Tensors\n\n다. 국회에 가입한 사회의 다른 것인 이 있습니다. 그럼 이 보험은 분리자 행사가 수입자가 현재 어떤 급여의 가 있는지 확인하지 못해 수입자를 형성한 이후 관리권이 부여했어야 부과할 수 있으로 사용되는 1 2 3의 요소를 가진 1차원 텐서 a를 생성했을 때 a 닷 디바이스의 어트리뷰트를 출력을 해보면 현재 CPU 디바이스에 있음을 확인하실 수가 있겠습니다. 이제 현재 환경이 쿠다를 사용할 수 있는 환경인지 확인해 보기 위해 토치 닷 쿠다 닷 이스 언더스쿨 어베이러블 함수를 사용해 보도록 하겠습니다. 그러면은 트루가 나오는 걸 보이시죠 따라서 현재 그 쿠다를 사용할 수 있는 환경임을 확인할 수가 있겠습니다. 그리고 이 함수는 7강부터 다시 등장하는 함수이기 때문에 잘 숙지해 두시면 좋을 것 같습니다. 그리고 우리가 현재 장치에서 사용하고 있는 쿠다 디바이스 이름을 확인하는 코드도 있습니다. 이 토치 닷 쿠다 닷 겟 언더스콜 디바이스 언더스콜 네임 함수를 사용하시면 되고요. 여기에 이제 디바이스를 0으로 설정해 주면 그에 맞는 디바이스 이름을 확인하실 수가 있겠습니다. 현재 이제 그 테슬라 t4라고 나오죠 네 따라서 우리가 현재 장치에서 사용하고 있는 쿠다 디바이스 이름은 테슬라 t4임을 알 수가 있겠습니다. 그리고 사용 가능한 GPU 개수를 확인하는 코드도 있습니다. 토치 닷 쿠다닷 디바이스 언더스코어 카운트 함수를 사용하시면 되고요. 실제로 출력을 해보면 네 제 현재 노트북에서는 1개를 사용할 수 있음을 확인할 수가 있겠습니다. 이제 중요한데요. 텐서를 GPU에 할당하는 코드입니다. 먼저 텐서를 이와 같이 생성해 준 후에 그다음에 투 메서드를 통해서 GPU를 그러니까 할당이 가능하겠습니다. 그래서 실제로 출력을 해보면 텐서가 출력이 되고 이 디바이스가 후다라는 것을 확인하실 수가 있겠죠. 또한 이 투 메서드 외에도 쿠다 메서드를 또 사용해서도 우리가 GPU 할당이 가능하겠습니다. 그리고 때로는 그 GPU에 할당된 텐서를 다시 CPU 텐서로 변환이 필요한 경우도 있을 텐데요. 마찬가지로 이와 같이 투 메서드를 사용하셔도 좋고요. 네 실제로 출력해 보면 디바이스가 사라진 거 보이시죠? 네 디바이스는 쿠다가 사라졌습니다. 아니면 직접적으로 씨피유 메서드를 사용해 가지고 또 출력을 하면 네 씨피유 텐서로 변환이 가능한 것을 확인할 수가 있겠습니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(3강) Creating Tensors.json",
        "lecture_name": "(3강) Creating Tensors",
        "course": "PyTorch",
        "lecture_num": "3강",
        "lecture_title": "Creating Tensors",
        "chunk_idx": 3,
        "total_chunks": 4,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:0e3e081f436ab910f90a71b0e5691d399f9927fc50b35f98463fedf00ce41dc1"
      },
      "token_estimate": 636,
      "char_count": 1193
    }
  ]
}