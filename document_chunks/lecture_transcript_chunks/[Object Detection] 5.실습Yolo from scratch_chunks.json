{
  "source_file": "[Object Detection] 5.실습Yolo from scratch.json",
  "lecture_name": "[Object Detection] 5.실습Yolo from scratch",
  "course": "Object Detection",
  "total_chunks": 5,
  "chunks": [
    {
      "id": "transcript_object_detection_object_detection_5실습yolo_from__c000_380c6b",
      "content": "[강의 녹취록] 과목: Object Detection | 제목: 5.실습Yolo from scratch\n\n네 안녕하세요. 이번 시간에는 저희가 5강 욜로에 대해서 학습을 했었잖아요. 그 욜로 버전 1에 대한 그 코드에 대해서 프롬 스크래치로 한번 구현해 보는 시간을 갖도록 하겠습니다. 네 먼저 이제 욜로 버전 1을 프롬 스크래치로 어떻게 구현할 수 있는지에 대해서 같이 한번 코드 리뷰를 해보도록 하겠습니다. 그래서 저희가 이제 이런 코레 파일 하나 제공해 드릴 생각이고요. 같이 따라와 오면서 한번 이제 코드를 작성해 보는 시간을 가져보겠습니다. 먼저 메인부터 한번 같이 볼까요? 맨 아래에 학습 가능한 트레인 트레이너 메인이 있는데요. 이제 메인부터 같이 살펴보면은 일단 여러 가지 필요한 라이브러리를 로드하고요. 그다음에 뭐 시도 고정해 주고 이렇게 하이퍼 파라미터들을 정의를 해 줍니다. 러닝 렛이랑 그 디바이스 쿠다에 돌 건지 CPU에서 돌 건지 그다음에 배치 사이즈 그다음에 뭐 웨이트 tk 4 워커 개수 기타 등등 이렇게 정의를 해 주고요. 그다음에 저희가 사용할 트랜스폼에 대해서 정의를 해줘서 이제 이미지와 바운딩 박스로 리턴할 수 있게끔 그러니까 먼저 위에서 뭐 어떻게 정의된 트랜스폼을 넣어주게 되면은 이 컴포즈를 호출을 했을 때 트랜스포즈 통과하고 이미지와 박스가 리턴이 되겠죠. 이 부분 같은 경우는 여러분들께서 어그멘테이션 코드로 바꿔서 사용을 하셔도 됩니다. 어쨌든 이렇게 트랜스포즈가 나오게 되면은 저희 트랜스포즈 같은 경우에는 리사이즈랑 2 텐서를 같이 진행을 해줍니다. 그래서 이미지에 리사이즈 2 텐서 된 결과와 바운딩 박스가 같이 예측이 되겠죠 그다음에 트레이너 펑션이 다음과 같고 메인 펑션 아래서 트레이너 펑션이 호출이 되는데요. 먼저 이제 메인 펑션부터 같이 살펴보겠습니다. 메인 펑션에는 먼저 이제 모델을 생성을 합니다. 욜로 버전 1 모델을 생성을 해주고 옵티마이저로는 아동 옵티마이저 그다음에 욜로 로스 생성을 해 줍니다. 그래서 뭐 프리 트렌드 웨이트 있을 시에는 로드 해 주고요. 그다음에 저희 커스텀 데이터셋으로 저희 데이터셋을 이렇게 로드를 해주고 테스트 데이터 로드하고 그거를 이제 로더에 이렇게 넣어줘야겠죠. 그래서 배치별로 묶여서 데이터가 나올 수 있으니까요. 문으로 이렇게 넣어주고 학습을 들어가면 되는데요. 먼저 그 과정에서 저희 커스텀 데이터 셋부터 같이 한번 살펴보도록 하겠습니다. 네 먼저 이제 커스텀 데이터 셋 보면은 그냥 토치 데이터셋을 상속받아서 이제 어떻게 이닛을 해 주냐면은 어노테이션 파일 데이터 디렉토리 그다음에 이제 커스텀 롤로 데이터 셋이기 때문에 셀 몇 바위 몇 셀로 최종적으로 아웃풋이 나오게 될 것인지 그다음에 박스의 개수 그다음에 저희가 클래스의 개수가 필요했잖아요. 클래스의 개수 트랜스폼 이렇게 같이 먼저 넘겨주면서 정의를 해 줍니다. 정의해 줄 때 코코 데이터로부터 어노테이션 파일 읽어야겠죠. 읽고 이미지 위치 그다음에 카테고리 정보 그다음에 이런 것들을 프레딕션으로 만들어 주고요. 기타 등등 아까 셀 바운딩 박스 개수 클래스 개수 이런 것들 네 넣어줍니다. 그다음에 중요한 건 이 커스텀 데이터 셋에 저희가 인덱스를 넣어주게 되면은 데이터 아이템 하나하나씩 가져오는데 어떻게 가져오냐면은 이렇게 이미지 아이디 가져오고요. 그다음에 이미지 정보 가져오고 실제로 이미지를 로드하죠. 여기서는 이제 pil 파일 이용 pil 라이브러리 이용해서 이미지를 업로드합니다. 그다음에 셀프 점 코코 여기 셀프 천 코코가 이거죠. 저희가 아까 코코 어노테이션 파일을 이렇게 로드를 했기 때문에 셀프 천 코코 겟 어노테이션 아이디 하면은 어노테이션 아이디를 가져옵니다. 그다음에 코코 어노테이션 아이디로부터 어노테이션을 로드해라 하면은 어노테이션 파일 로드 합니다. 이렇게 로드된 어노테이션 파일에는 박스 뭐 레이블 그런 정보들이 있죠 따라서 먼저 이제 박스 정보 가져오고요. 그다음에 레이블 정보 이렇게 가져올 수 있습니다. 그래서 이 에이스를 한번 프린트를 해보면은 거기 안에 키가 어떻게 구성이 되어 있는지 저희가 알 수 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Object Detection] 5.실습Yolo from scratch.json",
        "lecture_name": "[Object Detection] 5.실습Yolo from scratch",
        "course": "Object Detection",
        "lecture_num": "",
        "lecture_title": "5.실습Yolo from scratch",
        "chunk_idx": 0,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:778d2c58dbde48195b9d24c924282d640752549786aa4ce2ba0d0bbbb0c2a29e"
      },
      "token_estimate": 1103,
      "char_count": 2026
    },
    {
      "id": "transcript_object_detection_object_detection_5실습yolo_from__c001_96fbe1",
      "content": "[Object Detection] [Object Detection] 5.실습Yolo from scratch\n\n다. 그다음에 코코 어노테이션 아이디로부터 어노테이션을 로드해라 하면은 어노테이션 파일 로드 합니다. 이렇게 로드된 어노테이션 파일에는 박스 뭐 레이블 그런 정보들이 있죠 따라서 먼저 이제 박스 정보 가져오고요. 그다음에 레이블 정보 이렇게 가져올 수 있습니다. 그래서 이 에이스를 한번 프린트를 해보면은 거기 안에 키가 어떻게 구성이 되어 있는지 저희가 알 수 있습니다. 그다음에 박스 레이블을 0에서 1로 바꿔줘야 되는데요. 그 과정이 이렇게 다음과 같습니다. 그래서 이제 각 박스와 레이블 같이 불러와서 레이블 콤마 박스의 위치들을 다 노멀라이즈 0에서 1 사이로 노말라이즈를 한 것을 볼 수가 있습니다. 저희 같은 경우는 지금 이미지 사이즈로 512로 리사이즈 했기 때문에 나누기 512 이미 이미지 사이즈를 알고 있다는 가정 하에 이렇게 나누게 해줬는데요. 어 만약에 이미지가 리사이즈가 되지 않은 케이스에 대해서는 512로 다이렉트로 넣어주면 안 되겠죠 그래서 그 이미지 인포 인포에 이제 이미지 사이즈 정보가 같이 있었으니까 해당 정보를 활용을 하시거나 이는 직접 이미지를 로드를 했잖아요. 그 이미지로부터 사이즈 이제 프로퍼티를 가져와서 여기에 나눠주는 그런 방식이 있을 수가 있겠습니다. 그렇게 해서 최종적으로 박스를 만들어 주시고 트랜스폼 연산 가해준 다음에요. 그다음에 이제 필요한 것은 욜로 같은 경우는 어노테이션 파일 저희가 가지고 있는 바운딩 박스를 어 그리드 각 셀별 그리드 기준으로 바꿔줘야 됩니다. 그러니까 박스를 셀로 바꿔줘야 되는데요. 그 이유 같은 경우는 욜로에서는 총 7바이 7 셀이 나오게 되고 각 셀마다 박스 프레딕션이 이루어지게 되잖아요. 그래서 각 셀마다 어 박스가 나오게 되고 그라운드 트루스도 그 셀 기준으로 바꿔줘서 실제 로스를 계산을 해줘야 됩니다. 그래서 이제 그라운드 트루스 박스를 셀 기준으로 이제 바꿔줘야 됩니다. 그래서 먼저 이제 레이블 매트릭스 이렇게 비어 있는 토치 제로 0 다 000이죠. 비어있는 매트릭스를 하나 바꿔주는데 여기 쉐이블 보시면은 7바이 7 바이 클래스 개수 플러스 5 곱하기 박스 개수 저희가 이제 강의 시간에 봤던 거랑 동일하죠. 근데 강의 시간에는 박스가 먼저 왔었는데 실제 코드 구현에서는 이렇게 클래스가 먼저 앞에 옵니다. 그다음에 그래서 이제 저희가 로드한 각 박스 박스별로 이 박스의 엔티티를 살펴보면 클래스 레이블 XY 그다음에 wis 헤이트 이렇게 정보가 있잖아요. 그래서 먼저 이제 클래스 레이브 인티저로 바꿔주고 이 XY 위치 정보 있잖아요. 중심점의 정보 이 위치 정보를 셀 정보로 변환을 해주기 위해서 이 위치가 어느 셀에 담겨 있는지 계산을 해줘야 됩니다. 그렇게 해서 이렇게 셀 정보가 나오게 되고요. 높이 너비도 마찬가지로 그리드 기준으로 바꿔줘야 되겠죠. 그리드 기준으로 바꾼 다음에 이렇게 각 레이블 매트릭스에 이제 해당 박스를 넣어줘야 되는데 어 욜로 버전 1 같은 경우는 그리드 당 박스의 개수가 하나로 제한이 됩니다. 따라서 이렇게 박스가 없을 때 현재 0번이 비어 있는 박스라는 뜻이죠. 박스가 없을 때 해당 클래스 해당 그리드에 이제 박스가 있다고 표시를 해주고 박스 좌표 이렇게 모아서 넣어주고요. 그다음에 클래스 어떤 클래스를 갖는지 이렇게 원화으로 클래스 위치에 이렇게 일 처리될 수 있게끔 원화으로 넣어주게 됩니다. 이렇게 모든 박스를 그리드 셀로 이렇게 변환을 해준 다음에 최종적으로는 리턴으로는 저희가 로드한 이미지와 요 레이블 매트릭스를 리턴을 해 주면 될 것입니다. 지금까지 커스텀 데이터 셋 한번 살펴봤고요. 이렇게 커스텀 데이터 셋 로드 하면은 저런 셀 기준으로 변환된 레이어를 얻을 수가 있겠죠. 그다음에 이제 각 4 안에서 모델이 어떻게 학습이 되는지 한번 같이 살펴보도록 하겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Object Detection] 5.실습Yolo from scratch.json",
        "lecture_name": "[Object Detection] 5.실습Yolo from scratch",
        "course": "Object Detection",
        "lecture_num": "",
        "lecture_title": "5.실습Yolo from scratch",
        "chunk_idx": 1,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:778d2c58dbde48195b9d24c924282d640752549786aa4ce2ba0d0bbbb0c2a29e"
      },
      "token_estimate": 1031,
      "char_count": 1923
    },
    {
      "id": "transcript_object_detection_object_detection_5실습yolo_from__c002_53522f",
      "content": "[Object Detection] [Object Detection] 5.실습Yolo from scratch\n\n다. 이렇게 모든 박스를 그리드 셀로 이렇게 변환을 해준 다음에 최종적으로는 리턴으로는 저희가 로드한 이미지와 요 레이블 매트릭스를 리턴을 해 주면 될 것입니다. 지금까지 커스텀 데이터 셋 한번 살펴봤고요. 이렇게 커스텀 데이터 셋 로드 하면은 저런 셀 기준으로 변환된 레이어를 얻을 수가 있겠죠. 그다음에 이제 각 4 안에서 모델이 어떻게 학습이 되는지 한번 같이 살펴보도록 하겠습니다. 그래서 이제 저희가 테스트 로더 트레인 로더 이런 게 있는데 먼저 처음에 테스트 로더에 대해서 어 모델과 테스트 로더로부터 어떤 박스 하나 예측하고요. 그다음에 그라운드 트러스 박스 가져와서 map가 학습되기 전에 map가 어떻게 되는지 계산을 합니다. 그러니까 이제 각 에프이 돌기 전에 현재 엠에피는 이렇게 된다라고 이제 예측을 하는 거죠. 그다음에 이제 트레인 펑션이 호출이 돼서 트레인 로더가 모델에 들어가서 실제 트레이닝 과정을 진행을 하게 됩니다. 여기 이제 갭 박스 함수 살펴보시면은 로더로부터 그라운드 트루스 박스와 모델을 로더를 예측해서 프레딕션 박스를 계산을 해서 이제 그리드 단위를 다시 셀 단위의 박스를 원래의 박스로 바꿔 가지고 리턴을 해 주게 됩니다. 한번 실제 그 코드를 한번 이제 주석 저희가 달아드렸으니까 뭐 어떻게 돌아가는지는 직접 보시면은 쉽게 아실 수 있을 겁니다. 그렇게 돼서 이제 트레인 펑션 안에 들어가 보면요. 여기 있죠 트레인 펑션 안에 어 로더로부터 이렇게 아이템 가져오고요. 티큐디엠 객체로 묶어서 이제 어느 정도 진행되고 있는지 확인할 수 있게끔 저희가 해줬죠. 그래서 x가 이미지가 될 거고 y가 셀 단위로 바뀐 박스가 될 것입니다. 이렇게 x y 가져오고요. 그다음에 먼저 그 이미지를 욜로 모델에 통과시키게 됩니다. 그럼 모델이 어떻게 생겼는지 한번 같이 간단하게 볼까요? 진짜 그냥 저희가 강의에서 설명드린 그대로인데 이게 이제 모델 정의하는 파일입니다. 그래서 이게 무슨 뜻이냐면 커널 사이즈 그다음에 필터 채널 개수죠. 그다음에 스트라이드 패딩 이런 것들을 의미하고 여기는 이제 맥스 풀을 의미합니다. 그다음에 여기 이게 리스트 형태로 들어가면은 다음 구조가 이렇게 네 번 반복된다 다음 구조가 두 번 반복된다 그런 의미를 가지고 있습니다. 그래서 욜로에서 먼저 이제 기본적인 연산이 되는 컨볼루션 블록을 정리를 해주고요. 그래서 기본 컴브 블록 같은 경우는 컴브 연산 후 뼈치놈 그다음에 리큘렐로 여기 보시면 컴브 뼈치놈 리큘렐로 이게 이제 기본 씨엔엔 블록이고 실제 사용하게 될 모델은 다음과 같이 정의가 되어 있는데요. 현재 이제 아키텍처 파일 채널 개수 인풋 채널 개수 보통 이미지가 채널이 3이니까 rg RGB 3개 채널이니까 보통 3이 오겠죠 뭐 앱 리스트 같은 경우는 RGB가 아닌 그레이 형태니까 1이 올 것이고요. 다크넷 로드 하고 플리 커넥티드 레이어 로드 해서 최종적으로는 다크넷 통과하고 플리커넥티드 레이어 통과한다라고 보시면 되겠습니다. 여기서 그냥 이제 함수 이름 명령 자체를 이제 다크네스로 저희가 해줬습니다. 이 아키텍처 컴피그 저희가 로드 위에서 봤던 아키텍처 컴피그 따라서 이렇게 콤블루션 뭐 플링 레이얼 그다음에 리피티드 된 박스 리피티드 된 컴블레이얼 이런 거 쭉 노드를 만들어 줘서 이렇게 이제 백번 콤블루션 연산을 쭉 수행하게 됩니다. 이렇게 수행해서 최종적으로 시퀀셜로 묶어줘서 컴블레이어를 크리에이트 하고요. 그다음에 이제 플리 커넥티드 레이어도 비슷하게 이렇게 시퀀셜로 묶어줘서 크리에이트 하는데 그 중간에 플리커넥티드 레이어가 총 하나 리뉴얼 레이어가 하나 두 개 들어갔죠. 근데 이제 맨 마지막에 들어간 플리 커넥티드 레이어의 아웃풋 채널을 보시면은 스 곱하기 스 곱하기 시 플러스 비 곱하기 5 이렇게 되어 있잖아요. 이게 이제 저희가 7 7 클래스 개수 그다음에 박스 개수 곱하기 5 이렇게 예측이 되는 것을 볼 수가 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Object Detection] 5.실습Yolo from scratch.json",
        "lecture_name": "[Object Detection] 5.실습Yolo from scratch",
        "course": "Object Detection",
        "lecture_num": "",
        "lecture_title": "5.실습Yolo from scratch",
        "chunk_idx": 2,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:778d2c58dbde48195b9d24c924282d640752549786aa4ce2ba0d0bbbb0c2a29e"
      },
      "token_estimate": 1063,
      "char_count": 1979
    },
    {
      "id": "transcript_object_detection_object_detection_5실습yolo_from__c003_7bb2bf",
      "content": "[Object Detection] [Object Detection] 5.실습Yolo from scratch\n\n다. 이렇게 수행해서 최종적으로 시퀀셜로 묶어줘서 컴블레이어를 크리에이트 하고요. 그다음에 이제 플리 커넥티드 레이어도 비슷하게 이렇게 시퀀셜로 묶어줘서 크리에이트 하는데 그 중간에 플리커넥티드 레이어가 총 하나 리뉴얼 레이어가 하나 두 개 들어갔죠. 근데 이제 맨 마지막에 들어간 플리 커넥티드 레이어의 아웃풋 채널을 보시면은 스 곱하기 스 곱하기 시 플러스 비 곱하기 5 이렇게 되어 있잖아요. 이게 이제 저희가 7 7 클래스 개수 그다음에 박스 개수 곱하기 5 이렇게 예측이 되는 것을 볼 수가 있습니다. 나중에 이거를 이제 아웃풋 결과를 리쉐입 해가지고 저희가 7 7 바이 30으로 해가지고 활용을 하겠죠. 그래서 트레인 펑션 보면은 이렇게 아웃이 그렇게 나오게 되고요. 각 그리드별로 이제 예측을 하는 거죠. 각 그리드별로 지금 같은 경우에는 박스가 2개니까 2개의 박스를 무조건 예측을 하는데 이제 여기 보시면은 로스를 계산을 해줘야 됩니다. 로스 같은 경우에는 이제 각 그리드별로 두 개의 박스가 무차별하게 예측이 되는 게 아니라 그라운드 트루스와 비슷하게 예측이 되어야 되겠죠. 이 학습을 진행하기 위해서 로스를 계산을 하고 백워드하고 옵티마이저 스탭해서 실제 그라디언트를 업데이트를 하는 그런 과정이 이루어지게 됩니다. 그렇게 되면은 이제 저희가 이제 남은 것은 이 로스 함수에 대해서만 살펴보면 되는데요. 로스 함수도 되게 간단합니다. 여기 위에 루스 함수를 로스 여기 아래 보시면은 로스 함수가 욜로 루스로 선언이 되잖아요. 여기 같이 한번 욜로 로스 보시면요. 초기화 같은 경우는 MSA로스 그다음에 그리드 개수 박스 개수 클래스 개수 그다음에 그 강의 시간에 봤던 앞에 붙어 있는 하이퍼 파라미트 노 오브젝트에 대한 하이퍼 파라미트와 콜딩 오리네이트에 대한 하이퍼 파라미트 하이퍼 파라미터가 이렇게 이니셜라이즈 되게 되고요. 그다음에 이제 포워드 포워드가 실제 로스를 계산하는 부분이라고 보시면 되겠습니다. 그래서 저희가 아까 욜로 모델로부터 나온 프레딕션과 그다음에 셀 단위로 바뀐 타겟 두 가지 형태가 있었죠. 먼저 이제 프레딕션을 이렇게 저희가 알고 있던 그런 포맷으로 바꿔줘야 됩니다. 그래서 이제 7 바이 7 바이 클래스 GS 플러스 박스 개수 곱하기 5 형태로 이제 바꿔줘야 되고요. 프레딕션이 존재하게 될 것이고 그다음에 이제 이 프레딕션으로부터 어 그라운드 트루스와의 iou를 계산을 해줘서 저희가 이제 박스가 2개가 있잖아요. 그 2개의 박스 중에서 예측한 2개의 박스 중에서 어떤 박스 어떤 박스가 더 그라운드 트로스와 비슷하냐를 이제 계산을 해줘야 하기 때문에 어 이 과정이 필요합니다. 그래서 이제 첫 번째 박스와 타겟과 그런 iou를 계산을 하고요. 두 번째 박스와 타겟의 IO를 계산을 합니다. 그래서 이제 타겟의 박스 위치는 여기 여기에 있고 첫 번째 박스의 박스 위치 여기 있으니까 얘와 계산을 해주면 되는 거죠. 그다음에 두 번째 박스와 그 타겟의 iu를 이런 식으로 계산을 해 주면 됩니다. 그래서 아유 계산하는 코드는 위에 위에 맨 위에 보시면 나와 있는데 되게 간단합니다. 뭐 그냥 박스 에리어 구해서 교집합 빼고 전체 교집합으로부터 나눠주면 되는 것이죠. 한번 참고해서 보시면 될 것 같고요. 주석 저희가 다 달아드렸으니까요. 먼저 다시 이제 로스 함수로 오면은 그렇게 해서 첫 번째 박스 iou 두 번째 박스 iu가 계산이 된다고 했을 때 전체 iu로부터 더 큰 iu를 가진 베스트 박스 계산합니다. 그다음에 저희가 이제 뭐 박스 로스 같은 경우는 해당 그리드 셀에 실제 그라운드 트루스 타겟이 존재할 때만 그 박스 로스를 업데이트해 줬잖아요. 그래서 해당 타겟의 타겟에 그 그라운드 트로스가 존재하는지 여부를 계산을 해줘야 되는데요. 그래서 다음과 같이 이제 실제로 그 셀에 박스가 존재하냐 그라운드 트루스가 존재하냐 그 정보를 이렇게 가져오면 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Object Detection] 5.실습Yolo from scratch.json",
        "lecture_name": "[Object Detection] 5.실습Yolo from scratch",
        "course": "Object Detection",
        "lecture_num": "",
        "lecture_title": "5.실습Yolo from scratch",
        "chunk_idx": 3,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:778d2c58dbde48195b9d24c924282d640752549786aa4ce2ba0d0bbbb0c2a29e"
      },
      "token_estimate": 1052,
      "char_count": 1972
    },
    {
      "id": "transcript_object_detection_object_detection_5실습yolo_from__c004_ac6d99",
      "content": "[Object Detection] [Object Detection] 5.실습Yolo from scratch\n\n다. 그다음에 저희가 이제 뭐 박스 로스 같은 경우는 해당 그리드 셀에 실제 그라운드 트루스 타겟이 존재할 때만 그 박스 로스를 업데이트해 줬잖아요. 그래서 해당 타겟의 타겟에 그 그라운드 트로스가 존재하는지 여부를 계산을 해줘야 되는데요. 그래서 다음과 같이 이제 실제로 그 셀에 박스가 존재하냐 그라운드 트루스가 존재하냐 그 정보를 이렇게 가져오면 됩니다. 이제 남은 것은 그냥 로컬리제이션 로스를 계산을 해 주면 되겠죠 그래 로컬리제이션 로스가 어떻게 계산이 되냐면 박스가 존재할 때 그러니까 실제 박스가 존재할 때 어 아이유가 이제 더 큰 박스가 첫 번째 두 번째 박스일 때 두 번째 박스인 거랑 아이유가 더 큰 게 이제 첫 번째 박스인 거랑 그러니까 이제 베스트 박스를 가져오는 거죠. 아이유가 더 큰 베스트 박스를 이렇게 프레디션 박스를 쭉 가져와서 그라운트루스도 마찬가지로 이그지슨 박스가 있을 때만 가져와서 실제로 프레딕션의 위스와 헤이트에 루트 씌우고 절댓값 씌우고 그런 연산이 있었잖아요. 연산 가해줘서 이렇게 ms2를 그냥 계산을 해주게 해주면은 끝납니다. ms를 이렇게 계산을 해 주면 끝이고요. 컨피던스 로스도 되게 간단하죠. 컴피던스 로스 같은 경우는 오브젝트가 있을 때 그리고 오브젝트가 없을 때 나눠서 저희가 계산을 했잖아요. 그래서 앞서 이그지스승 박스로 오브젝트 유무를 알 수가 있으니까 먼저 이제 오브젝트가 있을 때 오브젝트가 있을 때 그 아이유가 큰 저희가 이제 박스들만 가져옵니다. 첫 번째 박스와 두 번째 박스 중 예측 중에서 그라운드 소스가 어떤 게 더 아이유가 크냐 제사 앞에서 계산했잖아요. 그래서 두 번째 박스일 때 가져오고 첫 번째 박스일 때 가져와서 이제 박스가 있을 때 그라운드 트루스와 그 컴피던스 스코어를 MSA로 계산을 합니다. 그다음에 오브젝트가 없을 때죠. 이제 오브젝트가 없을 때는 모든 두 개의 모든 박스에 대해서 이제 컴피턴스 스코어의 MSA를 계산을 하는데요. 그래서 먼저 이제 첫 번째 바운딩 박스 그다음에 두 번째 바운딩 박스 MSA를 계산을 해서 노 오브젝트로스에 이렇게 더해줍니다. 그렇게 되면은 최종적으로 노 오브젝트 로스 나오고 여기에 오브젝트 로스 컨비던스에 대한 로스가 이렇게 나오게 되겠죠. 그 위에서는 이제 박스 로스 저희가 계산을 했으니까요. 이제 남은 것은 클래시피케이션 로스만 남았죠. 그래서 클래시피케이션 로스 같은 경우는 다음과 같이 마찬가지로 박스가 존재할 때 그 프레딕션과 박스가 존재할 때 그 타겟 클래스에 대한 실제 정보잖아요. 워낙 정보를 저희가 넣어줬기 때문에 이 부분이 이제 최종적으로 ms 형태로 계산이 됩니다. 이게 욜로 버전 1이기 때문에 어떤 소프트맥스 로스를 쓰지 않고 ms 로스를 저희가 사용을 합니다. 그래서 최종 클래스 로스까지 계산이 됐고 최종 로스의 형태를 보면은 이 각각 앞에 붙는 하이퍼 파라미터를 곱해주고 그런 로스를 이렇게 다 더해주면 됩니다. 그래서 최종적으로 이 로스를 리턴을 하고 아까 이 트레이너 함수에서 트레인 펑션 부분에 이 로스가 이제 뭐 백워드 되고 옵티마이즈 돼서 최종적으로 저희 욜로 모델이 학습이 될 수 있습니다. 이것으로 이제 욜로 한번 코드에 대해서 살펴봤는데요. 실제 저희 캠프 분들께서는 이 코드를 기반으로 저희가 지금 다루지 않았던 아이유 계산하고 그런 것들이 있잖아요. 저희가 주석 다 달아드렸으니까 한번 코드 리뷰해 보는 것을 추천드립니다. 감사합니다. 네 이것으로 이제 욜로 버전원 폼 스크래치 구현을 마무리하도록 하겠습니다. 감사합니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[Object Detection] 5.실습Yolo from scratch.json",
        "lecture_name": "[Object Detection] 5.실습Yolo from scratch",
        "course": "Object Detection",
        "lecture_num": "",
        "lecture_title": "5.실습Yolo from scratch",
        "chunk_idx": 4,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:778d2c58dbde48195b9d24c924282d640752549786aa4ce2ba0d0bbbb0c2a29e"
      },
      "token_estimate": 966,
      "char_count": 1799
    }
  ]
}