{
  "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
  "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
  "course": "RecSys 이론",
  "total_chunks": 12,
  "chunks": [
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c000_3cb62d",
      "content": "[강의 녹취록] 과목: RecSys 이론 | 강의: 6강 | 제목: Recommender System with Deep Learning 1\n\n안녕하세요. 추천 시스템 이론 강의를 맡은 강사 이준원입니다. 이제 강의가 절반 정도 진행되었는데요. 생각해 보면 아직까지 저희는 딥러닝을 사용한 추천 모델을 본격적으로 배우지 않았습니다. 물론 5강에서 아이템 투 백 모델이 간단한 뉴럴넷 랭귀지 모델이긴 하지만 그렇게 복잡한 딥러닝 모델은 아니었죠. 이전에 말씀드린 대로 추천 시스템 분야는 다른 분야에 비해서는 딥러닝 모델이 기존 ML 모델에 비해 월등히 좋은 성능을 내지 못하는 부분이 있습니다. 또한 추천을 수행할 때 이 모델을 서빙하는 레이턴시가 굉장히 중요하기 때문에 또 너무 복잡한 모델을 사용하기에는 실제로는 어렵다는 챌린지도 존재합니다. 그럼에도 불구하고 딥러닝을 사용한 추천 모델은 여전히 활발하게 연구되어 있고 또 일부 구글과 핀터레스트와 같은 추천을 잘하는 회사는 딥러닝을 추천에 적극적으로 활용하고 있습니다. 그래서 이번 시간에는 3강부터 5강까지 배웠던 컬래버레이터의 필터링의 원리를 바탕으로 딥러닝 추천 모델들에 대해 살펴보겠습니다. 네 목차는 다음과 같습니다. 딥러닝이 어떤 장점을 가지는지, 딥러닝에 사용되는 기법은 무엇인지에 대해 간단히 랩업을 하고 나서 이제 이번 시간에는 멀티 레이어 퍼셉트론 제일 기본적인 피드 포워드 뉴럴 네트워크 구조이죠. 그리고 오토 인코더를 기반으로 설계된 대표적인 추천 모델에 대해서 배워보도록 하겠습니다. 먼저 추천 시스템에 딥러닝을 사용하는 것이 왜 좋은가? 딥러닝을 통해 어떻게 추천 모델이 고도화될 수 있는지 살펴봅시다. 네 먼저 딥러닝 모델은 가장 잘 알려진 특징이죠. 논 리니어 트랜스포메이션이 가능합니다. 데이터가 가진 비선형의 패턴을 효과적으로 나타내고 모델링 할 수 있습니다. DNN에서 사용되는 멜루나 탄젠트 하이퍼블릭 같은 활성화 함수들이 이런 논 리니얼리티를 가능하게 하는 것을 이미 배우셨을 것입니다. 이제 이러한 DNN의 논 리니어 트랜스포메이션 성질은 추천 모델 학습에 사용되는 이 유저 아이템의 복잡한 인터랙션을 모델링하는 데 큰 도움을 줍니다. 우리가 4강에서 배웠던 매트리스 팩토라이제이션의 경우 유저 아이템을 임베딩한 이후에는 닷 프로덕트 즉 선형 결합을 통해서 바로 유저의 선호도를 예측하게 됩니다. 그리고 8강에서 배우게 될 대표적인 클래시컬 모델인 팩토라이제이션 머신이나 그 외에 사용하는 다양한 추천 모델의 경우에서도 선형 가정을 토대로 모델이 설계된 경우가 많습니다. 그래서 이러한 가정은 모델을 너무 단순하게 만들고 모델이 가지는 표현력에 큰 한계를 두게 합니다. 따라서 딥뉴럴 네트워크 DNN을 사용하여서 전통적인 추천 모델이 표현할 수 없는 복잡한 인터랙션을 딥러닝 모델이 학습하기를 기대하는 것입니다. 또한 DNN은 주어진 로우 데이터로부터 피처 레프레젠테이션을 직접 할 수 있기 때문에 피처 프리 프로세싱이 훨씬 적고 사람이 직접 피처를 디자인하지 않아도 됩니다. 또한 디엔엔을 사용하면 기존에 사용하기 어려웠던 텍스트나 이미지, 오디오와 같은 데이터도 추천 모델의 피처로 직접 사용할 수 있습니다. 그래서 이러한 레프레젠테이션은 인베딩 레이어나 컨볼루션 레이어와 같은 레이어를 사용하여서 하나의 모델로 엔드 투 엔드로 직접 학습할 수 있게 되고, 그래서 복잡한 피처를 적절한 레프리젠테이션으로 표현할 수 있게 됩니다. 또한 딥러닝 모델은 시퀀스 모델링에 굉장히 뛰어난 성능을 보이고 있습니다. 대표적으로 자연어 처리 머신 트레저레이션이나 음성 인식, 챗봇 과 같은 테스크에서 이런 시퀀스 모델링이 아주 좋은 성능을 보이고 있는데요. 앞선 강의에서 배우셨겠지만 RNN이나 CNN 계열의 모델 그리고 요즘에는 트랜스포머 같은 모델들이 이런 시퀀스 모델링을 아주 잘 하고 있습니다. 추천 시스템에서는 현재까지 소비한 아이템 다음에 넥스트 아이템을 예측하는 넥스트 아이템, 프리딕션이나 같은 세션에서 추천을 수행하는 세션, 베이스 레코멘데이션 같은 데스크에 이런 시퀀스 모델링이 활용될 수 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 0,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1099,
      "char_count": 2013
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c001_540823",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 대표적으로 자연어 처리 머신 트레저레이션이나 음성 인식, 챗봇 과 같은 테스크에서 이런 시퀀스 모델링이 아주 좋은 성능을 보이고 있는데요. 앞선 강의에서 배우셨겠지만 RNN이나 CNN 계열의 모델 그리고 요즘에는 트랜스포머 같은 모델들이 이런 시퀀스 모델링을 아주 잘 하고 있습니다. 추천 시스템에서는 현재까지 소비한 아이템 다음에 넥스트 아이템을 예측하는 넥스트 아이템, 프리딕션이나 같은 세션에서 추천을 수행하는 세션, 베이스 레코멘데이션 같은 데스크에 이런 시퀀스 모델링이 활용될 수 있습니다. 유저나 아이템에 대한 시간적 정보 즉 어떤 시퀀셜한 정보를 그러니까 이 딥러닝 모델이 표현하고 학습할 수 있기 때문입니다. 또한 마지막으로 플렉서빌리티인데요. 이러한 딥러닝 모델을 쉽게 개발할 수 있는 다양한 프레임워크가 이미 있기 때문에 연구와 현업에서도 이런 텐서플로우나 파이터치 같은 것을 잘 활용하여서 활발하게 연구와 개발을 동시에 하고 있습니다. 이러한 프레임웍을 사용하는 커뮤니티도 굉장히 활발하기 때문에 이 딥러닝 분야가 계속 추천 시스템에서도 잘 연구되고 있습니다. 그래서 이러한 이유들로 인해서 추천 시스템에서도 최근에 발생되는 최신 논문들과 기법은 거의 딥러닝 모델 혹은 그러한 접근들을 사용하고 있습니다. 네 이제 제일 기본적인 딥러닝의 레이어 인 멀티 레이어 퍼셉션을 사용한 대표적인 추천 모델 몇 가지를 살펴봅시다. 참고로 지금부터 일곱 번째 강의 즉 다음 강의까지 다양한 딥러닝 모델들을 배우게 될 것인데요. 제 강의에서 소개하는 모델들 그 논문들은 여러 가지 딥러닝 접근법을 추천 시스템의 각 분야에 처음 활용했다는 점에서 각각의 발자취를 남긴 논문이 되겠습니다. 따라서 실제 현업에서 자주 사용되는 기준으로 모델을 혹은 논문을 소개한다기보다는 이론적으로 큰 의미를 가지는 기준으로 소개하는 것임을 참고하시길 바랍니다. 네 멀티 레이어 퍼셉트론 한국말로 다중 퍼셉트론이라고 표현할 수 있는데요. 가장 기본적인 퍼셉션 즉 노드 여러 개의 노드로 이루어진 레이어를 순차적으로 쌓은 구조입니다. 피드 포드 유n 네트워크가 되겠죠 딥러닝이 가지고 있는 가장 기본적인 논 리니어와 문제를 풀 수 있다는 것을 설명하는 레이어이고요. 뭐 아래의 예시는 여러분들이 잘 아시는 엑스알 문제를 통해 엠엘피 레이어로 해결할 수 있다는 것을 보여줍니다. 그래서 RNN CNN 오토 인코더 혹은 트랜스포머 같은 다양한 복잡한 레이어들이 있지만 그 모든 레이어들 이전에 이 기본적인 MLP 레이어로부터 딥러닝 모델이 출발한 것입니다. 네 그래서 처음으로 소개하는 논문은 뉴럴 컬라버레이트 필터링입니다. 추천 시스템에서 가장 많이 사용하던 엠프 매트리스 팩토라이제이션에다가 이 MLP 레이어를 적용한 기법인데요. 매트리스 팩토라이제이션이 가진 한계 즉 아까도 잠깐 언급했지만 이 리니어 모델에 대한 한계를 지적하면서 뉴럴넷 모델을 이 엠프에 추가하여 좀 더 일반화된 모델을 본 논문에서는 제시하고 있습니다. 네 본 논문의 아이디어부터 살펴보겠습니다. 우리가 4강에서 대표적인 추천 모델이었던 매트리스 팩토라이제이션에 대해서 배웠던 거 기억하시죠? 간단하게 수식으로 써보면 rui는 유저 벡터 트랜스포즈 아이템 벡터로 나타낼 수 있죠. 이 수식을 보면은 유저 아이템 사이에 임베딩을 우리가 구했지만 결국 그 둘은 닷 프로덕트 즉 선형 연산으로 곱해지게 됩니다. 그래서 유저와 아이템 사이의 복잡한 관계를 표현해야 하는데 이런 리니어한 인터랙션으로 표현되는 경우에는 표현력에 한계를 가질 수밖에 없다는 것이죠. 그래서 엠프 모델을 통해서 유저 아이템 매트릭스는 각각 유저와 아이템 매트릭스로 나뉘어서 학습이 됩니다. 그래서 아래 그림에 요 왼쪽에 있는 예시를 살펴봅시다. 이 왼쪽에 있는 데이터가 유저 아이템 매트릭스 즉 매트릭스 팩터라이제이션 학습에 필요한 인풋 데이터고요. 오른쪽에 있는 이 학습된 유저 매트릭스를 인베딩 공간에 그려본 것입니다. 학습이 모두 이루어져 있기 때문에 유저 레이턴트 스페이스 즉 인베딩 스페이스에 각각의 유저들이 표현될 수 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 1,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1127,
      "char_count": 2065
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c002_718c5a",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 그래서 아래 그림에 요 왼쪽에 있는 예시를 살펴봅시다. 이 왼쪽에 있는 데이터가 유저 아이템 매트릭스 즉 매트릭스 팩터라이제이션 학습에 필요한 인풋 데이터고요. 오른쪽에 있는 이 학습된 유저 매트릭스를 인베딩 공간에 그려본 것입니다. 학습이 모두 이루어져 있기 때문에 유저 레이턴트 스페이스 즉 인베딩 스페이스에 각각의 유저들이 표현될 수 있습니다. 보시면 우리는 유저 1 유저 2 유저 3 일단 3개의 유저가 있고 이 유저는 각각 p1 p2 p3 라는 벡터로 표현이 됩니다. 그래서 이 p1 p2 p3라는 벡터를 레이턴트 스페이스에 나타냈는데요. 문제는 여기서 p4 즉 유저 4가 새로 등장했을 때 이 유저 4를 존의 유저 레이턴트 스페이스에 추가로 표현해 줘야 한다는 것입니다. 이때 유저 간의 유사도를 계산해야 되는데요. 이제 여기서 계산한 유사도는 각각의 레이팅이 얼마나 겹치는지 자카드 유사도를 사용하였습니다. 이 데이터를 보시면 유저 4와 가장 레이팅이 많이 겹치는 유저는 유저 원입니다. 즉 유저 4와 유저 원이 가장 유사하다는 것이죠. 그렇기 때문에 새로 학습되는 유저 4에 해당하는 p4라는 유저 4의 레이턴트 벡터는 p1과 제일 유사한 위치에 놓여야 합니다. 즉 뭐 이런 식으로 놓이거나 이런 식으로 놓여야겠죠 자 문제는 그 다음인데요. 유저 2와 유저 3 근데 문제는 유저 2와 유저 3인데요. 유저 4가 가장 가까운 유저 1 다음으로 가까운 유저는 보시면 유저 3리가 더 많은 아이템을 공유하고 있기 때문에 유저 4가 유저 3와 더 가깝습니다. 유저 2보다는 근데 이제 이 레이턴트 스페이스에 표현을 해야 되는데 어떻게 표현을 해도 이 유저 4는 유저 3보다는 유저 2에 가깝게 됩니다. 즉 새로운 유저 유저 포를 이 스페이스에 표현할 때 모순이 발생하는 거죠. 유저 원과 가깝게 표현을 하게 되는 경우 아무리 레이턴트 스페이스의 유저 포를 표현한다 하더라도 벡터를 유저 2에 비해 유저 3에 가깝게 놓을 수 없다는 것입니다. 이러한 상황에서 기존의 매트리스 팩터 라이제이션의 연산인 닷 프로덕트는 리니어 하기 때문에 최종 예측을 수행할 때 유저 4에 대해서는 유저 2보다는 유저 3와 비슷한 예측 값을 갖게 할 수는 없습니다. 즉 매트리스 팩토라이제이션 모델을 사용해서 예측을 할 경우 항상 유저 4와 유저 3의 평점보다는 유저 4와 유저 2의 평점이 더 비슷하게 추론된다는 것이죠. 네 그래서 새로운 유저 4를 설명하는 벡터 즉 p4는 어떻게 해도 유저 2에 비해서 유저 3에 가깝게 놓을 수가 없습니다. 이제 이러한 상황에서 기존의 매트릭스 팩토라이제이션의 연산인 닷 프로덕트는 리니어한 연산이기 때문에 최종 예측을 할 때에도 항상 유저 4는 유저 3보다 유저 2에 가깝게 예측이 됩니다. 실제로는 유저 4와 유저 3가 더 비슷함에도 불구하고 항상 예측을 할 때는 유저 3보다는 유저 2에 더 가깝게 평점이 구해진다는 것이죠. 그래서 이러한 문제를 해결하기 위해서는 매트리스 팩토라이제이션의 레이턴트 스페이스 차원을 다음과 같은 2차원이 아니라 더 큰 차원으로 크게 해서 이 유사도 표현의 문제를 해결할 수 있습니다. 하지만 이제 계속해서 그렇게 차원을 늘려갈 경우에 오버피팅 문제가 발생합니다. 따라서 이 뉴럴 컬라버레이팅 필터링 논문은 차원을 계속해서 크게 문제를 해결하는 것이 아니라 이 모델 자체에 논리니어한 표현을 추가하여서 이 문제를 해결하고 싶었고 그래서 이 엠엘피 레이어를 추가하게 되었습니다. 네 다음 페이지는 이 뉴럴 컬라버레이트 필터링에 새로 추가된 MLP 파트 부분입니다. 그래서 아래에 있는 레이어부터 위로 아웃풋 레이어까지 쭉 설명을 드리겠습니다. 먼저 인플레이어는 유저와 아이템에 대한 원핫 인코딩 벡터로 표현이 됩니다. 이제 여기서 유저 레이턴트 벡터 즉 인베딩 매트릭스를 통하여서 각각의 유저와 아이템이 어떤 댄스한 형태의 인베딩으로 표현이 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 2,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1045,
      "char_count": 1978
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c003_1f07f6",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 네 다음 페이지는 이 뉴럴 컬라버레이트 필터링에 새로 추가된 MLP 파트 부분입니다. 그래서 아래에 있는 레이어부터 위로 아웃풋 레이어까지 쭉 설명을 드리겠습니다. 먼저 인플레이어는 유저와 아이템에 대한 원핫 인코딩 벡터로 표현이 됩니다. 이제 여기서 유저 레이턴트 벡터 즉 인베딩 매트릭스를 통하여서 각각의 유저와 아이템이 어떤 댄스한 형태의 인베딩으로 표현이 됩니다. 그 이후에 뉴럴 콜라보레이트 레이어라고 하는 일반적인 MLP 레이어 로 들어가게 되는데요. 각각의 유저 레이턴트 팩터, 아이템 레이턴트 팩터를 구한 이후에 이 둘을 컨캐이 네이트 해서 첫 번째 레이어를 만들어 주게 되고 이 레이어를 계속해서 쌓아 나가서 피드 포워드 유뉴널 네트워크의 형태로 스겔의 레이어까지 쌓아주게 됩니다. 그리고 마지막 레이어 스에서 최종적으로 두 유저와 아이템에 대한 레이팅과의 차이 값 y 햇을 구해주게 됩니다. 그래서 이 논문에서는 타겟을 0 또는 1 를 예측하는 형태로 구성했는데요. 그래서 마지막 레이어의 액티베이션 펑션은 로지스틱이나 프로빗 함수를 사용했다고 말합니다. 네 그래서 방금 설명했던 MLP 레이어가 이 우측에 들어가고요. 이 좌측에 있는 것은 기존에 우리가 4강에서 배웠던 매트리스 팩토라이제이션을 조금 더 일반화한 형태의 표현입니다. 그래서 그림을 보시면 좌측에 있는 이 GMF 레이어 제너럴라이제이션 매트리스 팩토라이제이션 레이어는 유저 아이템을 각각 엠프 아이템과 엠프 유저 벡터로 인베딩한 뒤 이후에 이 둘을 엘레멘트 와이즈 프로덕트 해서 GMF 값을 구해줍니다. 그리고 이 오른쪽에 있는 부분은 방금 설명했던 것처럼 MLP 인베딩과 MLP 아이템 인베딩을 사용하여서 컨케이트네이트를 시켜주고 그 위로 fed for NA 네트워크를 쌓아줍니다. 그래서 각각의 레이어의 아웃풋을 마지막에 컨케이트네이트 해줘서 이 최종적인 뉴럴 매트리스 팩토라이제이션 레이어를 가지고 마지막 타겟 값과 y 햇을 구해서 이 둘을 최대한 비슷하게 예측되도록 모델을 학습하는 것입니다. 그래서 이 두 개의 모델을 이렇게 따로따로 구성하는 이유는 각각의 모델의 장점을 살리고 단점을 보완하기 위한 일종의 앙상블 효과를 내기 위함인데요. 한 가지 특이한 점은 매트릭스 팩토라이제이션의 유저 인베딩과 엠엘피의 유저 인베딩은 다른 레이어를 사용했다는 것입니다. 그래서 수식으로 표현하면은 이 부분이 제널라이즈 매트릭스 팩토라이제이션 레이어이고요. 이 밑에 있는 부분은 엠엘피 레이어가 됩니다. 그리고 이 둘의 아웃풋을 컨케이트네이트에서 최종적으로 시그모이드 펑션을 통해서 마지막 아웃풋을 예측해 주었습니다. 다음은 제한 모델인 뉴럴 컬래버레이터 필터링 모델 와 기존 모델의 성능을 비교한 결과입니다. 이제 비교 대상은 일반화된 매트릭스 팩토라이제이션 모델인 GMF 그리고 MLP만을 사용한 MLP 모델 그리고 이 두 모델을 앙상블안 이 본 논문에서 제안하고 있는 뉴럴 매트리스 팩토라이제이션이라는 모델입니다. 그래서 뉴 MF가 제안 모델인데요. 결과를 보시면 이 빨간색이 이 본 모델에서 제안하는 두 가지 GMF와 MLP를 각각 사용을 합쳐서 사용한 모델입니다. 보시면 트레이닝 로스는 가장 낮으면서 이 무비렌즈 데이터에 대한 히트레이쇼나 엔디cg 성능은 좀 더 높음을 알 수 있죠. 그래서 결론적으로는 이 논문 자체가 성능 향상을 크게 보였고 굉장히 추천에 잘 사용된다라기보다는 이 논문은 MLP 레이어를 기존 매트리스 팩토라이제이션에 처음 추가했던 논문이고 그런 점에서 의의가 있습니다. 그래서 추천 모델에서도 이런 MLP레이어 즉 딥러닝적인 접근을 적용했을 때 좋은 성능을 보인다라는 것을 처음 보여준 논문입니다. 다음 논문은 딥러닝을 활용한 추천 시스템에서 또 하나의 발자취를 남긴 논문인데요. 딥 뉴럴 네트워크 폴 유튜브 레코멘데이션스라는 이름입니다. 실제로 유튜브는 이 모델을 사용해서 유튜브 서비스의 추천을 제공하고 있다고 합니다. 근데 유튜브에는 셀 수 없을 만큼의 많은 추천 동영상이 존재합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 3,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1095,
      "char_count": 2032
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c004_bb8d48",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 그래서 추천 모델에서도 이런 MLP레이어 즉 딥러닝적인 접근을 적용했을 때 좋은 성능을 보인다라는 것을 처음 보여준 논문입니다. 다음 논문은 딥러닝을 활용한 추천 시스템에서 또 하나의 발자취를 남긴 논문인데요. 딥 뉴럴 네트워크 폴 유튜브 레코멘데이션스라는 이름입니다. 실제로 유튜브는 이 모델을 사용해서 유튜브 서비스의 추천을 제공하고 있다고 합니다. 근데 유튜브에는 셀 수 없을 만큼의 많은 추천 동영상이 존재합니다. 그래서 추천 시스템으로 볼 때도 어떤 서비스보다 가장 많은 유저와 아이템들이 있을 것입니다. 그래서 실제 추천을 적용할 때는 아래와 같은 세 가지의 문제를 해결해야 합니다. 먼저 스케일러빌리티 계속해서 말을 하고 있긴 하지만 특히 유튜브 같은 경우에는 그 유저 아이템 수가 다른 서비스에 비해서 압도적으로 더 많기 때문에 추천 모델을 학습하는 것도 중요하지만 이 학습한 모델을 효율적으로 서빙해야 합니다. 그리고 두 번째는 프레시니스인데요. 모델이 기존에 학습하고 있던 콘텐츠와 새로 업로드된 콘텐츠 를 적절하게 조합해야 한다는 것입니다. 과거에 굉장히 인기 있는 동영상만 계속해서 추천된다든지 혹은 새로운 영상은 하나도 추천이 안 된다든지 이런 경우에는 문제가 될 수 있습니다. 그래서 새로 업로드된 콘텐츠도 적절하게 익스플로레이션 하여서 과거에 인기 있는 동영상과 최근에 등장한 동영상이 적절하게 추천이 되어야 합니다. 이제 이러한 기능을 단순하게 룰 베이스로만 해결하기엔 어려움이 있기 때문에 이런 프레시니스라는 정보도 모델이 표현할 수 있도록 모델을 설계하였습니다. 네 그리고 마지막으로 큰 노이즈에 대해서 모델이 잘 대응해야 하는데요. 높은 스파 시티 즉 유저 아이템의 개수가 아주 많기 때문에 데이터는 굉장히 스파스해지고요. 또 유튜브 서비스 같은 경우에는 다양한 외부 요인이 존재하기 때문에 단순히 좋아요나 구독과 같은 익스플리시 피드백만을 사용하게 되면은 유저의 행동을 예측하기 어렵습니다. 따라서 유저가 어떤 동영상을 봤다라는 정보인 인플리시 피드백 데이터를 잘 활용해야 되고 본다면 그 영상을 다 봤는지 적게 봤는지와 같은 형태로 데이터를 가공해서 사용해야 합니다. 그래서 앞에서 언급한 이 세 가지 문제를 해결하기 위해서 유튜브는 이런 2단계의 추천 모델을 사용하였습니다. 이 부분이 본 논문에서 가장 핵심적인 부분 중의 하나인데요. 추천 시스템이 추구해야 하는 목표를 두 가지 모델에 나누어서 적용했습니다. 먼저 첫 번째는 캔디데이 제너레이션입니다. 엄청나게 많은 비디오가 있을 때 주어진 사용자에 대해서 탑 앤 추천 아이템을 생성합니다. 탑 n개를 뭐 10개 정도로 생성하는 것이 아니라 헌드레즈 수백 개의 아이템으로 추려주는 형태가 먼저 캔디데이 제너레이션입니다. 그리고 그 캔디데이트들에 대해서 최종 랭킹 수백 개의 아이템에 대해서 최종적으로 몇 개를 내보낼지 랭킹을 수행하여서 결과적으로는 십수 개의 추천 아이템을 생성해서 이를 유저에게 송출합니다. 이제 아이템이 수백 개에서 아니 수백만 개에서 수백 개로 줄어들었기 때문에 이 랭킹을 할 때는 더욱더 유저와 비디오의 피처를 더 풍부하게 사용하여서 랭킹의 정확도를 높이는 방식을 사용하고 있습니다. 자 그러면 각 단계의 모델과 그 모델이 어떤 문제를 풀어야 하는지 하나씩 살펴봅시다. 첫 번째 테스크는 캔디데이트 제너레이션입니다. 여기서는 주어진 유저에 대해서 유저가 좋아할 만한 몇백 개의 비디오를 생성하는 테스크를 수행합니다. 그래서 이를 위해서 학습하는 모델이 풀어야 하는 문제는 바로 멀티 클래스 클래시피케이션입니다. 주어진 유저가 어떤 특정 시간에 컨텍스트를 가지고 있을 때 각각의 비디오를 볼 확률을 계산하는 것인데요. 이제 이 비디오가 한 개가 아니라 수백만 개가 되기 때문에 수백만 개나 되는 비디오를 클래시피케이션 하는 즉 익스트림 멀티클래스 클래시피케이션이라고 볼 수 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 4,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1079,
      "char_count": 1972
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c005_d0b717",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 첫 번째 테스크는 캔디데이트 제너레이션입니다. 여기서는 주어진 유저에 대해서 유저가 좋아할 만한 몇백 개의 비디오를 생성하는 테스크를 수행합니다. 그래서 이를 위해서 학습하는 모델이 풀어야 하는 문제는 바로 멀티 클래스 클래시피케이션입니다. 주어진 유저가 어떤 특정 시간에 컨텍스트를 가지고 있을 때 각각의 비디오를 볼 확률을 계산하는 것인데요. 이제 이 비디오가 한 개가 아니라 수백만 개가 되기 때문에 수백만 개나 되는 비디오를 클래시피케이션 하는 즉 익스트림 멀티클래스 클래시피케이션이라고 볼 수 있습니다. 주어진 다양한 유저 벡터를 가지고 맨 마지막에 이 유저가 어떤 비디오를 볼 것인지에 대한 예측을 수행하는 것인데요. 그래서 마지막엔 결국 소프트맥스를 사용하는 수백만 개의 비디오 중에 하나의 비디오를 봤다라는 그 레이블을 예측해야 하는 멀티클래스 클래시피케이션 문제입니다. 그래서 먼저 이 모델이 사용하는 피처들 가운데 가장 중요한 피처는 바로 왓치 벡터와 서치 벡터 즉 과거에 유저가 어떤 시청 이력을 가지고 있는지 어떤 검색 이력을 가지고 있는지인데요. 이런 데이터는 사실 다른 추천 모델에서 잘 활용하지는 않았지만 이 유튜브 레코멘데이션에서는 각각의 유저의 행동 데이터들을 이렇게 인베딩을 한 이후에 이 인베딩을 에버러지 해 가지고 결국 이 에버러지 된 와치 벡터와 서치 벡터를 수행해서 예측을 수행합니다. 다만 마지막에 검색했던 검색어가 너무 큰 힘을 갖지 않도록 평균을 구했습니다. 그래서 과거의 시청 이력과 검색 이력이 잘 인베딩이 되었으면 이제 이 유저가 볼 만한 비디오를 클래시피케이션 할 때 유저가 과거에 뭐 스포츠 관련된 유튜브 동영상을 많이 봤을 경우에 스포츠 동영상이 분류될 확률이 더 높게 되겠죠 다음은 데모 그래픽 지오 그래픽 피처입니다. 추천 시스템에서 유저 정보 가운데 많이 활용하는 정보가 바로 성별, 연령 혹은 지역과 같은 정보인데요. 이제 이러한 데이터는 적절한 방법으로 인베딩을 해서 사용하고 있고요. 그리고 또 중요한 피처가 바로 이 이그잼플 에이지라는 피처입니다. 이 아이템이 언제 생성됐는지에 대한 피처를 사용하지 않고 모델을 학습하게 되면 계속해서 과거에 인기 있던 데이터 위주로 편향이 되어서 학습이 됩니다. 따라서 이 시청 로그가 학습 시점으로부터 얼마나 경과했는지 즉 이 데이터가 최근 데이터인지 혹은 과거 데이터인지 그 정보를 이그젠플 에이지라는 값으로 구성하고 그래서 과거 데이터의 경우에는 좀 덜 학습되게 그리고 최신 데이터의 경우에는 더 많이 학습될 수 있도록 이 피처를 예측의 인풋으로 사용해 주는 것입니다. 이렇게 해서 부트 스트래핑 현상은 방지하고 이 프레시니스 즉 새로운 동영상이 더 잘 추천될 수 있도록 모델을 변형한 것입니다. 네 그렇게 해서 유저가 과거에 봤던 왓치 벡터와 서치 벡터 를 인베딩해서 에버러지 하고 그 외에 지오 그래픽이나 이그젠플 에이지 같은 피처를 다 구해주고 이 모든 피처 벡터를 마지막 엠엘피 레이어에서는 하나의 컨케이트네이트 된 벡터로 만들어 줍니다. 그리고 그 위에 댄스 한 레이어 피드 포워드 유뉴럴 네트워크를 쌓아서 최종적으로 유저 벡터를 생성하게 되고 이 유저 벡터에 대해서 마지막에 이 유저가 어떤 비디오를 봤는지 멀티클래스 클래시피케이션 테스크를 수행하여서 최종적으로 로스를 구하게 됩니다. 그래서 마지막 아웃 플레이어는 어떤 비디오를 봤는지 클래시피케이션 하는 문제, 즉 소프트맥스 펑션을 사용하는 멀티클래스 클래시피케이션 문제입니다. 다음 내용은 캔디데이 제너레이션 모델이 서빙되는 부분입니다. 보통의 논문들은 모델의 성능을 이야기하긴 하지만 서빙을 어떻게 해야 하는지에 대해서는 서술하지 않는데요. 이 유튜브 추천 레코멘데이션 논문은 수백만 개의 비디오 가운데서 수백 개의 비디오를 생성하는 이 캔디데이 제너레이션 부분을 어떻게 서빙해야 하는지도 설명하고 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 5,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1078,
      "char_count": 1966
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c006_767505",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 그래서 마지막 아웃 플레이어는 어떤 비디오를 봤는지 클래시피케이션 하는 문제, 즉 소프트맥스 펑션을 사용하는 멀티클래스 클래시피케이션 문제입니다. 다음 내용은 캔디데이 제너레이션 모델이 서빙되는 부분입니다. 보통의 논문들은 모델의 성능을 이야기하긴 하지만 서빙을 어떻게 해야 하는지에 대해서는 서술하지 않는데요. 이 유튜브 추천 레코멘데이션 논문은 수백만 개의 비디오 가운데서 수백 개의 비디오를 생성하는 이 캔디데이 제너레이션 부분을 어떻게 서빙해야 하는지도 설명하고 있습니다. 그래서 주어진 유저에 대해서 상위 n개의 비디오를 추출하기 위해서는 우리가 갖고 있는 수백만 개의 비디오에 대한 모든 소프트맥스 프로벌리티를 계산하고 그중에 가장 프로벌리티가 높은 비디오 n개를 추출해야 합니다. 따라서 주어진 유저에 대해서 수백만 개에 대한 비디오 벡터의 내적을 다 계산해야 하는데요. 이제 이 계산은 굉장히 많은 시간이 소요되고 실제로 이 연산을 통해서 실시간 서빙을 하는 것은 굉장히 불가능한 부분이라고 볼 수 있죠. 따라서 우리가 필요한 것은 주어진 유저 벡터에 대해서 가장 내적이 큰 비디오 벡터를 찾아주는 것인데요. 이렇게 소프트맥스 연산을 다 해서 가장 확률이 높은 벡터를 찾는 것이 아니라 어노이와 파이스와 같이 주어진 유저 벡터와 가장 유사한 벡터를 찾아주는 에엔의 라이브러리를 여기서 사용하게 됩니다. 그래서 이 부분은 연산을 하지만 마지막 부분인 이 소프트맥스를 계산하지 않고 주어진 유저 벡터에 대해서 비디오 벡터가 인베딩 되어 있는 인덱스에서 어프록시메이트 한 탑 n개의 아이템 벡터를 찾아주는 것이죠. 그래서 정확한 소프트맥스 값을 계산하지 않지만 그와 최대한 유사하게 주어진 유저 벡터와 최대한 유사한 아이템 벡터 수백 개를 서빙하는 방식을 취하고 있습니다. 자 다음은 방금 전에 캔디딧 제너레이션 모델에서 수백 개의 추천 후보군에 대한 선택이 끝났을 때 끝나고 나서 최종 추천을 제공하기 위한 랭킹 부분의 문제입니다. 2단계 추천 구조의 두 번째 부분이 되겠습니다. 네 기본적으로는 주어진 유저 아이템 컨텍스트에 대해서 해당 아이템이 노출되었을 때 클릭한 확률을 구하는 문제이므로 로지스틱 리그레션을 사용하여서 마지막 예측 레이어를 구성합니다. 하지만 뉴럴넷 아키텍처를 사용하기 때문에 다양한 유저와 비디오 피처를 아래와 같이 사용할 수 있는 것이죠. 또한 단순히 클릭 여부를 반영하는 것이 아니라 웨이티드 로지스틱 을 사용하고 있는데요. 이는 클릭한 이후에 시청 시간이 긴지 혹은 짧은지에 대한 값을 가중치로 사용하여서 반영하고 있습니다. 네 먼저 인풋 피처 부분을 살펴봅시다. 이 부분은 유저가 과거에 어떤 채널에서 얼마나 많은 영상을 봤는지, 비디오 왓치 팩터들 혹은 어떤 토픽의 동영상을 많이 보고 그 시간이 얼마나 지났는지, 그리고 이 유저가 어떤 랭귀지를 사용하는지, 비디오의 랭귀지는 무엇인지 등의 다양한 유저 액션 피처와 아이템 피처들을 사용합니다. 사실 이 부분은 모델 구조가 특별하다기보다는 이 도메인을 잘 아는 전문가, 즉 서비스를 잘 아는 데이터 사이언티스트 같은 인력 등이 분석을 통해서 어떤 피처가 가장 좋은지 피처를 잘 셀렉션하고 그 피처를 적당히 잘 가공해야 하는 부분입니다. 그래서 모델 자체가 중요하다기보다는 그 서비스에 맞는 피처를 잘 찾아서 랭킹 모델을 구성하는 것이 더 중요한 부분입니다. 그래서 이 인풋 피처가 마지막 레이어에서 다 합쳐지게 되고요. 이 레이어는 다시 한번 엠엘피 레이어를 통하여서 최종적으로 네트워크를 통과하게 되면은 비디오가 실제로 시청될 확률을 구하게 됩니다. 그래서 0과 1을 맞추는 CTR 예측 문제와 같다고 볼 수 있습니다. 여기서 로스 펑션은 그냥 기본적인 CTR 예측 문제와는 조금 다르게 구성되는데요. 단순한 바이너리 크로스 엔트로피가 아니라 이 웨이트드 랜 크로스 엔트로피를 사용합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 6,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1071,
      "char_count": 1966
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c007_ce9865",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 그래서 이 인풋 피처가 마지막 레이어에서 다 합쳐지게 되고요. 이 레이어는 다시 한번 엠엘피 레이어를 통하여서 최종적으로 네트워크를 통과하게 되면은 비디오가 실제로 시청될 확률을 구하게 됩니다. 그래서 0과 1을 맞추는 CTR 예측 문제와 같다고 볼 수 있습니다. 여기서 로스 펑션은 그냥 기본적인 CTR 예측 문제와는 조금 다르게 구성되는데요. 단순한 바이너리 크로스 엔트로피가 아니라 이 웨이트드 랜 크로스 엔트로피를 사용합니다. 즉 비디오를 클릭한 이후에 오래 시청했을 때와 비디오를 클릭하자마자 바로 나갔을 때의 로스 펑션을 다르게 계산하는 것이죠. 비디오를 클릭한 이후에 많이 면 많이 볼수록 그 비디오에 대해 만족했다는 것이기 때문에 그 웨이트를 더 높게 주어서 이 모델이 더 그 데이터를 잘 학습할 수 있게 하고요. 반대로 비디오를 클릭하자마자 바로 떠나는 이런 낚시나 광고성 콘텐츠 같은 경우에는 클릭이 일어나긴 하지만 시청 시간이 아주 짧기 때문에 웨이트가 거의 0에 가까울 것이고 이제 그럼 그러한 데이터는 비록 클릭은 했지만 웨이트가 아주 작기 때문에 이 모델의 로스에 거의 반영이 안 될 것입니다. 그래서 그러한 데이터는 학습에 거의 반영이 되지 않을 것입니다. 그래서 본 논문을 요약을 하자면은 딥러닝 기반의 2단계 추천을 처음으로 제안한 논문입니다. 단순히 학계에서 이야기하는 추천 성능뿐만 아니라 이 모델을 가지고 어떻게 서빙해야 현업에서 사용할 수 있는지까지 제시한 기념비적인 논문이라고 볼 수 있습니다. 그래서 캔디에 제너레이션 부분은 기본적인 시프의 아이디어를 활용하되 기존의 CF 기법은 유저 아이디만을 사용했지만 이 캔디 애니메이션 모델은 유저 아이디 외에 다양한 유저의 피처들, 다양한 아이템의 피처를 활용해서 더 정확한 탑 엔 아이템을 생성하였습니다. 또한 아이템의 최신 선을 반영하기 위해서 이그잼플 에이즈까지 사용했다는 점에서 현업의 추천에 더 가까운 모델을 제시했습니다. 그리고 랭킹 부분은 과거에 많이 사용된 로지스틱 리게션이나 트리 기반의 리그레션 트리 모델보다 딥러닝 모델이 더 뛰어난 성능을 보여주는데요. 그것은 바로 다양한 피처들을 마음껏 사용해서 마지막 레이어에서 컨케이트네이트하고 그것을 MLP 레이어를 통해서 예측을 했기 때문입니다. 또한 단순 CTR 예측으로 로스를 계산한 게 아니라 그 비디오를 클릭한 이후에 비디오를 얼마나 봤는지 익스펙티드 와치 타임을 예측하여서 더 좋은 양질의 추천 결과를 생성하였습니다. 그래서 지금까지 유튜브 추천 모델에 대한 리뷰였습니다. 이 모델 이후에 유튜브 추천 논문을 레퍼런스화하는 다양한 실용적인 모델들이 등장하게 됐는데요. 그래서 이 유튜브 레코멘데이션 논문은 여러분들이 이 강의 이후에도 다시 한 번 출력하여서 자세히 읽어보기를 추천드립니다. 그만큼 중요한 논문이기 때문입니다. 다음은 딥러닝 아키텍처 가운데 하나인 오토 인코더의 개념을 이해하고 이 오토 인코더를 활용한 추천 시스템 모델에 대해서 살펴보겠습니다. 네 먼저 오토 인코더에 대해서 간단히 살펴보겠습니다. 오토 인코더는 입력 값을 넣고 그 입력 값을 아웃풋 레이어에서 똑같이 복원하는 언슈퍼바이스 러닝 모델입니다. 아래 그림을 보시면은 인풋 데이터가 있고요. 이 인풋 데이터가 인코더를 통해서 압축된 레프레젠테이션으로 표현되고요. 이 압축된 레프레젠테이션이 다시 디코더를 통해서 기존 인풋과 최대한 비슷한 RC 스트럭트 된 인풋으로 표현되게 됩니다. 그래서 보통 인코더는 보통 오토 인코더는 인코더와 디코더 구조로 쌍을 이루어서 모델을 이루고 있습니다. 그래서 오토 인코더 모델은 방금 언급한 것처럼 주어진 인풋에 대해서 추론된 리컨스트럭트 인풋과 차이를 최대한 줄이는 방법으로 로스 펑션을 구성하고 그래서 이미지 데이터와 같은 경우에는 뭐 루트민 스퀘어 같은 에러를 사용하기도 하고요. 스퍼스 인풋 데이터 같은 경우에는 소프트 맥스 값을 이용해서 로스 값을 구성하기도 합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 7,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1089,
      "char_count": 1998
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c008_c38b01",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 그래서 보통 인코더는 보통 오토 인코더는 인코더와 디코더 구조로 쌍을 이루어서 모델을 이루고 있습니다. 그래서 오토 인코더 모델은 방금 언급한 것처럼 주어진 인풋에 대해서 추론된 리컨스트럭트 인풋과 차이를 최대한 줄이는 방법으로 로스 펑션을 구성하고 그래서 이미지 데이터와 같은 경우에는 뭐 루트민 스퀘어 같은 에러를 사용하기도 하고요. 스퍼스 인풋 데이터 같은 경우에는 소프트 맥스 값을 이용해서 로스 값을 구성하기도 합니다. 그래서 보통 오토 인코더가 활용되는 대표적인 분야는 이상치를 탐지하는 어노말리 디텍션 그리고 중간에 이 히든 레이어가 인풋 데이터를 압축하는 압축된 레프레젠테이션으로 표현되기 때문에 이 레프레젠테이션 러닝을 다른 테스크에도 사용하기도 합니다. 그래서 통상적인 레프레젠테이션 러닝에도 이 오토 인코더가 많이 활용되고요. 또한 이미지 노이즈를 제공하는 이미지 디노이징 테스크에도 활용됩니다. 원래 오토 인코더는 기존의 이미지를 최대한 비슷하게 복원하는 테스크에서 시작했지만 실제 적용 문화를 찾다 보니 오히려 노이즈가 있는 이미지에서 노이즈를 없애는 테스크에도 반대로 활용할 수 있게 되었고 괜찮은 성능을 보였습니다. 그래서 이 테스크를 더 잘 수행하기 위해서 이 오토 인코더에서 발전된 모델이 있는데요. 바로 오토 인코더 앞에 이 디노이징이라는 이름이 붙은 디노이징 오토 인코더입니다. 기존의 입력 데이터는 노이즈가 없는 데이터인데요. 여기에 일부러 그 모델을 설계한 사람이 랜덤 노이즈나 드로브 아웃 같은 것을 추가하여서 노이지한 인풋을 강제로 생성해 주게 됩니다. 그래서 이 노이즈 한 인풋을 모델의 입력 값으로 사용하고 인코더와 디코더를 거쳐서 노이즈가 없는 원래 오리지널 이미지로 복원될 수 있도록 학습을 구성합니다. 이제 이렇게 학습할 경우 노이즈 한 인풋을 더 잘 복원해 줄 수 있는 로버스트한 모델이 학습되고 학습 데이터 에 있는 깨끗한 인풋 데이터에만 오버피팅 되는 오토 인코더가 아니라 이러한 오버피팅 되는 기존의 한계를 극복해서 더 좋은 제너럴라이제이션 성능을 보이는 모델로 발전되게 되었습니다. 그래서 이 디노이즈 오토 인코더가 일반적인 오토 인코더 제일 기본적인 오토 인코더보다 여러 테스크에서 좋은 성능을 보였습니다. 사실 지노이징 오토 인코더 이후에도 베리에이셔널 오토 인코더나 컨디셔널 오토 인코더와 같은 더 발전된 형태의 오토 인코더가 계속 등장하고 이러한 모델도 똑같이 추천 시스템에 사용되긴 했지만 저희는 이런 오토 인코더가 어떻게 발전되었는지에 대한 내용보다는 이 오토 인코더가 도대체 추천 시스템에서 어떤 형태로 활용되는지를 배워야 합니다. 그래서 앞으로 두 개의 모델을 다루면서 추천 시스템의 오토 인코더가 어떻게 적용되어 있는지 학습해 봅시다. 네 그래서 다음으로 살펴볼 논문은 오토렉입니다. 이 모델은 굉장히 간단하고 논문의 길이도 두 장으로 굉장히 짧은데요. 기존의 오토인코더를 컬래버레이트 필터링에 적용하여서 유저와 아이템에 대한 인베딩을 더 잘 표현하고 반대로 복잡도는 줄인 모델입니다. 아까 언급했던 것처럼 오토인코더는 레프레젠테이션 러닝 측면에서 좋은 성능을 내기 때문에 다양한 다운스트림 테스크에 많이 응용된다고 했죠. 이를 그대로 추천 시스템에 적용하면은 유저와 아이템의 인베딩을 오토 인코더를 활용하면은 좋은 레프리젠테이션을 만들 수 있기 때문에 이 원리를 사용하여서 오토렉이 등장하게 되었습니다. 본 논문의 아이디어는 다음과 같습니다. 오토 인코더의 입력 데이터를 레이팅 벡터, 즉 유저가 아이템에 매긴 평점 벡터로 사용한다는 것입니다. 아까 전에 예시에서는 이미지 데이터를 가지고 복원을 했는데요. 여기서는 이미지 데이터가 아니라 레이팅 데이터를 입력으로 하고 출력으로 하여서 이 레이팅 벡터를 복원하는 테스크를 수행합니다. 즉 유저나 아이템을 기준으로 기존에 주어진 평점 데이터를 그대로 복원하는 것이죠. 유저와 아이템의 벡터를 저차원의 레이턴트 피처로 나타내고 이를 사용해 평점을 예측합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 8,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1115,
      "char_count": 2020
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c009_c0a887",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 본 논문의 아이디어는 다음과 같습니다. 오토 인코더의 입력 데이터를 레이팅 벡터, 즉 유저가 아이템에 매긴 평점 벡터로 사용한다는 것입니다. 아까 전에 예시에서는 이미지 데이터를 가지고 복원을 했는데요. 여기서는 이미지 데이터가 아니라 레이팅 데이터를 입력으로 하고 출력으로 하여서 이 레이팅 벡터를 복원하는 테스크를 수행합니다. 즉 유저나 아이템을 기준으로 기존에 주어진 평점 데이터를 그대로 복원하는 것이죠. 유저와 아이템의 벡터를 저차원의 레이턴트 피처로 나타내고 이를 사용해 평점을 예측합니다. 다음은 매트리스 팩토라이제이션과 간단히 비교해 볼 텐데요. 이 매트리스 팩토라이제이션은 리니어하고 로우 오더 한 인터랙션 을 통해 레프레젠테이션이 학습되기 때문에 그 표현력에 어느 정도 한계가 있지만 오토랙 같은 경우에는 논 리니언 a티베이션 펑션을 사용하기 때문에 좀 더 복잡한 인터랙션이 표현되게 됩니다. 네 다음은 오토랙을 그림으로 표현해 보았습니다. 상당히 간단한데요. 인풋과 아웃풋은 아까 얘기했던 것처럼 레이팅 벡터가 되는데요. 유저나 아이템을 기준으로 레이팅 벡터를 만들 수 있습니다. 아래 그림은 아이템을 기준으로 전체 유저에 대한 레이팅을 구성한 것입니다. 그래서 이 알아는 아이템 아의 레이팅 벡터가 되고요. 각각의 이 레이팅 벡터는 하나하나가 개별 유저와 아이템의 평점으로 이루어져 있습니다. 그래서 이 전체 아이템 벡터의 차원은 m 차원 즉 유저 전체의 수와 같게 되고요. 이제 이 레이팅 벡터는 인코더의 가중치 행렬인 v와 곱해져서 가운데 있는 덴 싼 레프레젠테이션이 표현되게 됩니다. 그리고 다시 이 덴싼 레프레젠테이션은 디코더의 가중치 행렬 웨이트 매트릭스가 곱해져서 다시 원래의 레이팅 매트릭스 즉 m 차원의 아이템 벡터로 복원되게 됩니다. 모델이 학습이 수행될 때는 기존의 실제 레이팅과 모델을 통해서 리컨스트렉트 된 레이팅에 루트 미스크 에러 즉 두 개의 차이의 제곱의 루트를 씌운 값을 최소화하는 방향으로 학습되게 됩니다. 그리고 이 에러는 전체 레이팅이 아니라 우리가 갖고 있는 관측된 데이터에 대해서만 학습을 하고 그 관측된 데이터의 로스만 가지고 각각의 파라미터를 업데이트합니다. 여기에 있는 이 이치라는 수식이 오토 인코더를 나타내는 펑션이고요. 이 치라는 수식을 살펴보면은 원래 레이팅 값에 인코더의 가중치 매트릭스를 곱하고 거기에 이제 뮤를 라는 바이어스를 더해서 쥐라는 액티베이션 펑션을 씌우게 되면은 이 쥐라는 값은 가운데에 있는 레프레젠테이션이 되고요. 다시 이 가운데에 있는 레프레젠테이션에 디코더의 매트릭스를 곱하고 다시 거기에 가중치 바이러스를 더해주면 최종적으로 디코더를 통과한 리컨스트럭티드 레이팅이 구해집니다. 그래서 이 치와 실제 레이팅 사이의 차이를 최소화하는 방향으로 각각의 브블 그리고 뮤비가 학습이 됩니다. 본 논문에서는 이 활성화 함수 g와 f 를 시그모이드와 아이덴티티 펑션으로 사용했다고 말합니다. 어떤 활성화 함수를 사용하느냐에 따라서 약간의 성능 차이는 발생한다고 합니다. 사실 오토랙 같은 경우에는 지금으로부터 거의 7년 전인 2015년에 발표된 논문이기 때문에 좀 오래된 페이퍼이기도 하고요. 상당히 간단한 딥러닝 구조를 사용하고 있습니다. 따라서 당시에 좋은 성능을 보이던 모델도 굉장히 단순한 모델인 r비엠과 매트리스 팩토라이제이션이 있었고 그래서 그 두 가지 모델과의 추천 성능을 비교하였습니다. 이 레이팅을 예측하는 모델이기 때문에 로스 펑션은 알엠에스이로 구성하였고, 이 RMSE를 기준으로 기존의 알비엠이나 엠프와 같은 모델보다 더 좋은 성능을 보임을 알 수 있습니다. 또한 가운데 인코더 디코더 레이어 가운데에 있는 레프리젠테이션 레이어의 노드 개수가 점점 늘어날수록 알엠스는 감소하는 것을 볼 수 있는데요. 이 노드의 개수는 가운데에 있는 히든 레이어 즉 유저와 아이템의 벡터를 몇 차원으로 레프레젠테이션 하느냐를 의미하는 것입니다. 물론 어느 어느 정도 증가하게 되면 그 알엠스의 감소 폭은 줄어들게 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 9,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1112,
      "char_count": 2035
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c010_5776a3",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 이 레이팅을 예측하는 모델이기 때문에 로스 펑션은 알엠에스이로 구성하였고, 이 RMSE를 기준으로 기존의 알비엠이나 엠프와 같은 모델보다 더 좋은 성능을 보임을 알 수 있습니다. 또한 가운데 인코더 디코더 레이어 가운데에 있는 레프리젠테이션 레이어의 노드 개수가 점점 늘어날수록 알엠스는 감소하는 것을 볼 수 있는데요. 이 노드의 개수는 가운데에 있는 히든 레이어 즉 유저와 아이템의 벡터를 몇 차원으로 레프레젠테이션 하느냐를 의미하는 것입니다. 물론 어느 어느 정도 증가하게 되면 그 알엠스의 감소 폭은 줄어들게 됩니다. 그래서 본 논문 이후에 이 오토 인코더 기법을 좀 더 고급 오토 인코더로 발전한 다양한 컬래버레이트 필터링 논문들이 다음과 같이 등장했는데요. dae 혹은 vae를 활용한 아래의 논문들도 여러분들이 관심이 있으면 찾아보고 공부해 보시길 추천드립니다. 네 그래서 다음은 이 고급 오토 인코더 가운데 디노이징 오토 인코더 를 컬래버레이트 필터링에 적용한 모델, 즉 컬래버레이트 디노이징 오토인코더라는 cdae 논문입니다. 이름 그대로 디노이징 오토 인코더를 사용하였으며 학습 데이터를 적절하게 가공해서 탑 엔 레코멘데이션 즉 웨이팅을 정확하게 예측하는 것이 아니라 아이템에 대한 선호도를 예측하여서 그 아이템 탑 n개를 추천하는 논문으로 구성하였습니다. 네 이 모델은 오토랙과 달리 평점을 예측하는 레이팅 프로젝션 문제가 아니라 유저에게 탑 엔 추천을 제공하는 모델로 설계하였습니다. 그래서 오토렉의 경우에는 최종 성능 비교를 알엠스 즉 테이터 테스트 데이터의 웨이팅을 얼마나 정확하게 복원했는지로 평가했지만 본 논문 씨디에이는 유저에게 탑 앤 추천을 얼마나 잘 제공했는지 엔디시지와 같은 매트릭으로 추천 성능을 평가하고 있습니다. 그리고 탑 n 추천 문제로 정의하면서 문제를 단순화하기 위해서 유저 아이템의 레이팅 정보를 실수 값이 아닌 0 또는 1의 바이너리 정보로 바꾸어서 학습 데이터를 사용하였습니다. 어떤 프리퍼런스 즉 얼마나 선호하냐 그 선호도 정보를 학습하게 됩니다. 그리고 이 선호도가 곧바로 탑 앤 추천에 활용됩니다. 네 다음은 cdae 컬래버레이티브 디노이징 오토 인코더의 특징에 대해서 자세히 살펴봅시다. 가장 큰 차이점은 여기에 있는 da 디노이징 오토 인코더를 사용한다는 점입니다. 한 명의 유저 율을 기준으로 모든 아이템에 대한 평점인 yu를 구한 뒤 이 yu를 그대로 사용하지 않고 yu 틸드 값을 사용합니다. 이 yu 틸드는 q의 확률로 의해 0으로 드롭아웃 된 벡터입니다. 즉 q의 확률로 어떤 원소는 0이 되고 1 마이너스 q의 확률로는 어떤 원소는 기존 평점 값에 델타가 곱해지게 됩니다. 그래서 이렇게 해서 노이즈 한 인풋을 만들어서 디노이징 오토인 코드를 구성하였고요. 또 하나의 차이점은 개별 유저에 대한 브유라는 파라미터가 존재한다는 것입니다. 유저별로 갖는 특징들이 있을 텐데 그 유저별 특징을 이 브유라는 파라미터가 각각 개별 유저에 대해서 학습을 하게 됩니다. 그리고 이는 유저별 탑 앤 추천에 활용돼서 추천 성능을 높여줍니다. 각각의 유저별로 특징이 다르고 그 특징이 각각의 파라미터를 통해 학습이 되면서 이 모델에 컬래버레이티브라는 이름이 붙게 되었음을 언급 드립니다. 그래서 이를 수식으로 나타내면 인코더 부분에 노이즈 한 인풋인 와유틸드가 사용되었고 그리고 개별 유저의 벡터인 브이 즉 유저 노드가 사용되어서 가운데에 있는 히든 레이어를 구성하게 됩니다. 그리고 히든 레이어가 다시 디코더를 통해서 복원되는 것은 기존의 오토 인코더와 동일합니다. 그래서 가장 큰 차이점은 바로 이 yu 틸드를 사용해서 인풋 값을 n이지하게 바꿨다. 그리고 유저에 대한 파라미터를 추가하여서 유저별 특징을 학습하도록 하였다. 이 두 가지가 앞에서 언급한 오토랩과의 가장 큰 차이점이라고 볼 수 있습니다. 그래서 해당 모델을 사용하여서 기존의 탑 엔 추천 테스크에서 좋은 성능을 내던 다른 모델과 비교한 결과를 본 논문에서 제시하고 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 10,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 1093,
      "char_count": 2028
    },
    {
      "id": "transcript_recsys_이론_recsys_이론_6강_recommender_syste_c011_2f5e9c",
      "content": "[RecSys 이론] [RecSys 이론] (6강) Recommender System with Deep Learning 1\n\n다. 그리고 히든 레이어가 다시 디코더를 통해서 복원되는 것은 기존의 오토 인코더와 동일합니다. 그래서 가장 큰 차이점은 바로 이 yu 틸드를 사용해서 인풋 값을 n이지하게 바꿨다. 그리고 유저에 대한 파라미터를 추가하여서 유저별 특징을 학습하도록 하였다. 이 두 가지가 앞에서 언급한 오토랩과의 가장 큰 차이점이라고 볼 수 있습니다. 그래서 해당 모델을 사용하여서 기존의 탑 엔 추천 테스크에서 좋은 성능을 내던 다른 모델과 비교한 결과를 본 논문에서 제시하고 있습니다. 대체적으로 이 n에 관계없이 다른 탑 엔 추천 모델, 즉 아이템 베이스나 MF 와 같은 다른 추천 모델에 비해서 이 씨디에이가 좋은 타앤 추천 성능을 보임을 알 수 있습니다. 네 여기까지가 씨디에이 콜라보레이티브 디노이징 오토 인코더에 관한 내용이었습니다. 이 논문 외에도 다른 고급 오토 인코더를 사용한 추천 모델은 계속해서 발표되어 왔는데요. 이 개별 모델에 대한 이해도도 중요하지만 무엇보다 오토 인코더를 활용한 추천 모델이 어떻게 유저 아이템 인베딩이 학습되는지를 기억하는 것이 제일 중요하다고 볼 수 있습니다. 네 이상 여섯 번째 강의가 모두 끝났습니다. 오늘도 수고하셨습니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "[RecSys 이론] (6강) Recommender System with Deep Learning 1.json",
        "lecture_name": "[RecSys 이론] (6강) Recommender System with Deep Learning 1",
        "course": "RecSys 이론",
        "lecture_num": "6강",
        "lecture_title": "Recommender System with Deep Learning 1",
        "chunk_idx": 11,
        "total_chunks": 12,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b47bb84c4b5def22d5e7f6b8edddfee9a42f4169e4f8cb34a61f9ea5a502be45"
      },
      "token_estimate": 344,
      "char_count": 663
    }
  ]
}