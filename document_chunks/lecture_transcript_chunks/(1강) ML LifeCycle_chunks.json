{
  "source_file": "(1강) ML LifeCycle.json",
  "lecture_name": "(1강) ML LifeCycle",
  "course": "ML Engineering",
  "total_chunks": 15,
  "chunks": [
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c000_c56b49",
      "content": "[강의 녹취록] 과목: ML Engineering | 강의: 1강 | 제목: ML LifeCycle\n\n안녕하세요. 여러분 머신 러닝 라이프 사이클 강좌에 오신 것을 환영합니다. 제 이름은 김수경이라고 하고요. 이화여자대학교 인공지능 융합 전공에 이번 학기부터 조교수로 부임한 어 새로운 교수입니다. 먼저 이번에 이제 머신 러닝 라이프 사이클 강좌에 이렇게 오신 것을 환영합니다. 이 부트 캠프를 이제 시작하기 전에 환영 인사와 함께 저에 대한 소개를 간단하게 드리려고 합니다. 말씀드린 것처럼 제 이름은 김수경이고 이화여자대학교 인공지능 융합 전공 소속입니다. 그래서 불과 4개월 전에는 미국에 있었는데 이번 학기부터 이화여자대학교에 부임하게 되었습니다. 미국에서는 졸업 후 이화여자대학교를 졸업했고 17년 동안 학교랑 연구소를 거치면서 머신 러닝 연구를 했는데요. 먼저 뉴욕에 있는 콜롬비아 대학에서 석사로 전자공학과 솔리드 스테이트 일렉트리컬 엔지니어링을 전공했고 그다음에 인턴십을 거친 다음에 조지아텍에서는 재료 시뮬레이션 연구를 했고 머신러닝 석사를 해서 그 후에는 주로 내셔널 랩이나 국가 연구소 산업 연구소에서 머신 러닝 연구를 진행해 왔습니다. 제 연구 관심 분야를 간단하게 소개시켜 드리면은 주로 설명 가능한 AI 익스플레이너블 AI라고 하죠. 이런 분야에 관심이 많고 제 이전까지의 연구 영역은 주로 인공지능 융합 연구를 주로 했고 제가 관심 있는 거는 과학 데이터랑 머신 러닝 메소드를 융합하는 연구를 많이 했습니다. 그래서 제 사실 박사 전공이 재료 공학이에요. 그래서 인공지능 모델을 이용해서 어떻게 하면은 재료를 최적화하고 신소재를 개발하고 신약을 개발할 수 있는지 주로 생성 모델을 이용해 가지고 이런 일들을 많이 했었고 강화 학습을 이용해서 스마트 시티나 어떤 컨트롤 시스템을 옵티마이제이션 하는 연구들도 많이 했습니다. 그리고 추가적으로 요새 클라이메이 체인지가 되게 심각한데요. 이런 기후 변화를 태클하기 위해서 인공지능 모델을 이용해서 굉장히 값비싼 물리 기반 모델을 인공지능 기반 모델로 대체하는 연구들을 많이 했습니다. 자 그러면 이제 시작해 보도록 하겠습니다. 오늘은 머신 러닝에 굉장히 기초가 되는 그 머신 러닝의 개념 머신 러닝이란 어떻게 하면은 머신 러닝을 적용할 수 있는지 학습의 종류는 뭐가 있는지 개념적인 것을 이렇게 배우게 될 거고요. 그다음에 이제 본격적으로 머신 러닝 라이프 사이클이란 무엇인지에 대해서 어떻게 머신 러닝 모델을 만들고 이거를 갖다가 프로덕트에 인플리멘트 해가지고 실제로 회사에서 쓸 수 있는 프로덕트로 만들고 그거를 어떻게 우리가 배포하고 유지 관리할 수 있는지 대략적인 아이디어를 설명드리도록 하겠습니다. 그래서 이번 강의는 가장 첫 번째 세션이기 때문에 여러분들 어떤 소개하는 세션이라고 생각하시고 편하게 들으시면 될 것 같습니다. 자 그러면은 머신 러닝에 대해서부터 이제 개괄적인 아이디어부터 보도록 할게요. 기본적으로 머신 러닝 하면은 사람들이 굉장히 머신 러닝이라는 텀을 많이 많이 이용하게 되고 또 딥러닝이라는 말도 많이 이용하죠. 그리고 요새는 인공지능이다 인공지능이다 해서 뭐 광고를 보던 텔레비전를 보던 신문을 보던 이런 인공지능이라는 텀이 굉장히 많이 이용이 되는 것을 볼 수가 있어요. 하지만 이 인공지능 머신러닝 딥러닝이라는 개념은 사실은 좀 차이가 있는 개념이고 이러한 구조를 가지고 있습니다. 먼저 인공지능이 가장 큰 개념이고 그 하위 개념이 머신 러닝이고 그 하위 개념이 딥러닝이에요. 그래서 하나씩 이제 개괄적으로 살펴보도록 할게요. 먼저 인공지능 알티피셜 인텔리전스 AI라고 하죠. 이 에 인공지능은요 기본적으로 인공지능입니다. 즉 기계가 인간처럼 지능적인 행동을 할 수 있도록 하는 모든 기술을 말해요. 그래서 굉장히 포괄적인 개념이고 어떻게 보면 한 뭐 인간의 우리가 이렇게 사람으로서 인지할 수 있는 능력을 기계가 모방하려고 하는 모든 시도를 포함하는 굉장히 큰 개념이라고 생각하시면 돼요. 그리고 머신 러닝이 인공지능이라는 개념에 속합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 0,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1093,
      "char_count": 1985
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c001_280bed",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 즉 기계가 인간처럼 지능적인 행동을 할 수 있도록 하는 모든 기술을 말해요. 그래서 굉장히 포괄적인 개념이고 어떻게 보면 한 뭐 인간의 우리가 이렇게 사람으로서 인지할 수 있는 능력을 기계가 모방하려고 하는 모든 시도를 포함하는 굉장히 큰 개념이라고 생각하시면 돼요. 그리고 머신 러닝이 인공지능이라는 개념에 속합니다. 머신 러닝 ML이라고 하죠. 머신 러닝은 기본적으로 AI의 하위 분야예요. 말씀드린 것처럼 그래서 명시적으로 어떤 프로그래밍이 되어 있지 않아도 우리가 데이터셋으로부터 굉장히 많은 데이터로부터 학습을 하고 어떤 테스크를 하기 위해서 예측하거나 어떤 디시전 메이킹 결정을 할 수 있는 시스템을 만드는 기술입니다. 그래서 기본적으로 우리가 머신 러닝이라고 하면요. 머신러닝 알고리즘은 어떤 데이터로부터 패턴을 인식하고 그 패턴을 기반으로 결과를 예측하는 어떤 모델이라고 생각하면 돼요. 그래서 패턴 인식이라고 이해하시면 됩니다. 딥러닝은 머신 러닝을 가능하게 하는 한 가지 메소드입니다. 그래서 기본적으로 딥러닝은 머신 러닝의 하위 분야로 다층 신경망 모델을 이용해서 즉 딥 뉴럴 네트워크라는 모델을 이용해서 굉장히 복잡한 데이터의 어떤 패턴을 학습하는 이런 기술이라고 생각하시면 됩니다. 그래서 인공지능이 가장 큰 개념 그 밑에 머신 러닝이 있고 그 밑에 딥러닝이 있습니다. 자 그러면은 이제 우리가 오늘 배울 거는 머신 러닝입니다. 머신 러닝이란 무엇인가 머신 러닝이란 이 탑 미체이라는 그 머신 러닝의 대가의 텍스트북 을 보면 이러한 정의가 나와 있습니다. 러닝 is 애니 프로세스 바이 위치 시스템 인프로브 퍼포먼스 m 익스피리언스 시스템이 어떤 익스피리언스 경험을 통해서 그거의 어떤 성능을 향상시키는 거를 러닝이라고 한대요. 머신 러닝은 이 러닝 프로세스를 머신 기계가 하는 거예요. 그래서 기계 학습이죠. 그래서 기본적으로 이 정의를 보면요. 이렇게 세 가지로 나누어서 생각할 수 있어요. 머신 러닝이라는 기본적으로 어떤 작업 티에 대해서 어떤 작업이 주어져야 돼요 우리 프로블럼 스테이트먼트죠. 어떤 작업 티에 대해서 경험 이와 함께 성능을 향상시키는 어떤 테스크를 머신 러닝이라고 해요. 그래서 머신 러닝 테스크를 정의하기 위해서는 여기 이렇게 말씀드린 것처럼 작업 티랑 경험이랑 성능 p가 주어져야 돼요. 그래서 머신 러닝을 정의하기 위해서는 작업이 뭔지 우리가 풀려는 태스크가 뭔지 p를 정의를 해야 되고 그 작업을 풀기 위해서 어떤 경험을 해야 되는지 2가 주어져야 되고 그리고 이 프로세스를 통해서 어떻게 성능을 향상시키는지 그 성능 p가 주어져야 돼요. 그래서 기본적으로 제가 연구소에서도 느꼈던 건데 머신 러닝을 실제로 연구하지 않는 외부 사람들은 마치 머신 러닝을 매직 박스처럼 생각해요. 머신 러닝을 이용하면 이것도 할 수 있고 저것도 할 수 있고 모든 문제를 다 풀어줄 거다라는 어떤 희망을 가지고 있는데 실제로는 그렇지 않습니다. 이 세 가지가 정의가 돼야지 머신 러닝이라는 문제가 정의되고 머신러닝 모델을 이용해서 문제를 풀 수가 있습니다. 자 그래서 문제 정의를 어떻게 하는지 한번 이그 샘플 예시를 통해서 한번 보도록 할게요. 먼저 머신 러닝을 배울 때 가장 널리 사용되는 어떤 그 예시가 이미지 클래시피케이션입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 1,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 897,
      "char_count": 1645
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c002_216914",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 이 세 가지가 정의가 돼야지 머신 러닝이라는 문제가 정의되고 머신러닝 모델을 이용해서 문제를 풀 수가 있습니다. 자 그래서 문제 정의를 어떻게 하는지 한번 이그 샘플 예시를 통해서 한번 보도록 할게요. 먼저 머신 러닝을 배울 때 가장 널리 사용되는 어떤 그 예시가 이미지 클래시피케이션입니다. 이미지 분류 작업이죠. 기본적으로 어떤 이미지를 컴퓨터가 보고 머신러닝 알고리즘의 이미지를 보고 그 이미지가 어떤 이미지인지 분류하는 거예요. 이 이미지가 고양이인지 개인지 아니면은 말인지 이런 거를 분류하는 거를 이미지 클래시피케이션인 테스크라고 해요. 자 이 테스크에서는 작업이 뭘까요? 자명하죠. 주어진 이미지가 고양인지 개인지 말인지 어떤 클래스인지를 분류하는 작업이죠. 그러면 어떤 경험을 통해서 이 테스크를 할 수가 있을까요? 경험은 어떻게 보면은 이렇게 다양한 고양이랑 개로 이루어진 엄청나게 많은 이미지 데이터를 보고서 우리가 이거를 분류하는 거죠. 그래서 경험은 다양한 고양이와 개 이미지로 이루어진 어떤 학습 데이터 셋이라고 정의를 할 수가 있을 거예요. 자 그러면은 이 경험을 통해서 작업을 할 때 어떻게 우리가 이 어 알고리즘이 머신러닝 알고리즘이 잘 동작하는지 성능을 평가할 수 있을까 성능으로서는 이미지 분류 정확도가 있겠죠. 여러 가지 정확도 매트릭이 있는데 이 이미지를 얼마나 요 머신 러닝 모델이 정확하게 분류하는지 이미지가 주어져 있으면 이게 고양인지 개인지를 어떻게 정확히 분류할 수 있는지 이 정확도라는 매트릭을 이용해서 우리가 성능 피를 평가할 수 있을 거예요. 한 번 더 해보죠. 또 하나의 테스크 이그잼플로 볼 수 있는 게 스팸 메인 필터링이에요. 메일이 쭉 들어오면은 우리가 안 좋은 메일 스팸 메일만 필터링 해 가지고 스팸 메일 편지통에다 넣고 싶어요. 그래서 작업은 또 여전히 자명하죠. 이메일이 스팸인지 아니면 정상 이메일인지 분류하는 작업 이것도 역시 클래시피케이션 테스크가 되겠네요. 그러면 이거는 경험이 뭘까요? 스팸이랑 정상 메일이랑 이렇게 레이블 된 많은 메일 데이터셋이 되겠죠 메일이 쭉 있으면은 스팸 메일이면은 이게 스팸 메일이다 이렇게 레이블이 돼 있고 정상 메일이면은 정상 메일이다 이렇게 레이블이 되어 있는 이 데이터셋을 경험이라고 이렇게 정의 내릴 수 있을 거예요. 그러면은 성능은 뭘까요? 또 마찬가지로 이 이메일 클래시피케이션 테스크니까 이 이메일 분류 테스크의 정확도를 우리가 성능으로 생각할 수 있겠습니다. 자 그래서 이 머신 러닝 모델을 우리가 생각하는 그런 전통적인 프로그램이랑 비교해서 설명해 보면 이런 차이가 있어요. 예를 들어 전통 프로그램이라고 하면은 한 예로 어 뭐 예를 들어 소팅 알고리즘 같은 게 있겠죠 어떤 어레이 숫자가 이루어진 어레이가 들어왔을 때 그 어레이를 작은 숫자부터 큰 숫자까지 예쁘게 소팅하는 어떤 알고리즘 이런 게 전통적인 프로그래밍 알고리즘이라고 생각할 수가 있겠죠. 그런 전통적인 프로그래밍 알고리즘을 보면은 대부분 이 과정을 통해서 출력값을 예측을 하는 테스크를 진행합니다. 즉 컴퓨터를 이용해서 컴퓨터가 어떤 데이터를 받아들이고 그리고 그 데이터를 갖다가 어 뭐 소팅하는 프로그램 같은 게 되겠죠. 그런 프로그램을 이렇게 받아들여서 데이터랑 프로그램을 이용해서 우리가 원하는 출력값을 예측하는 식으로 되어 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 2,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 919,
      "char_count": 1674
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c003_e31585",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 즉 컴퓨터를 이용해서 컴퓨터가 어떤 데이터를 받아들이고 그리고 그 데이터를 갖다가 어 뭐 소팅하는 프로그램 같은 게 되겠죠. 그런 프로그램을 이렇게 받아들여서 데이터랑 프로그램을 이용해서 우리가 원하는 출력값을 예측하는 식으로 되어 있습니다. 예를 들어 뭐 솔팅 알고리즘을 말씀드렸으니까 한번 이 어 프레임웍에 맞춰 가지고 생각을 해볼게요. 솔팅 알고리즘의 데이터는 뭐예요? 그 뒤죽박죽 들어있는 숫자들로 이루어진 어떤 어레이죠? 그게 인풋이에요. 그리고 프로그램은 뭐예요? 그 인풋을 받아 가지고 그 인풋을 갖다가 작은 숫자에서 큰 숫자로 이렇게 솔팅이 되게 만드는 어떤 프로그램이 되겠죠 이 인풋이랑 프로그램을 가지고 컴퓨터가 그걸 받아들여서 출력 값 예쁘게 솔팅된 어레이의 아웃풋 값을 이렇게 예측하는 게 전통적인 프로그램 방식이라고 할 수가 있어요. 하지만 머신 러닝은 좀 반대예요. 데이터랑 출력 값이 같이 들어가요. 즉 어떤 레이블 된 형태의 데이터가 들어간다는 거죠. 예를 들어 아까 이미지 클래시피케이션 같은 테스크를 보면은 데이터는 수많은 이미지요. 그렇죠 개랑 고양이랑 말이랑 뭐 여러 가지 클래스로 이루어진 수많은 이미지가 데이터가 되겠죠. 이런 인풋 데이터가 그 출력 값이랑 같이 레이블 돼가지고 컴퓨터로 들어가요. 출력값은 뭐예요? 개는 개라고 레이블l 되어 있는 그 출력이고 고양이는 고양이로 레이블 되어 있는 이런 출력이죠. 이런 데이터랑 출력값이 컴퓨터에 같이 들어가서 머신 러닝 모델을 이용해서 프로그램을 알아서 이 안에서 이렇게 학습하는 과정으로 이루어져 있습니다. 그래서 이렇게 생각하시면 편해요. 전통적인 프로그램은 룰 베이스드 알고리즘을 이용해서 만들어진 프로그램이고 머신 러닝은 데이터를 갖다가 인풋으로 받아 가지고 그 패턴을 학습하는 어떤 알고리즘을 우리가 학습하는 식으로 만들어져 있는 이 프레임웍을 가지고 있습니다. 자 그러면은 이제 머신 러닝의 적용 사례를 보도록 하겠습니다. 이 머신 러닝이 이렇게 딥러닝이 부밍 되면서 어 한 5 6년 전부터 굉장히 인기를 끌고 있고 지금은 그 5 6년 동안 하나도 빼놓지 않고 곳곳에 머신 러닝이 적용이 돼 가지고 이용되고 있어요. 그래서 대표적인 적용 사례를 보면은 컴퓨터 비전 테크닉을 이용해서 우리가 스마트폰 이용하잖아요. 그 스마트폰에서 얼굴 인식이라든지 아니면은 얼굴을 좀 더 예쁘게 보정해 준다든지 이런 모든 앱 같은 거 앱 같은 거에 모두 컴퓨터 비전 기술이 내재되어 있어요. 그리고 뭐 문자 인식할 때 뭐 우리가 문자 쓸 때 자동 완성 기능이 있잖아요. 그것도 그 머신 러닝 중에 NLP 랭귀지를 프로세스하는 어떤 알고리즘이 내재돼 가지고 그 우리가 어떤 문자 텍스트를 쓰면 그다음에 어떤 월드가 올지를 예측하는 알고리즘이 뒤에서 돌아가서 이렇게 보여주고 있죠. 음성 인식도 마찬가지죠 여러분 아이폰 쓰시면 시리 시리 같은 거 많이 쓰시잖아요. 우리가 이렇게 스마트폰에다가 말을 하면은 그거를 스마트폰이 알아듣도록 하는 알고리즘도 머신 러닝입니다. 그리고 자연어 처리가 요새 뭐 챗gpt 말할 것도 없죠 여러분 차체 지피티 하루에 몇 번 쓰세요? 저는 거의 하루에 한 다섯 번을 쓰는 것 같아요. 이렇게 우리의 모든 생활에 머신 러닝이 곳곳에 적용이 안 되는 곳이 없는 세상입니다. 자 그래 가지고 일상생활 곳곳에 이런 머신러닝 알고리즘이 사용이 돼 가지고 지금 우리가 살고 있는 이 2024년에 현 시대에 굉장히 가장 뜨거운 이슈로 떠오르고 있습니다. 그래서 과장하지 않고 말하자면 이제 앞으로 넥스트 테니얼스 앞으로 한 10년 동안의 시대는 이 머신 러닝 인공지능의 시대가 될 것이고 심지어는 어떤 사람들은 이 인공지능 모델이 사람을 굉장히 많은 부분에서 대체할 거라고 생각되고 있습니다. 그래서 요새 현 시대를 살고 있는 우리들에게 가장 중요한 기술이 아닌가 생각해 봅니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 3,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1050,
      "char_count": 1928
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c004_b4ae5d",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 자 그래 가지고 일상생활 곳곳에 이런 머신러닝 알고리즘이 사용이 돼 가지고 지금 우리가 살고 있는 이 2024년에 현 시대에 굉장히 가장 뜨거운 이슈로 떠오르고 있습니다. 그래서 과장하지 않고 말하자면 이제 앞으로 넥스트 테니얼스 앞으로 한 10년 동안의 시대는 이 머신 러닝 인공지능의 시대가 될 것이고 심지어는 어떤 사람들은 이 인공지능 모델이 사람을 굉장히 많은 부분에서 대체할 거라고 생각되고 있습니다. 그래서 요새 현 시대를 살고 있는 우리들에게 가장 중요한 기술이 아닌가 생각해 봅니다. 자 그러면은 이 머신 러닝을 갖다가 우리가 아까 개념을 배웠죠. 머신 러닝은 기본적으로 데이터를 이용해 가지고 데이터를 입력 값으로 받아서 컴퓨터가 그 데이터 에 있는 어떤 내재된 패턴을 자동으로 이렇게 데이터를 통해서 학습시키는 그런 방법론이라고 그랬어요. 그러면은 여기서 질문이 있어요. 어떻게 학습을 할 거냐 그래 머신 러닝은 데이터를 통해서 패턴을 학습시키는 거다 그러면은 어떻게 학습을 할 거냐라는 질문이 있습니다. 기본적으로 이 학습의 종류는요 머신러닝에서 쓰이는 학습의 종류는 세 가지가 있어요. 첫 번째 지도 학습이라고 써 있는데 이게 영어 단어를 그대로 번역한 거예요. 수퍼바이지드 러닝이라는 학습이 있습니다. 그리고 비지도 학습 언슈퍼바이즈드 러닝이라는 학습이 있고 마지막으로 강화 학습 윈 포스먼트 러닝이라는 학습이 있습니다. 그래서 간략하게 개념을 보면요. 수퍼바이즈드 러닝은 뭐냐면은 처음에 우리가 데이터를 통해서 배울 때 그 데이터가 다 레이블이 되어 있습니다. 그래서 인풋 데이터가 아웃풋 데이터랑 이렇게 다 매칭이 되어 있는 상태에서 우리는 인풋을 넣었을 때 아웃풋이 나오는 어떤 알고리즘 머신러닝 알고리즘을 학습하는 식으로 이루어져 있는 게 이 슈퍼바이지드 러닝입니다. 그래서 우리가 소위 딥러닝이라고 얘기하는 많은 방법론들이 실은 이 지도 학습에 속하는 어떤 방법론들입니다. 그래서 뒤에서 좀 더 이야기할 거예요. 그리고 비지도 학습 언슈퍼바이저 러닝은요 지도 학습이랑 비슷한데 한 가지 다른 점이 있습니다. 지도 학습은 처음에 데이터를 시작할 때 인풋과 아웃풋이 다 레이블 되어 있잖아요. 요 언스퍼바이즈 러닝 비지도 학습 같은 경우에는요 인풋만 있어요. 그래서 출력값이 없어요. 원하는 출력값이 없고 학습 데이터 인풋 학습 데이터만 주어져서 우리가 그 학습 데이터를 통해서 어떤 레이블이 없는 패턴을 학습하는 겁니다. 이것도 뒤 슬라이드에서 좀 더 이야기할 거예요. 그리고 이 지도 학습이랑 비지도 학습과는 약간 결이 다른 학습 방법이 강화 학습 린 폴스먼트 러닝입니다. 요 린 폴스먼트 러닝은요 기본적으로 어떤 데이터 셋을 통해서 학습을 한다기보다 어 어떤 에이전트를 만들어요 뭐 예를 들어 로봇 같은 게 되겠죠 어 어떤 에이전트를 만들어서 이 에이전트를 특정 환경에 던져 놓습니다. 그리고 그 에이전트가 계속 그 환경에서 그 환경과 인터랙션하면서 스스로 어떤 기술을 자동으로 습득하게 하는 방식입니다. 이것도 뒤에서 좀 더 배우겠습니다. 자 먼저 지도 학습이랑 비지도 학습이랑 얘기를 했는데 그게 슈퍼바이스 러닝이랑 언슈퍼바이스 러닝이에요. 그거의 차이를 다시 한번 설명드릴게요. 먼저 슈퍼바이스 러닝은요 예를 들어 뭐 클래시피케이션 알고리즘 같은 거 얘기할 때 뭐 이미지 클래시피케이션 같은 거 얘기할 때 기본적으로 우리가 가지고 있어야 되는 데이터는 굉장히 많은 이미지랑 그 이미지가 어떤 클래스인지를 레이블 되어 있는 그 레이블 데이터입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 4,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 967,
      "char_count": 1764
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c005_59b7d1",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 이것도 뒤에서 좀 더 배우겠습니다. 자 먼저 지도 학습이랑 비지도 학습이랑 얘기를 했는데 그게 슈퍼바이스 러닝이랑 언슈퍼바이스 러닝이에요. 그거의 차이를 다시 한번 설명드릴게요. 먼저 슈퍼바이스 러닝은요 예를 들어 뭐 클래시피케이션 알고리즘 같은 거 얘기할 때 뭐 이미지 클래시피케이션 같은 거 얘기할 때 기본적으로 우리가 가지고 있어야 되는 데이터는 굉장히 많은 이미지랑 그 이미지가 어떤 클래스인지를 레이블 되어 있는 그 레이블 데이터입니다. 즉 고양이 이미지는 고양이라고 레이블 되어 있어야 되고 뭐 말 이미지는 말이라고 레이블 되어 있어야 되고 토끼는 토끼라고 이렇게 레이블 되어 있어야 돼요. 이렇게 여기 그림에서도 보여 있듯이 그 인풋이랑 그 아웃풋이 다 이렇게 레이블이 돼 있어야 돼요. 그리고 우리가 이 데이터를 통해서 배우는 거는 인풋이 들어왔을 때 아웃풋이 나오게 즉 요 덕 그 올이라는 이미지가 들어갔을 때 이미지가 아웃 인풋이죠. 덕이라는 아웃풋이 출력되게 할 수 있는 어떤 머신 러닝 펑션을 학습하는 게 이 슈퍼바이스 러닝입니다. 그래서 기본적으로 이 슈퍼바이스 러닝을 이용해서 어떤 예측 모델 프리딕티브 모델을 만들 수가 있어요. 이 데이터를 통해서 이 이미지가 들어갔을 때 궁극적으로는 이 레이블 된 아웃풋이 나올 수 있도록 이 레이블 된 데이터로부터 이 프리젝티브 모델을 갖다가 학습을 하는 게 슈퍼바이스 러닝입니다. 그렇죠 그리고 언 슈퍼바이스 러닝은 슈퍼바이스 러닝이랑의 차이가 아웃풋이 없다고 그랬어요. 아웃풋이 레이블이 되어 있지 않아요 그러니까 기본적으로 요 레이블 된 데이터에서 이 아웃풋 요 레이블만 쫙 빼면은 이 그림만 남잖아요. 요 인풋 데이터만 이렇게 가지고 우리가 처리를 하는 거예요. 그럼 아웃풋 데이터가 없는데 어떻게 패턴을 학습시키냐 여러 가지 방법을 이용해서 요 인풋 간에 시미널리티 같은 걸 이용해서 이렇게 클러스터를 할 수도 있고 여러 가지 다른 방법론이 있어요. 하지만 기본적으로 어떤 아웃풋에 의해서 슈퍼바이스 되지 않고 그 인풋에 있는 내재된 본연의 성질을 이용해 가지고 패턴을 학습시키는 거를 요 언슈퍼바이스 러닝이라고 해요. 비지도 학습 그렇죠 그래서 뭐 슈퍼바이스 러닝의 한 가지 예가 요 그 리그레션 프러블럼이에요. 회기 문제라고 하죠. 리그레션 회기입니다. 그리고 또 클래시피케이션 문제도 역시 이 슈퍼바이스 러닝에 해당합니다. 그래서 기본적으로 여기에 제가 아까 앞에서 설명했던 거를 좀 더 수학적으로 풀어서 설명한 슬라이드가 있는데요. 기본적으로 이 데이터 스 즉 인풋이 되겠죠. 인풋인 스랑 레이블 아웃풋인 와가 이렇게 주어졌을 때 굉장히 많은 데이터가 있을 거 아니에요 즉 스1 와1 스2 와 2 스앤 와엔까지 이렇게 수많은 요 레이블드 된 데이터가 인풋과 아웃풋에 어떤 페어로 주어졌을 때 우리가 원하는 건요. 주어진 스가 주어졌을 때 인풋인 x가 주어졌을 때 어떤 함수 FX를 통해서 y를 예측하도록 하고 싶어요. 그래서 예를 들어 뭐 x1이 들어가면은 y1이 나오게 그리고 x2가 들어가면은 y2가 나오게 이렇게 하는 모든 테스크가 슈퍼바이스 러닝입니다. 그래서 여기에 그 이그샘플로 리그레션이랑 클래시피케이션이 나와 있죠. 그래서 만약에 이 y가 하나의 숫자예요. 실수 값으로 주어지는 어떤 숫자면은 리그레션 프러블럼이라고 그러고 y가 예를 들어서 어떤 클래스예요? 뭐 개인지 고양이인지 이렇게 디스크리트하게 딱딱 떨어지는 어떤 클래스예요 그러면 이거는 클래시피케이션 프로블럼이라고 합니다. 그래서 주로 이렇게 슈퍼바이스 러닝은 우리가 기본적으로 인풋이 아웃풋으로 이렇게 많이 레이블 되어 있는 데이터 셋이 있을 때 즉 x1 y1 x2 y2 이렇게 페어가 되어 있는 데이터셋이 많을 때 굉장히 효율적으로 패턴을 학습시킬 수 있는 머신 러닝 방법입니다. 그리고 언슈퍼바이즈 러닝은 아까 말씀드렸듯이 y가 없어요. 레이블이 없어요. 출력값은 없고 인풋 x만 주어진 학습 방법입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 5,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1075,
      "char_count": 1977
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c006_5a988f",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 그래서 주로 이렇게 슈퍼바이스 러닝은 우리가 기본적으로 인풋이 아웃풋으로 이렇게 많이 레이블 되어 있는 데이터 셋이 있을 때 즉 x1 y1 x2 y2 이렇게 페어가 되어 있는 데이터셋이 많을 때 굉장히 효율적으로 패턴을 학습시킬 수 있는 머신 러닝 방법입니다. 그리고 언슈퍼바이즈 러닝은 아까 말씀드렸듯이 y가 없어요. 레이블이 없어요. 출력값은 없고 인풋 x만 주어진 학습 방법입니다. 그래서 이렇게 아까 언스퍼바이즈 러닝은 슈퍼바이스 러닝에 비해서 y가 없죠. 즉 엑스원 y1 이렇게 폐허가 되어 있지 않고 스1만 있고 스2만 있고 이렇게 xn까지 인풋만 이렇게 주어졌을 때 이 인풋에 어떤 내재되어 있는 그런 펀디멘탈한 어떤 패턴을 갖다가 학습시켜 가지고 어 우리가 어떤 패턴을 학습시키는 그런 알고리즘이다. 그래서 하나의 되게 좋은 예가 클러스터링 알고리즘이에요. 예를 들어 뭐 이 xn 1부터 n까지가 이렇게 표현된다고 했을 때 우리가 가까이 있는 거를 이렇게 군집화하는 거죠. 그루핑하는 거죠. 그래서 가까이 있는 것끼리 같은 색깔로 이렇게 표현을 한 겁니다. 그렇게 클러스터링 하는데 우리가 실제로 어떤 레이블을 사용하지 않았잖아요. 스라는 벡터만 이용했습니다. 그래서 와라는 레이블이 없어도 스의 성질만을 이용해서 패턴을 학습하는 게 언슈퍼바이즈 러닝이더라. 그래서 실제로 이 언스퍼바이스 러닝은 딥러닝 시대에 그렇게 많이 쓰이지는 않지만 쓰이는 영역도 있어요. 하나의 이그 샘플로 예를 들어서 뭐 바이올로지에서 바이오 인포매틱스에서 유전체학 응용 분야에서 유전체를 갖다가 클러스터링 할 때 레이블이 없잖아요. 이 유전체는 어떤 유전체다라는 어떤 레이블이 없습니다. 따라서 그 유전체의 어떤 그 시퀀스의 나열의 패턴을 학습시켜 가지고 그 나열에 대한 정보를 비슷한 것끼리 군집화해 가지고 이렇게 클러스터링을 한 논문도 있었습니다. 자 그리고 세 번째 언슈퍼바이스 러닝 슈퍼바이스 러닝에서 대해서 배웠는데 그런 그 슈퍼바이스 언스퍼즈 러닝이랑 결이 다른 게 요 강화 학습 윈 포스먼트 러닝입니다. 이게 굉장히 재미있는 분야예요. 기본적으로 그 슈퍼바이즈랑 언슈퍼바이즈 러닝은 데이터셋이 있다는 가정 하에 그 데이터셋으로부터 패턴을 학습했단 말입니다. 그런데 이 리인포스먼트 러닝은 좀 달라요. 우리가 머신 러닝 모델을 갖다가 이미 있다고 가정을 하고 그걸 에이전트라고 부릅니다. 그 에이전트라는 머신러닝 모델이 있다는 가정을 가지고 그 머신 러닝 에이전트를요. 우리가 풀려는 어떤 문제가 있는 환경에다가 던져 넣습니다. 그리고 그 에이전트가 그 환경 내에서 어떤 테스크를 무수히 반복해서 수행하게 해요. 그렇게 함으로써 그 테스크로부터 스스로 그 에이전트가 원하는 태스크에 대한 기술을 습득할 수 있게 학습시키는 것을 강화 학습이라고 그럽니다. 그래서 약간 좀 무슨 말인지 잘 모르시겠죠? 그래서 이 예를 들어서 한번 설명드릴게요. 예를 들어 뭐 로봇 팔을 갖다가 우리가 학습시킨다고 할게요. 로봇 팔로 어떤 물체를 집어 가지고 올리는 테스크를 진행하도록 하겠습니다. 그럼 이 로봇 자체 로봇이라는 자체는 모델입니다. 그래서 이 로봇을 갖다가 에이전트라고 생각을 할게요. 그 로봇을 갖다가 물건을 집는 환경에다 던져놔요. 근데 이 로봇이 원하는 거는요 물건을 딱 집어 가지고 올리는 거죠. 이 테스크를 하는 게 이 로봇의 목표예요. 그러면은 그 기술을 어떻게 습득하느냐 수만 번 반복을 해가지고 물건을 이렇게 잡으려고 막 그 로봇의 관절을 움직이고 그래서 물건 떨어뜨려 보고 자 그러면은 이거는 잘못된 케이스인 걸 알겠죠. 그리고 집어서 올리는 거를 수만 번을 반복을 합니다. 그러면 어느 순간 이 로봇이 물건을 딱 잡아 가지고 올렸을 때 오 이거는 성공했어 그러면은 리워드를 딱 받는 겁니다. 그래서 이렇게 문제를 디자인을 해주면은요. 이 로봇이 수만 번의 그 트라이얼 앤 에러를 반복함으로써 그 원하는 테스크를 했을 때 리워드를 받는 것을 얘 스스로 학습시키게 만드는 겁니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 6,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1084,
      "char_count": 1992
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c007_f94d25",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 그러면 어느 순간 이 로봇이 물건을 딱 잡아 가지고 올렸을 때 오 이거는 성공했어 그러면은 리워드를 딱 받는 겁니다. 그래서 이렇게 문제를 디자인을 해주면은요. 이 로봇이 수만 번의 그 트라이얼 앤 에러를 반복함으로써 그 원하는 테스크를 했을 때 리워드를 받는 것을 얘 스스로 학습시키게 만드는 겁니다. 그래서 어떻게 보면은 사람이 그러니까 인간이 어떤 기술을 습득하는 거랑 가장 비슷한 방식으로 기술을 습득하는 게 이 강화 학습 방법이라고 생각하시면 돼요. 그래서 여기 이렇게 정의가 나와 있는데 조금 헷갈리실 수 있습니다. 보상이 있는 상태에 액션의 시퀀스가 주어졌을 때 즉 이 액션이라는 거는 아까 제가 예를 들어서 설명한 거에서 이 로봇 팔이 물건을 잡는 어떤 행동이 액션이 되겠죠. 그리고 그다음에 보상은 이 로봇 팔이 물건을 잘 잡아서 원하는 테스크를 했을 때 이 로봇에게 주는 보상 즉 리워드입니다. 이렇게 보상이 있는 상태와 액션의 시퀀스가 주어졌을 때 이 보상이 있는 일련의 상태와 작업이 주어지면은 이 폴리스를 출력하는 거예요. 즉 폴리스라는 거는요. 이 로봇 팔이 물건을 주워 가지고 원하는 테스크를 하기 위한 기술입니다. 그래서 기본적으로 이 폴리스란 주어진 상태에서 이 로봇의 어떤 주어진 상태에서 로봇의 어떤 관절의 어떤 3차원적인 오리엔테이션 이런 게 상태가 되겠죠. 이 로봇의 상태에서 수행해야 될 작업 즉 어떤 물체를 집어 가지고 올리는 그런 작업이죠. 그런 작업을 알려주는 어떤 그 상태부터의 작업 형식의 매핑이 됩니다. 그래서 무슨 말이냐면요. 요 로봇의 어떤 상태가 있어요? 로봇이 지금 이렇게 오리엔티이 되어 있고 이러한 스테이트로 있어요. 이런 상태에서 공을 집으려면 어떻게 관절을 움직여서 액션을 해야 되는지 그거를 예측하게 하는 것을 강화 학습이라고 그래요. 즉 어떤 특정 상태에서 작업을 할 수 있는 그 작업을 예측하는 형태의 매핑되어 있는 펑션을 러닝하는 게 강화 학습입니다. 그래서 뭐 예를 보여드리면 훨씬 더 이해하기가 편하실 것 같아요. 그래서 강화 학습의 예시를 보여드릴게요. 이 세 가지가 있는데 먼저 게임 플레이가 가장 이해하기가 쉽습니다. 여러분 알파고 다 아실 거예요. 딥 마인드에서 만드는 바둑 하는 로봇이죠. 그래서 기본적으로 알파고가 이 강화학습 r 포스먼트 러닝을 이용해서 학습이 됐어요. 그래서 기본적으로 이 알파고에서의 에이전트는 누굴까요? 바둑을 두는 로봇이죠 그 바둑을 두는 어 그 주체가 되는 어떤 모델이 알파고의 그 에이전트예요. 이 에이전트가 계속해서 바둑 그 게임을 하게 돼요. 그리고 그 에이전트가 바둑 게임을 이겼을 때 보상을 받게 됩니다. 그래서 이 에이전트가 실제로 사람 바둑 플레이어랑 계속 계속 이렇게 플레이를 하게 돼 가지고 어떻게 하면 바둑이 이기는지에 대한 어떤 전략을 학습시키게 한 거죠. 그렇죠 그리고 또 오픈 AI의 도타 2라는 그런 모델이 있는데 이것도 역시 이 r 퍼스먼트 러닝을 이용해 가지고 굉장히 복잡한 전략 게임인 도타 2를 학습하게 되었습니다. 그래서 이 오픈 AI가 실은 우리는 챗gpt로 많이 알고 있는데 실제로는 이 강화 학습 모델을 많이 연구하던 회사였어요. 그래서 뭐 알파고는 딥 마인드에서 나왔지만 오픈ai에서 개발한 오픈ai g이라는 라이브러리가 있습니다. 그래서 그 라이브러리가 기본적으로 요 강화 학습을 잘 학습시키도록 만들어져 있는 이 라이브러리입니다. 그리고 제가 아까 말씀드렸던 것처럼 이 로봇 팔을 이용해서 어떤 물건을 잡는 것처럼 이런 로봇 엔지니어링 로보틱스 같은 분야에서도 그 로봇의 제어를 위해서 강화 학습이 많이 사용이 됩니다. 그리고 가장 익사이팅하다고 생각하는 게 이 자율 주행입니다. 실제로 이 자율 주행은 실제로 요새는 프로덕트화돼서 뭐 샌프란시스코 시티 내에서는 웨이모라는 회사가 자율 주행 차를 이용해 가지고 실제로 이렇게 사람들도 태워 가지고 택시 서비스를 운영을 한다고 해요. 그래서 이 자율 주행도 마찬가지로 강화 학습을 이용합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 7,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1082,
      "char_count": 1995
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c008_92afb3",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 그리고 제가 아까 말씀드렸던 것처럼 이 로봇 팔을 이용해서 어떤 물건을 잡는 것처럼 이런 로봇 엔지니어링 로보틱스 같은 분야에서도 그 로봇의 제어를 위해서 강화 학습이 많이 사용이 됩니다. 그리고 가장 익사이팅하다고 생각하는 게 이 자율 주행입니다. 실제로 이 자율 주행은 실제로 요새는 프로덕트화돼서 뭐 샌프란시스코 시티 내에서는 웨이모라는 회사가 자율 주행 차를 이용해 가지고 실제로 이렇게 사람들도 태워 가지고 택시 서비스를 운영을 한다고 해요. 그래서 이 자율 주행도 마찬가지로 강화 학습을 이용합니다. 자율 주행은 강화 학습을 통해서 이 자율 주행차가 다양한 도로 상황에서 최적의 운전 결정을 내리도록 학습을 시킵니다. 이거 같은 경우는 이제 에이전트가 이 운전을 하는 어떤 시스템이 되겠죠 그리고 이 에이전트가 어떤 스테이트 이렇게 도로의 어떤 상황을 카메라로 보고 이 상황에서 어떻게 핸들을 꺾고 어떻게 엑셀을 밟을지에 대한 액션을 수행하게 되는 강화 학습 모델을 학습하게 됩니다. 그래서 실제로 제 연구 분야가 강화 학습과 많은 관련이 있습니다. 그래서 제가 요새 중점적으로 보고 있는 어떤 모델의 한 형태가 요 강화 학습입니다. 자 그래서 여기까지 우리가 이제 머신 러닝의 개념과 그 슈퍼바이스 러닝 언슈퍼바이스 러닝 강화 학습 리인포스먼트 러닝의 개념에 대해서 배워봤습니다. 그러면은 이렇게 여러 가지 모델의 그 종류들을 배웠는데 이런 머신러닝을 이용해서 모델을 만들었을 때 어떻게 어떤 회사나 연구 프로덕트나 어떤 실제 생활에서 그 머신 러닝 모델을 그 프로덕트에 탑재해 가지고 관리하고 운영할 수 있는지 이 머신 러닝 라이프 사이클에 대해서 이제 배워보도록 하겠습니다. 머신 러닝 라이프 사이클이란 뭐냐 그 여기 이렇게 써 있죠 머신 러닝 라이프 사이클이란 머신 러닝 모델을 개발하고 배포하고 유지 보수하는 일련의 단계들을 정의하는 프로세스다 이렇게 쓰여 있는데 기본적으로 무슨 말이냐면요 우리가 뭐 나중에 회사를 가거나 아니면은 학교에서 연구를 하거나 할 때 특정한 문제를 풀기 위해서 머신 러닝 모델을 쓰게 될 거예요. 그러면은 그 문제를 풀기 위해서 어떤 머신 러닝 모델을 어떻게 적용을 해가지고 개발을 할 건지 그리고 개발된 모델을 어떻게 프로덕트화해서 어떻게 제품화해서 배포를 하고 유저들이 사람들이 사용하게 하면서 계속해서 업데이트하고 유지하고 보수를 하는지 이 일련의 모든 사이클을 머신 러닝 라이프 사이클이라고 합니다. 그래서 기본적으로 그 머신 러닝 라이프 사이클이란 머신 러닝 모델을 문제를 풀기 위해서 만들어 가지고 어떻게 프로덕트에 탑재하고 사람들이 쓰게 하고 보수까지 하는지 그 모든 프로세스를 다 머신 러닝과 관련된 모든 프로세스를 어 머신 러닝 라이프 사이클이라고 정의한다고 생각하시면 됩니다. 그래서 일반적으로 머신 러닝 프로덕트라고 하면 그러니까 AI나 머신 러닝이 탑재된 어떤 제품이라고 하면요 그 제품을 만들기 위한 모든 프로세스가 집합적으로 이루어져서 만든 프로덕트인데요. 그 프로세스라는 게 굉장히 방대해요. 데이터 처리나 학습 배포만으로 이루어져 있다고 생각을 하지만 그게 아니고 그 이상의 것들을 굉장히 많은 프로세스를 포함합니다. 그래서 그걸 잠깐 볼게요. 자 그래서 먼저 이게 이제 머신 러닝 라이프 사이클을 갖다가 개괄적으로 보여주는 어떤 그림이라고 해가지고 이제 여기다 넣어놨는데 굉장히 머신 러닝 라이프 사이클을 잘 설명하는 그림이라고 생각을 합니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 8,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 952,
      "char_count": 1729
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c009_1d2939",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 그래서 그걸 잠깐 볼게요. 자 그래서 먼저 이게 이제 머신 러닝 라이프 사이클을 갖다가 개괄적으로 보여주는 어떤 그림이라고 해가지고 이제 여기다 넣어놨는데 굉장히 머신 러닝 라이프 사이클을 잘 설명하는 그림이라고 생각을 합니다. 자 여기 이렇게 전구 그림이 있죠 우리가 딱 아이디어를 냈어요. 어떤 태스크가 있고 그 테스크를 머신러닝 모델을 이용해 가지고 해결하고자 하는 아이디어를 냈어요. 그러면은 보통 이거를 갖다가 실제로 이루게 하는데 이런 동그란 프로세스를 큰 동그라미 프로세스를 겪게 돼요. 먼저 데이터를 모아야 되겠죠. 우리가 데이터를 통해서 패턴을 학습하는 게 머신러닝이니까 먼저 데이터를 갖다가 콜렉트하고 그거를 프로세스 해야 돼요. 그런 다음에 그 데이터의 패턴을 학습할 수 있는 모델을 갖다가 만들어야 되겠죠. 그런 다음에 그 모델을 갖다가 테스트하고 이밸류에이트 해야 돼요. 실험하고 그리고 이 모델이 제대로 동작을 하는지 이밸류에이션을 해야 돼요. 그다음에 이게 제대로 동작을 한다 이렇게 결론이 나면 그게 끝이 아니고 요 머신 러닝 모델을 가져다가 우리가 원하는 어떤 큰 소프트웨어 시스템에다가 디플로이를 해야 되겠죠. 그렇게 해가지고 디플로이가 되고 프로덕트가 배포됐다 그게 끝이 아니에요. 이 프로덕트를 사람들이 잘 쓰는지 아니면 이 프로덕트에 문제가있는 건 아닌지 아니면 또 새로운 모델이 나와 가지고 이 프로덕트를 업데이트해야 되는 건 아닌지 이렇게 계속 유지 보수하는 굉장히 긴 프로세스가 필요합니다. 그게 바로 모니터 엔 메인 테인 프로세스죠. 그래 가지고 이 큰 동그라미 프로세스를 따르는데요. 여기 보시면 작은 동그라미 2개가 있죠. 데이터에서 테스팅 앤 이밸류에이션까지 가기 위해서 굉장히 모델에 관련된 많은 프로세스가 있습니다. 먼저 모델이 굉장히 빠르게 업데이트가 됩니다. 요새 머신 러닝의 시대이기 때문에 새롭고 좋은 모델들이 거의 일주일 단위로 성능이 향상되고 많이 퍼블리케이션이 나오는데 이거를 계속 힙합 하면서 모델을 갖다가 탐색하는 이 모델 익스플로레이션 작업이 필요합니다. 그리고 데이터도 계속 업데이트 돼요. 예를 들어서 뭐 유튜브 추천 알고리즘 같은 걸 보면은 하루에도 몇 빌리언 계의 유저들이 계속 유튜브를 보니까 레코멘데이션 데이터가 업데이트가 되겠죠. 그러니까 거의 실시간에 가깝게 모델이 리파인 돼야 됩니다. 모델이 계속 실시간에 어 맞게 트레인 되고 업데이트가 돼야 됩니다. 그래서 이 모델 익스플로레이션이랑 모델 리파인먼트 프로세스가 이 데이터에서 테스트로 가는 중간 프로세스의 굉장히 크게 차지를 하게 됩니다. 그래서 실제적으로 우리가 이제 빅텍 컴펜이라고 했을 때 뭐 구글이나 뭐 뭐 페이스북 메타나 뭐 NVIDIA 이런 거에서 프로덕트를 런칭할 때 이 큰 동그라미 사이클을 따르게 돼요. 자 그러면은 이 사이클에 맞게 적재적소에 전문가를 배치해 가지고 일을 시켜야 되겠죠. 그래서 우리가 맨 처음에 데이터 컬렉션이랑 데이터 프리 프로세싱에 해당되는 일을 하시는 분들이 이 데이터 엔지니어들입니다. 그래서 어 레이블 된 데이터를 보고서 이 데이터를 머신러닝 모델을 개발하기에 적합한 형태로 우리가 프리 프로세싱하고 클리닝 하는 그런 분들이 이 데이터 엔지니어고 이 데이터 엔지니어가 어 레이블 되고 클린된 데이터를 이렇게 주면은 뭐 AI 사이언티스트나 데이터 사이언티스트나 ML 사이언티스트 사이언티스트 직군에 되시는 분들이 연구에 관련된 일을 합니다. 그러니까 연구라고 하면 우리가 모델을 실제로 개발하는 거죠. 그래서 우리가 코드를 짜고 머신러닝 모델을 만들고 모델을 트레이닝 해 가지고 트레인 된 그러니까 제대로 동작하는 모델을 만드는 일을 하기까지 노력해 주시는 분들이 이 데이터 머신러닝 AI 사이언티스트입니다. 그래서 사이언티스트라고 붙인 이 직업군들은 기본적으로 모델을 갖다가 만드는 그러니까 새로운 모델들을 배워가지고 인플리멘트하고 또 모델을 향상시키기 위해서 모델에 조금씩 변화를 주는 그런 일을 하시는 분들이 이 사이언티스트 분들입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 9,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1107,
      "char_count": 2011
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c010_965aaf",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 그러니까 연구라고 하면 우리가 모델을 실제로 개발하는 거죠. 그래서 우리가 코드를 짜고 머신러닝 모델을 만들고 모델을 트레이닝 해 가지고 트레인 된 그러니까 제대로 동작하는 모델을 만드는 일을 하기까지 노력해 주시는 분들이 이 데이터 머신러닝 AI 사이언티스트입니다. 그래서 사이언티스트라고 붙인 이 직업군들은 기본적으로 모델을 갖다가 만드는 그러니까 새로운 모델들을 배워가지고 인플리멘트하고 또 모델을 향상시키기 위해서 모델에 조금씩 변화를 주는 그런 일을 하시는 분들이 이 사이언티스트 분들입니다. 그래서 기본적으로 우리가 뒤에서 배우겠지만 이 모델을 만들기 위한 언어들이 있어요. 그러니까 파이썬 기반된 언어들인데 파이토치나 텐서플로우 같은 게 있습니다. 그런 것들을 잘 다루고 그래서 모델을 실제로 만질 수 있는 사람들이 이 사이언티스트라는 직군입니다. 그래서 이제 모델이 만들어졌다 그러면 끝이 아니에요. 그다음에 굉장히 큰 그 유지 보수 배포 프로세스들이 있습니다. 그래서 이 모델을 갖다가 기존 있는 웹이나 앱의 코드에 어 이렇게 인플리먼트 하는 거죠. 그래서 실제로 사람들한테 배포하고 프로덕트 화로 만드는 그런 일을 하시는 분들이 블라블라블라 엔지니어라고 붙은 직군입니다. ML 엔지니어도 될 수 있고 데이터 엔지니어가 될 수도 있고 AI 엔지니어가 될 수도 있죠 기본적으로 개발자분들입니다. 그래서 이분들은 훨씬 더 이 프로덕트 코딩에 능하시고 뭐 여러 가지 언어들을 하시고 파이썬 뿐만 아니고 뭐 자바나 c 플러스 플러스나 c 같은 거를 쓰시면서 실제로 프로덕트에 인플리멘트 할 수 있는 어떤 프로그래밍 엔지니어링을 하시는 분들이 이 엔지니어들입니다. 그래서 기본적으로 보이시죠 여러분들이 이 부트 캠프를 끝나시고 이제 실제 현업에 뛰어드실 텐데 뭐 많은 직군들이 있어요. 근데 데이터 엔지니어라고 붙은 게 이 데이터 프리 프로세싱 하시고 분석하시는 분들 어떤 사이언티스트라고 이루어진 직군들이 이 파이토치나 텐서플로우 모델들을 갖다가 만드는 분들 그리고 엔지니어 분들 그러니까 ML 엔지니어나 개발자라는 직군은 이 모델을 갖다가 이 시스템에 디플로이 하는 분들이라고 생각하시면 됩니다. 자 근데 이 머신 러닝 라이프 사이클이 사실 그렇게 쉬운 테스크가 아니에요. 굉장히 굉장히 어렵고 변수들이 많고 계속 우리가 업데이트해야 되는 부분이 많은 테스크입니다. 왜냐 어 여러 가지 이유들이 있는데 각각의 그 데이터 모델 코드의 파이프라인에서 보면요 데이터 사이드에서는 굉장히 문제가 많아요. 왜냐면은 그 데이터라는 게 사실 실제로 우리가 데이터를 까보면은 굉장히 노이지하고 더러운 데이터들이 많아요. 그 사실 웹 베이스 데이터가 수만 가지 오만 가지가 있고 그걸 우리가 클라우드 소싱에서 레이블링 한다고 할 때 사람들마다 그 레이블링하는 기준이 다르고 방식이 다르기 때문에 데이터를 그냥 까보면은 굉장히 더럽게 그러니까 어떻게 소위 말하면은 클린되지 않은 상태의 로우 데이터인 경우가 많아요. 그래서 이런 데이터를 가지고 어떤 기준 스키마를 가지고 잘 분석을 하고 클린 하는 과정이 굉장히 어떻게 보면 노가다스러운 어려운 테스크입니다. 그래서 어 고려할 점들이라고 하면은 이 스키마가 정확하게 정형화되어 있어 가지고 우리가 원하는 딱 원하는 정형화된 상태의 데이터 포맷을 유지하게 하는 게 어렵고 그리고 시간 경과에 대한 샘플링이라고 그러는데요. 이게 그 데이터가 랜덤성을 유지하기 위해서 되게 랜덤하게 시간에 따라서 디펜던시가 없게 샘플링을 해야 되고 또 볼륨 문제도 있습니다. 얼마나 많이 수집해야 되나 이런 문제도 있고 이런 세세한 그런 기준이나 어떤 어 팩터들이 데이터 엔지니어링을 어렵게 합니다. 그리고 두 번째로 모델은 머신러닝 알고리즘을 실제로 개발하는 과정에서 이 알고리즘의 그 업데이트 속도가 거의 아까 말씀드렸지만 그 매주 새로운 모델이 업데이트가 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 10,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1067,
      "char_count": 1935
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c011_0350da",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 얼마나 많이 수집해야 되나 이런 문제도 있고 이런 세세한 그런 기준이나 어떤 어 팩터들이 데이터 엔지니어링을 어렵게 합니다. 그리고 두 번째로 모델은 머신러닝 알고리즘을 실제로 개발하는 과정에서 이 알고리즘의 그 업데이트 속도가 거의 아까 말씀드렸지만 그 매주 새로운 모델이 업데이트가 됩니다. 즉 스테일 오브 디 아트 모델의 1등이 되는 모델이 계속 매주마다 업데이트가 되는 거예요. 저번 주에 가장 좋았던 모델이 이번 주에는 뭐 예를 들어 3등이 될 수도 있어요. 이렇게 굉장히 많은 알고리즘을 가지고 우리 테스크에 리그로스하게 잘 동작하는 어떤 모델을 찾는 게 일이고 그리고 그 많은 데이터를 통해서 많은 트레이닝을 거쳐야 되고 또 많은 실험을 해야 되는 어려움이 있습니다. 그리고 마지막으로 그 배포 개발자 분들이 고민하시는 부분은요 이 배포 상황에서 그 실제로 사람들이 이 코드를 갖다가 써야 되잖아요 이 프로덕트를 갖다가 써야 되면은 그 유저들의 요구 사항을 반영하지 않을 수가 없습니다. 그래서 이 개발자들이 사실은 그러니까 프론트엔드 엔지니어링이라고 하는데 그러니까 실제로 고객들이랑 가까울수록 많은 비즈니스 요구 사항 오류 수정이나 뭐 요청 사항들을 반영해야 됩니다. 그래서 이런 이유들 때문에 이 머신 러닝 라이프 사이클을 잘 돌아가게 하는 게 굉장히 큰 일이 됩니다. 자 그래서 이 머신 러닝 라이프 사이클을 이런 문제들을 잘 어우를 수 있는 구성 요소들을 잘 이렇게 우리가 파이프라인을 만드는 게 중요합니다. 아까 말씀드렸듯이 여러 가지 비즈니스적인 요구도 있을 것이고 데이터 상황에서 만드는 만들어지는 문제들도 있을 것이고 모델 상황에서 생기는 어떤 문제들도 있을 거잖아요. 그래서 이 문제들을 갖다가 효율적으로 잘 해결하기 위해서 이런 구성들을 따라서 사람들이 이 라이프 사이클을 따라서 이제 모델을 개발하고 배포하게 되는데요. 기본적으로 이렇게 계획하기 플래닝 데이터 프리퍼레이션 데이터 모델 엔지니어링 모델 이밸류에이션 모델 디플로이먼트 모니터링 앤 메인터넌스 6개의 단계를 거칩니다. 그래서 이 각각의 단계들을 설명드리도록 할게요. 자 먼저 계획하기 단계에서는요 예를 들어서 뭐 유튜브 추천 시스템이라는 거를 생각을 해볼게요. 이 유튜브 추천 시스템을 만들어서 우리가 뭘 할 건지 이 추천 시스템을 만들어서 비즈니스적으로 뭘 이룰 것인지 그래서 우리 회사의 수익을 몇 프로 향상시킬 것인지 이런 거를 잘 처음에 플레이닝 하는 게 이 계획 단계입니다. 그래서 여기 써 있는 것처럼 계획 단계에서는요 우리가 만들고자 하는 이 머신 러닝 애플리케이션의 어떤 범위나 성공 지표나 실현 가능성을 평가를 하는 작업을 포함을 합니다. 그래서 여러분들 회사에 가시면은 PM이라고 해서 프로덕트 매니저라는 직업군을 가진 분들이 있습니다. 그분들이 사실 비즈니스적인 마인드도 있고 엔지니어링 마인드도 가지고 있는 어떤 인터디스플리너리한 백그라운드를 가지고 있는 분들인데요. 그런 분들이 이런 거를 갖다가 리드해서 하시게 됩니다. 그래서 뭐 비즈니스나 머신 러닝을 사용해서 현재 있는 프로세스를 어떻게 개선을 할 것인지 그거에 대해서 많은 생각을 하게 됩니다. 그래서 비용이나 편익 분석과 여러 단계로 솔루션을 출시할 방법을 이행하고 우리가 머신러닝 모델을 만들었을 때 이게 실제로 얼마나 잘 작동하는지를 매트릭화해가지고 측정 가능한 지표로 정의를 해야 됩니다. 예를 들어서 우리가 이 머신 러닝을 만들 모델을 만들 때 정확도를 목표를 얼마로 하겠다 이런 것들이 다 계획 단계에서 정의가 돼야 되는 거죠. 그리고 비즈니스적으로는 아까 말씀드렸듯이 우리가 이 머신 러닝을 이용해서 이용하기 전보다 수익을 뭐 예를 들어 20%를 늘리겠다 뭐 이거를 머신러닝을 이용하면 기존의 프로세스에 비해서 효율성이 10%가 오를 것이다 이런 거를 꼴을 세웁니다. 목표를 세우고 그거를 갖다가 정확한 매트릭으로 평가 지표를 설정하는 게 이 계획 단계에 포함됩니다. 그래서 이 계획 단계가 마치면 이제 타당성 보고서를 작성을 하게 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 11,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1105,
      "char_count": 2013
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c012_04b89e",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 목표를 세우고 그거를 갖다가 정확한 매트릭으로 평가 지표를 설정하는 게 이 계획 단계에 포함됩니다. 그래서 이 계획 단계가 마치면 이제 타당성 보고서를 작성을 하게 됩니다. 자 그러면은 이제 데이터를 모아야 되겠죠. 예를 들어 뭐 아까 제가 말씀드린 것처럼 유튜브 추천 시스템 같은 경우에는 그 유튜브 추천 시스템의 트레이닝에 쓰일 어떤 추천 데이터를 갖다가 수집을 해야 되겠죠. 그래서 뭐 이 4개의 프로세스가 있는데 먼저 데이터를 수집하고 레이블링 해야 됩니다. 그래서 유튜브 같은 경우에는 클라우드 소싱을 해요. 뭐 여러 가지 클라우드 소싱하는 센터들이 있어 가지고 많은 사람들이 유튜브를 시청을 하고 그거에 대한 평가를 갖다가 레이블링 하는 테스크를 하게 됩니다. 그래서 이렇게 데이터 수집 및 레이블링을 거치면 이 레이블 된 데이터들이 있을 거 아니에요 그 레이블 된 데이터들이 사실 중구난방일 거예요. 그래서 그렇게 중구난방으로 되어 있는 레이블 된 데이터를 깔끔하게 학습 가능한 형태로 클리닝을 해야 되고 그래서 그 모델에 직접 트레이닝에 쓸 수 있는 어떤 그 데이터베이스 형태로 이렇게 처리 정리 처리를 하게 됩니다. 그리고 나서 마지막으로 모델 학습 및 프로덕트 구현 과정에서 편리하고 효율적으로 쓰일 수 있도록 이 데이터를 관리하는 과정까지 이렇게 수집 정리 처리 관리 과정을 통해서 이 데이터를 갖다가 준비를 하게 돼요. 자 그럼 이제 데이터가 준비되면 모델을 만들어야 되겠죠. 그래서 이 모델 엔지니어링 단계가 그 모델을 만드는 단계인데요. 이 단계에서는요 계획 단계의 모든 정보 우리가 계획할 때 사용했던 모든 정보를 사용해서 머신 러닝 모델을 구축하고 훈련을 시키게 됩니다. 그래서 먼저 모델을 만들려면은 논문을 보고 어떤 모델이 제일 좋은지 판별을 해 가지고 모델 아키텍처 모델의 구조를 갖다가 구축해야 되겠죠. 그래서 코딩을 하고 모델을 만들고 그 모델을 갖다가 평가할 수 있는 어떤 매트릭을 정의를 해야 됩니다. 뭐 이미지 클래시피케이션 테스크 같은 경우는 그는 F1 스코어 뭐 그런 정확도 같은 게 되겠죠. 그래서 이제 학습이 끝나면 이제 모델을 학습시키고 학습이 끝나면 테스트 데이터로 검증을 하게 되고 그다음에 이 과정이 끝나면 이 과정을 다 할 수 있는 코드를 예쁘게 깨끗하게 정리를 해 가지고 어 그렇게 업데이트를 해야 되겠죠. 그래서 실험 메타데이트 기능 코드 변경이 머신러닝 파이프라인을 요 1 2 3 4를 다 할 수 있는 파이프라인을 잘 정리를 해가지고 이렇게 모델을 업데이트를 해야 됩니다. 그래서 여러분들이 사실 연구 경험이 있다면요 기타 코드를 많이 봤을 텐데요. 기타 코드 중에서 리듬이도 깔끔하게 쓰여지고 이런 것들이 있죠. 그래서 그런 기타 코드를 깔끔하게 정리하는 과정이 1번부터 4번에 해당하는 과정이라고 생각하시면 됩니다. 자 그래서 모델을 만들었어요. 그러면은 이 모델을 갖다가 우리의 그 프로덕트에다가 배포를 하고 인플리멘트를 해야 되잖아요. 그러려면 이 모델을 갖다가 우리 시스템에 들어갈 수 있게 압축화해야 돼요. 경량화해야 돼요. 그래서 이런 경향 및 압축화하는 과정이 필요하게 되고 그렇게 해가지고 우리 시스템에 디플로이가 되면은 이 디플로이 됐을 때 그 모델의 성능이나 어떤 사용 같은 패턴을 보고서 도메인 지식 전문가를 통해서 이 결과를 갖다가 해석하는 과정이 포함되게 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 12,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 918,
      "char_count": 1690
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c013_2ad002",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 자 그래서 모델을 만들었어요. 그러면은 이 모델을 갖다가 우리의 그 프로덕트에다가 배포를 하고 인플리멘트를 해야 되잖아요. 그러려면 이 모델을 갖다가 우리 시스템에 들어갈 수 있게 압축화해야 돼요. 경량화해야 돼요. 그래서 이런 경향 및 압축화하는 과정이 필요하게 되고 그렇게 해가지고 우리 시스템에 디플로이가 되면은 이 디플로이 됐을 때 그 모델의 성능이나 어떤 사용 같은 패턴을 보고서 도메인 지식 전문가를 통해서 이 결과를 갖다가 해석하는 과정이 포함되게 됩니다. 자 그리고 마지막에 이제 모델 평가를 해야 되는데요. 모델 평가는 왜 필요할까요? 그거는 바로 모델을 프로덕트에 사용할 준비가 되었는지 확인하기 위해서예요. 예를 들어서 유튜브 추천 시스템 같은 경우의 모델 평가는 실제로 이 추천 시스템 모델 알고리즘을 가지고 사람들이 추천을 받았을 때 그 사람들이 그 유튜브를 시청하는 시간이 더 늘었는지 아니면 유튜브를 더 많이 시청하게 되었는지 이런 거를 평가를 하게 되는 거죠. 근데 만약에 이 평가 결과가 되게 안 좋아요. 실제로 이 유튜브 추천 시스템을 디플로이 했더니 사람들의 시청률이 더 떨어졌어요. 그러면 당연히 이 모델이 제대로 워킹을 하지 않는 걸 거 아니에요 그래서 그러면 당연히 이 유튜브 알고리즘이 유튜브 추천 알고리즘이 유튜브 시스템의 디플로이가 되면 안 되겠죠. 왜냐하면 평가 결과가 안 좋으니까 그래서 이 모델을 이렇게 프로덕트에 사용할 준비가 됐는지 안 됐는지를 평가하기 위해서 모델 평가는 꼭 필요한 어떤 테스크가 됩니다. 그래서 테스트 데이터셋을 모델 테스트로 이렇게 삼고 전문가를 참여시켜서 예측 오류를 파악하게 되고 그리고 또한 요새 되게 중요하게 생각하고 있는 게 에티컬 한지입니다. 즉 이 에아 모델을 갖다가 우리가 시스템에 디플로이 했을 때 실제로 이거를 쓸 때 윤리적인 어떤 문제가 없는지 산업적 윤리적 법적인 문제가 없는지를 또 확인을 해야 됩니다. 네 이게 요새 되게 중요하죠. 왜냐하면 생성형 AI가 많이 있기 때문에 이 어 이 생성형 AI가 윤리적으로 좋지 않은 데이터를 생성하는지 아닌지를 우리가 항상 염두에 둬야 됩니다. 그리고 로버스트니스 이건 뭐냐면요 실제로 모델이 우리가 그 연구 단계 모델 사이언티스트들이 이제 모델을 만드는 단계에서는 별 문제가 없었지만 실제로 시스템에 들어갔을 때 브레이크 다운 하는 경우가 많아요. 왜냐하면 특히 요새 챗gpt 같은 RLG 랭귀지 모델은 굉장히 큰 메모리를 쓰기 때문에 웬만한 시스템에는 디플로이를 못 해요. 그래서 그 시스템 안에서 우리가 이 모델을 디플로이 했을 때 리저너블하게 동작을 하는지 이 로보 스튜니스를 테스트해야 됩니다. 그리고 이런 것들을 다 패스를 하면은 어 이 성공 지표랑 비교를 해서 이 모델을 실제로 배포할 것인지 아닌지를 우리가 결정을 하게 되겠죠. 그래서 이제 오케이 그래서 이 모델이 경량화 돼 가지고 시스템에도 디플로이 되고 실제로 모델 평가도 좋고 이 모델을 넣었을 때 뭐 예를 들어 유튜브 어 레코멘데이션 시스템이라면은 사람들의 그 시청률이 더 높아졌다 그러면 이제 모델을 디플로이 하고 배포를 해야 되겠죠. 그래서 그게 바로 모델 배포 과정입니다. 이 단계에서는요 현재 시스템에 머신러닝 모델을 갖다가 어 디플로이 하고 배포를 하는 과정이 포함됩니다. 그래서 일반적으로 클라우드 및 로컬 서버 아니면은 웹 브라우저 아니면 소프트웨어 패키지 같은 거에 배포를 할 수 있겠죠. 예를 들어서 뭐 유튜브 레코멘데이션 시스템 같은 경우는 웹 브라우저죠 그러니까 유튜브 사이트에다가 이 알고리즘을 갖다가 배포를 하게 되죠. 그래서 어 뭐 이렇게 배포를 하게 되고 이렇게 배포한 게 끝이 아니고 배포를 한 다음에 계속 모니터링하고 유지 및 관리를 해야 돼요. 그래서 배포한 후에는요 지속적으로 시스템을 갖다가 모니터링하고 개선을 해야 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 13,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 1048,
      "char_count": 1924
    },
    {
      "id": "transcript_ml_engineering_1강_ml_lifecycle_c014_ca8b2d",
      "content": "[ML Engineering] (1강) ML LifeCycle\n\n다. 그래서 일반적으로 클라우드 및 로컬 서버 아니면은 웹 브라우저 아니면 소프트웨어 패키지 같은 거에 배포를 할 수 있겠죠. 예를 들어서 뭐 유튜브 레코멘데이션 시스템 같은 경우는 웹 브라우저죠 그러니까 유튜브 사이트에다가 이 알고리즘을 갖다가 배포를 하게 되죠. 그래서 어 뭐 이렇게 배포를 하게 되고 이렇게 배포한 게 끝이 아니고 배포를 한 다음에 계속 모니터링하고 유지 및 관리를 해야 돼요. 그래서 배포한 후에는요 지속적으로 시스템을 갖다가 모니터링하고 개선을 해야 됩니다. 예를 들어서 유튜브 추천 시스템 같은 경우에는요 유저들이 계속 들어오죠 그리고 유저들의 어떤 프리퍼런스가 계속 바뀌게 돼요. 그래서 우리가 디플로이 한 이 추천 알고리즘이 계속 동작하라는 그런 개런티가 없어요. 왜냐하면 계속 시스템에 변화가 있기 때문에 그래서 이 추천 시스템이 실제로 잘 동작하는지 아니면 사람들의 프리퍼런스에 따라서 추천이 오히려 사람들을 유튜브 시청을 저해하지는 않는지 이렇게 제대로 이 모델이 잘 동작하고 있고 우리가 원하는 그런 아웃풋을 내는지를 계속 모니터링하고 만약에 그게 좋지 않다면 모델 단에서부터 개선을 해야 되는 필요가 있습니다. 그래서 요 모니터링 유지 관리 이런 것을 거의 그냥 뭐 실제로 탭 컴퍼니 같은 데 가면은요 거의 매일매일 해요 그래서 어 새로운 소프트웨어나 하드웨어를 업데이트하기 위해서 그 전체 머신 러닝 주기를 개선해야 되는 경우도 있습니다. 그래서 오늘은 이렇게 그 머신 러닝 라이프 사이클에 대해서 되게 개괄적으로 이렇게 배워봤습니다. 그래서 여러분들이 이 부트 캠프를 마치고 현업에 갔을 때 어떤 일을 하게 되고 이렇게 그 머신 러닝을 이용해서 모델을 만들고 프로덕트를 만드는 과정이 어떻게 진행되어 있는지 굉장히 개괄적으로 이렇게 빅 픽처를 보여드렸다고 생각하시면 됩니다. 그래서 이제 다음 시간에는요 본격적으로 좀 더 테크니컬하게 들어가서 머신러닝 모델 중에 가장 기초가 되는 리니어 리그레션이랑 리니어 리그레션의 어떤 어드벤스 된 형태인 뉴럴 렛 클래식 파이어 모델을 배워보도록 하겠습니다. 네 긴 시간 시청해 주셔서 감사합니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(1강) ML LifeCycle.json",
        "lecture_name": "(1강) ML LifeCycle",
        "course": "ML Engineering",
        "lecture_num": "1강",
        "lecture_title": "ML LifeCycle",
        "chunk_idx": 14,
        "total_chunks": 15,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:bb26b60dcdd85ec76dd284b4e44d22b4c3f7a88c321b60dbff8a1eba0a11bb67"
      },
      "token_estimate": 594,
      "char_count": 1087
    }
  ]
}