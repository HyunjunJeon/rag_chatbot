{
  "source_file": "(4강) Manipulation of Tensors.json",
  "lecture_name": "(4강) Manipulation of Tensors",
  "course": "PyTorch",
  "total_chunks": 5,
  "chunks": [
    {
      "id": "transcript_pytorch_4강_manipulation_of_tensors_c000_029135",
      "content": "[강의 녹취록] 과목: PyTorch | 강의: 4강 | 제목: Manipulation of Tensors\n\n87 어벤트 시장님께서 이런 시장님이 제니 케이스를 통해 수 있던 것처럼 함께 도움되도록 하겠습니다. 먼저 2차부터 함께 살펴보도록 하겠습니다. 네 그러면 첫 번째 특허부터 함께 살펴보도록 할까 사이 투표의 상표에 대해서 공복 주가 시중은 검찰에서 선고권 이상입니다. 접근할 수 있게 됩니다. 이번에는 타이텍스에서 인기를 이렇게 사용한 카페로드를 찾았습니다. 파이텍스는 흔히 토치 텐서 함수의 아규먼트로 10 20, 30, 40 50 60을 요소로 가지는 벡터를 변수 a에다가 할당을 해줍니다. 그리고 에이스퀘어 블라켓 제료를 출력을 해 줄 것인데요. 이는 a의 0번째 인덱스의 요소에 접근하겠다는 의미입니다. 따라서 0번째 인덱스의 요소인 10이 출력됨을 우리는 확인할 수가 있겠습니다. 여기서 여러분께 한 가지를 말씀드리고자 하는데요. 많은 분들이 텐스의 요소들을 가리킬 때 여러 가지 방식으로 이야기를 합니다. 예를 들어 우리가 생성한 텐서 a를 가지고 말씀을 드리면 10이라는 요소를 가리킬 때 저는 방금 0 번째 인덱스의 요소라고 말씀을 드렸지만 어떤 분들은 0번째 요소라고 말씀을 하시고 또 어떤 분들은 첫 번째 요소라고 말씀을 하시기도 합니다. 사실 이 중에 어느 표현이 옳다 그르다고 할 수는 없습니다. 왜냐하면 이 부분은 자신이 속해 있는 집단의 담론의 차이에 따라 그 표현이 달라지는 것이기 때문입니다. 저는 일부러 이 표현 방식들을 섞어서 사용할 예정인데요. 여러분들께서 강의를 집중해서 들으시면서 담론의 맥락에 따라 잘 구분하여 생각하시기를 바라겠습니다. 그리고 매니플레이션은 간단한 듯하지만 실제 개발 업무에서 중요한 부분인 만큼 슬라이드에서 설명한 내용을 실습하면서도 또다시 설명을 드릴 것입니다. 네 그럼 다시 이어서 다음 코드 표현을 살펴보면 텐서 a의 첫 번째 인덱스의 요소에 접근한 값을 출력하면 되겠는데요. 출력을 하면 네 20이 나오는 것을 확인할 수가 있겠습니다. 이후 번째 이제 인덱스 요소들도 여러분들께서 한 번씩 확인해 보시면 좋을 것 같습니다. 그리고 제가 이전 슬라이드에서 파이썬에서는 음수 인덱스가 가능하다고 말씀을 드렸었는데요. 텐서 에에 마이너스 1번째 인덱스 요소에 접근한 값을 출력을 하면 우리가 60을 나온다는 것을 확인할 수가 있겠습니다. 그리고 마이너스 2번째 인덱스 요소에 접근한 값을 출력을 하면 50이 나온다는 것을 확인할 수가 있겠습니다. 네 마찬가지로 이유 번째의 음수 인덱스 요소들도 여러분들께서 한 번씩 확인해 보시길 바라겠습니다. 예를 들어서 첫째 하겠습니다. 첫 번째 인도 시절 이후부터 두 번째 인도 시절 이 전 그런데 우리가 아까 보는 사이트크는 음수 이것들을 확인이 가능하다고 말씀을 드렸습니다. 그렇게 보면 그런 경우는 우리가 또 다른 소득템을 찾아보시면 됩니다. 예를 들어서 이동체 인덱스에서부터 다섯 번째 인더스트리 이번 그런 각종 1차원 텐서의 인덱싱 표현 실습에서 생성했던 1차원 텐서 a를 가지고 이어서 실습을 하도록 하겠습니다. 에이스퀘어 블라켓 1 콜론 4는 텐서 a의 첫 번째 인덱스의 요소부터 네 번째 인덱스의 요소 바로 전인 세 번째 인덱스의 요소 값까지 출력을 하겠다는 의미이며 실제로 출력을 해보면 우리가 20 30 40을 서브 텐서로 생성한다는 것을 확인할 수 있겠습니다. 음수 인덱스로 표현을 하면 에이스퀘어 블라켓 마이너스 5 콜론 마이너스 2가 되겠죠. 실제로 실행을 해보면 그 값이 같다는 것을 확인할 수가 있겠습니다. 에이스 케어 블라켓 콜론 오는 텐서 a의 0번째 인덱스의 요소부터 다섯 번째 인덱스의 요소 바로 전인 네 번째 인덱스의 요소 값까지 출력을 하겠다는 의미이며 실제로 출력을 하게 되면 10 20 30 40 50을 서브 텐서로 생성하는 것을 알 수가 있겠습니다. 그런데 a의 다섯 번째 인덱스와 a의 마이너스 1번째 인덱스는 같으므로 에이스퀘어 블라켓 홀른 5 대신 에이 스퀘어 블라켓 홀른 마이너스 1로 대체하셔도 되겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(4강) Manipulation of Tensors.json",
        "lecture_name": "(4강) Manipulation of Tensors",
        "course": "PyTorch",
        "lecture_num": "4강",
        "lecture_title": "Manipulation of Tensors",
        "chunk_idx": 0,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:54274792cf6ed573995e0ebc6016955e6c6a72792173c4920439a4989ff13a36"
      },
      "token_estimate": 1065,
      "char_count": 1995
    },
    {
      "id": "transcript_pytorch_4강_manipulation_of_tensors_c001_f80a4f",
      "content": "[PyTorch] (4강) Manipulation of Tensors\n\n다. 에이스 케어 블라켓 콜론 오는 텐서 a의 0번째 인덱스의 요소부터 다섯 번째 인덱스의 요소 바로 전인 네 번째 인덱스의 요소 값까지 출력을 하겠다는 의미이며 실제로 출력을 하게 되면 10 20 30 40 50을 서브 텐서로 생성하는 것을 알 수가 있겠습니다. 그런데 a의 다섯 번째 인덱스와 a의 마이너스 1번째 인덱스는 같으므로 에이스퀘어 블라켓 홀른 5 대신 에이 스퀘어 블라켓 홀른 마이너스 1로 대체하셔도 되겠습니다. 실제로 실행을 해주면 그 값이 같다는 것을 확인하실 수가 있겠죠. 이제 a 스퀘어 블라켓 1 콜로는 캔서 a의 첫 번째 요소부터 끝까지 출력을 하겠다는 의미이며 실제로 출력을 하게 되면 20 30, 40, 50 60을 서브 텐서로 생성한다는 것을 확인할 수 있겠습니다. 마찬가지로 1 대신에 마이너스 5 콜론으로 대체하더라도 실제로 수행을 해보면 네 같은 값이 나온다는 것을 알 수가 있겠습니다. 그다음에 이번에는 에이스퀘어 블라켓 콜론입니다. 에 스퀘어 블라켓 콜론은 0번째 인덱스 요소부터 끝까지 출력을 하겠다는 의미가 되겠습니다. 그래서 실제로 우리가 실행을 해보면 이와 같이 처음부터 끝까지 모든 요소들을 출력했다는 것을 확인할 수가 있겠습니다. 이제 에이스퀘어 블라켓 0 콜론 오 콜론 2를 살펴보도록 하겠습니다. 에이스퀘어 블라켓 0 콜론 오콜론 e는 a의 0번째 인덱스 요소부터 a의 다섯 번째 바로 이전인 요소까지 그것을 이제 두 칸 간격으로 출력을 하겠다는 의미가 됩니다. 그래서 실제로 우리가 실행을 해보면 10 30 50을 서브 텐서로 생성한다는 것을 확인할 수가 있겠습니다. 마찬가지로 에이스퀘어 블록 엔 마이너스 6 콜론 마이너스 1 콜론 2도 같은 의미가 되겠죠. 네 그래서 또 결과를 한번 또 확인을 해보도록 하고요. 또 a 스퀘어 블록의 콜론 오 콜론 2도 같은 의미가 된다는 것을 알 수가 있겠습니다. 그는 크게 다른 한번 앱에 있는 근태의 독점 위한 수리점도 함께 살펴보도록 하겠습니다. 이번에는 첫 번째 인격체 그리고 두 번째 인덱스 웹에 있는 우선 토치 텐서 함수의 아규먼트로 10 20 30, 40 50 60을 요소로 가지는 이행 3열의 텐서 b를 생성해 줍니다. 이때 비스퀘어 블라켓 0 콤마 0은 0번째 인덱스의 0번째 인덱스 열의 요소인 우리가 10을 출력한다는 것을 알 수가 있겠습니다. 여기 아래 보시면 다른 인덱스 엔과 다른 인덱스 열들을 제시했는데요. 다른 인덱스 엔과 다른 인덱스 열에 접근할 때도 출력값이 어떻게 나오는지 여러분들께서 한 번씩 살펴보시기를 바라겠습니다. 음수 인덱스도 마찬가지로 살펴보시길 바라겠습니다. 그리고 첫 번째 응급1 90 이외의 요구들은 20 30 20 10이 있었습니다. 바로 이 두 가지 2차원 텐서의 인덱싱 표현 실습에서 생성했던 2차원 텐서 비를 가지고 이어서 실습을 하도록 하겠습니다. 비스퀘어 블라켓 0 콤마 1 콜로는 텐서 b의 0번째 인덱스 행의 전체와 첫 번째 인덱스 열 그 이후에 요소들과의 교집합으로서 출력 결과를 한번 살펴보면은 20과 30을 서브 텐서로 생성을 한다는 것을 확인할 수가 있겠습니다. 그런데 비의 첫 번째 인덱스와 그 비의 마이너스 2번째 인덱스는 같은 것이므로 해당 표현으로 대체하셔도 무방하겠습니다. 그리고 비 스퀘어 블록의 콜론 콤마 1 콜론은 텐서 비의 전체 인덱스 엔과 첫 번째 인덱스 열과 그 이후의 요소들과의 교집합으로써 출력 결과를 살펴보면은 20 30 50 60을 요소로 가지는 이행 2열의 2차원 서브 텐서를 생성합니다. 아래 같은 경우에도 이제 같은 결과를 이제 출력하겠죠 네 왜냐하면 인덱스만 다른 것이기 때문에요. 네 그리고 이제 이번에는 비 스퀘어 블라켓 1 콤마 콜론 점점점을 살펴보고자 하는데요. 이와 같은 경우에는 이제 비의 첫 번째 인덱스 행의 전체와 그리고 전체 인덱스 열의 교집합으로서 출력 결과를 한번 살펴보면은 40 50 60을 서브 텐서로 생성합니다. 네 아래도 다 같은 표현입니다. 그쵸 인덱스만 바꿔줌 같은 표현이기 때문에 같은 결과가 나온다는 것을 확인하실 수가 있겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(4강) Manipulation of Tensors.json",
        "lecture_name": "(4강) Manipulation of Tensors",
        "course": "PyTorch",
        "lecture_num": "4강",
        "lecture_title": "Manipulation of Tensors",
        "chunk_idx": 1,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:54274792cf6ed573995e0ebc6016955e6c6a72792173c4920439a4989ff13a36"
      },
      "token_estimate": 1064,
      "char_count": 2036
    },
    {
      "id": "transcript_pytorch_4강_manipulation_of_tensors_c002_6c2440",
      "content": "[PyTorch] (4강) Manipulation of Tensors\n\n다. 아래 같은 경우에도 이제 같은 결과를 이제 출력하겠죠 네 왜냐하면 인덱스만 다른 것이기 때문에요. 네 그리고 이제 이번에는 비 스퀘어 블라켓 1 콤마 콜론 점점점을 살펴보고자 하는데요. 이와 같은 경우에는 이제 비의 첫 번째 인덱스 행의 전체와 그리고 전체 인덱스 열의 교집합으로서 출력 결과를 한번 살펴보면은 40 50 60을 서브 텐서로 생성합니다. 네 아래도 다 같은 표현입니다. 그쵸 인덱스만 바꿔줌 같은 표현이기 때문에 같은 결과가 나온다는 것을 확인하실 수가 있겠습니다. 조이탑을 개방하는 됩니다. 이 질문은 여러분들이 제 가 보시고 있는 것을 대한 수렴을 한 것을 좀 말씀드리도록 하겠습니다. 이번 원스폰 메모리를 통한 프로 체험을 살펴보도록 하겠습니다. 우선 토치 댄서 함수의 아규먼트로 0 1, 2, 3 4 5를 요소로 가지는 2행 3열에 2차원 텐서 씨를 생성해 주도록 하겠습니다. 이 텐서 씨의 메모리가 연속적으로 할당되었는지를 확인해 보기 위해 씨 닷 이스 언더스콜 컨테기어스 메서드를 출력해 보도록 하겠습니다. 출력을 해보면 트루 즉 연속적으로 할당되었음을 알 수가 있겠습니다. 이번에는 슬라이싱을 사용해서 서브 텐서 디를 만들어 주고자 하는데요. 이 해당 서브 텐서 디에 메모리가 연속적으로 할당되었는지를 확인해 보도록 하겠습니다. 그러기 위해서 디닷 잇스 언더스콜 컨티듀어스 메서드를 우리가 출력을 해보면 펄스가 나온다는 것을 알 수가 있는데요. 즉 비연속적으로 할당되어 있음을 알 수가 있겠습니다. 따라서 이 뷰 메서드를 활용해서 모양을 변경하고자 할 때 이와 같이 오류가 발생하는 것을 확인할 수가 있겠습니다. 그러면 서브 댄서 d를 뷰 메서드를 통해 모양을 변경하는 것을 이제 포기해야 할까요? 네 그것은 아닙니다. 우리가 did 콘티i스 메서드를 사용해서 서브 텐서 d를 컨티규어스하게 만들어 줄 수가 있습니다. 트루가 나오는 거 보이시죠? 따라서 이 컨티규어스의 진 디 언더 스컬 컨티규어스는 이제 뷰 메서드를 활용할 수 있게 됩니다. 소장 이 이상 고용 등으로 발생할 수가 있습니다. 또 노력은 항력증 증설 과를 조금 많이 줄어 발생하는 것입니다. 우선 토츠 닷 어레인지 함수의 11를 아규먼트로 넘겨주면 0부터 11까지의 요소들로 구성된 텐서 프를 생성해 줍니다. 그리고 그 크기를 살펴보면은 우리가 12개 요소들을 가지고 있는 1차원 텐서임을 알 수가 있겠습니다. 이제 뷰 메서드를 활용해 보도록 하겠습니다. 뷰 메서드의 메서드로 4 콤마 3을 아규먼트로 넘겨주면 텐서 애플을 우리가 4행 3열의 크기를 가진 텐서로 모양 변경이 가능하겠습니다. 아래의 표현은 이제 인덱스를 변경한 이제 동일한 표현으로 열과 관련된 아규먼트를 지금 마이너스 1로 주었는데 제가 슬라이드에서 이 마이너스 1의 중요성을 설명드렸죠. 마이너스 1의 인덱스가 그 마지막 요소를 표현하기 때문에 정말 유용한 표현인 것 같습니다. 그래서 여러분들께서 이러한 표현을 잘 숙지해 두셨으면 합니다. 이번에는 뷰 메서드의 메서드로 3 콤마 2 콤마 2를 아규먼트로 넘겨주면 텐서 애플을 3개의 이행 2열로 구성된 3차원 텐서로 모양 변경이 가능하겠습니다. 실제로 보시면 그렇죠 네 3개의 이행 2열에 이제 구성된 3차원 텐서임을 우리가 확인할 수가 있겠습니다. 아래 표현도 마찬가지죠. 마이너스 1로 마지막에 줬죠 네 그러면은 이제 3개 2행 2열로 구성된 3차원 텐서를 우리가 어 표현이 가능하겠습니다. 또치듯 랜덤 노멀 함수를 사용해서 표준 정규 분포의 값들을 요소로 가지는 이제 3행 3열에 2차원 텐서 아이를 생성해 주도록 하겠습니다. 이제 플레튼 함수를 사용해서 평탄화를 시켜보려고 하는데요. 플레튼 함수를 사용하게 되면은 텐서 아이가 1차원 텐서로 이렇게 평탄화되는 것을 확인할 수가 있겠습니다. 이번에는 특정 사례는 전문 고용 30원을 세무부에서 살펴드리도록 하겠습니다. 예를 들어서 연봉 10년 보는 연봉 2차원 30만 원입니다. 이번에는 전체를 평탄화하는 것이 아닌 특정 차원의 범위만 평탄화를 해보도록 하겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(4강) Manipulation of Tensors.json",
        "lecture_name": "(4강) Manipulation of Tensors",
        "course": "PyTorch",
        "lecture_num": "4강",
        "lecture_title": "Manipulation of Tensors",
        "chunk_idx": 2,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:54274792cf6ed573995e0ebc6016955e6c6a72792173c4920439a4989ff13a36"
      },
      "token_estimate": 1081,
      "char_count": 2021
    },
    {
      "id": "transcript_pytorch_4강_manipulation_of_tensors_c003_619d83",
      "content": "[PyTorch] (4강) Manipulation of Tensors\n\n다. 또치듯 랜덤 노멀 함수를 사용해서 표준 정규 분포의 값들을 요소로 가지는 이제 3행 3열에 2차원 텐서 아이를 생성해 주도록 하겠습니다. 이제 플레튼 함수를 사용해서 평탄화를 시켜보려고 하는데요. 플레튼 함수를 사용하게 되면은 텐서 아이가 1차원 텐서로 이렇게 평탄화되는 것을 확인할 수가 있겠습니다. 이번에는 특정 사례는 전문 고용 30원을 세무부에서 살펴드리도록 하겠습니다. 예를 들어서 연봉 10년 보는 연봉 2차원 30만 원입니다. 이번에는 전체를 평탄화하는 것이 아닌 특정 차원의 범위만 평탄화를 해보도록 하겠습니다. 우선 토치 닷 랜덤 노멀 함수를 사용해서 3개의 이행 2열로 구성된 3차원 텐서 k를 생성해 주도록 하겠습니다. 여기서 플랫트 함수의 아규먼트로 k와 0을 넘겨주면은 0번째 차원부터 평탄화를 수행하는 결과를 우리가 확인할 수가 있겠습니다. 그리고 플랫t 함수의 아규먼트로 케이와 1을 넘겨주면은 우리가 첫 번째 차원부터 그 평탄화를 수행하는 결과를 확인할 수가 있습니다. 또한 이제 플레튼 함수의 아규먼트로 k와 이를 넘겨주면 두 번째 처음부터 평탄화를 수행하는 결과이다 보니까 사실상 모양 변경이 없음을 확인할 수가 있습니다. 뿐만 아니라 이제 플랫트 함수의 아규먼트로 k와 0과 1을 넘겨주면 우리가 0 번째 차원부터 이제 첫 번째 차원까지만 이제 평탄화를 수행하는 결과를 확인할 수가 있겠습니다. 그래서 매매를 언급하는 식구라고 사용 금액인 경우에는 금액 카드를 사용하는 것이 좋습니다. 그만 금액 카드 같은 경우에는 우선 토치 어레인지 함수의 12를 아규먼트로 넘겨주면 0부터 11까지의 요소들로 구성된 우리가 이 텐서 엔을 생성할 수가 있겠습니다. 이제 리쉐인 메서드를 활용해 볼 건데요. 리쉐인 메서드의 4 콤마 3을 아규먼트로 넘겨주면은 우리가 이 앞에서 봤던 그 텐서 엔이요 4행 3열의 텐서로 모양이 변경되는 것을 확인할 수가 있겠습니다. 이제 아래의 표현은 이제 인덱스만 변경한 같은 표현인 거 아시겠죠? 네 실행을 해보면 네 결과가 동일한 것을 알 수가 있겠습니다. 이번에는 리쉐인 메서드에 3 콤마 2 콤마 1를 아규먼트로 넘겨줘 보겠습니다. 그러면은 우리가 출력을 했을 때 3개의 뎁스를 가진 이행 2열의 3차원 텐서로 모양 변경이 되는 것을 확인할 수가 있겠습니다. 또 아래의 표현은 이제 그 인덱스만 변경한 것을 알 수가 있겠습니다. 결과는 동일합니다. 우선 토치 텐서의 함수의 아규먼트로 0 1 2 3 4 5를 요소로 가지는 2행 3열의 2차원 텐서 q를 생성해 주도록 합니다. 여기서 트랜스포스 메서드의 아규먼트로 0 콤마 1을 넘겨주면은 0번째 차원과 그리고 첫 번째 차원의 축이 바뀌는 것을 확인하실 수가 있겠습니다. 실제로 그 텐서 큐가 그 행과 열이 바뀌어서 이와 같이 출력되는 것을 네 확인할 수가 있겠죠 네 이번에는 토치 텐서 함수를 사용해서 3개의 삼행 2열로 구성된 3차원 텐서 s를 생성하였습니다. 여기서 트랜스포스 메서드의 아규먼트로 1 콤마 2를 넘겨주면은 첫 번째 차원과 두 번째 차원의 축이 바뀌어 이제 우리가 그 결과를 보게 되면은 이와 같이 이와 같은 3차원 텐서로 변경된 것을 우리가 확인할 수가 있겠습니다. 토치듯 랜덤 노말 함수를 사용해서 표준 정규분포의 값들을 요소로 가지는 한 개의 뎁스를 가지는 3행 4열의 3차원 텐서 율을 생성해 주겠습니다. 여기서 스키즈 함수를 사용하면은 디멘전이 1인 뎁스 차원을 우리가 축소하는 결과를 얻을 수가 있겠습니다. 이번에는 토치 닷 랜덤 노멀 함수를 사용해서 표준 정규 분포들의 값들을 요소로 가지는 1개의 뎁스를 가지는 일행 4열의 3차원 텐서 더블를 생성해 주도록 하겠습니다. 여기서 이제 스케즈 함수를 사용하게 되면요. 디멘전이 1인 뎁스와 행차원 두개의 차원을 이제 축소하는 것을 확인할 수가 있겠습니다. 그리고 만약에 이 뎁스 차원은 그대로 두고 행차원만 축소를 하고 싶다면은 매개 변수를 이렇게 디멘저은 1 이렇게 지정을 해 주시면은 우리가 그와 같은 결과를 얻을 수가 있겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(4강) Manipulation of Tensors.json",
        "lecture_name": "(4강) Manipulation of Tensors",
        "course": "PyTorch",
        "lecture_num": "4강",
        "lecture_title": "Manipulation of Tensors",
        "chunk_idx": 3,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:54274792cf6ed573995e0ebc6016955e6c6a72792173c4920439a4989ff13a36"
      },
      "token_estimate": 1074,
      "char_count": 2013
    },
    {
      "id": "transcript_pytorch_4강_manipulation_of_tensors_c004_4b7511",
      "content": "[PyTorch] (4강) Manipulation of Tensors\n\n다. 이번에는 토치 닷 랜덤 노멀 함수를 사용해서 표준 정규 분포들의 값들을 요소로 가지는 1개의 뎁스를 가지는 일행 4열의 3차원 텐서 더블를 생성해 주도록 하겠습니다. 여기서 이제 스케즈 함수를 사용하게 되면요. 디멘전이 1인 뎁스와 행차원 두개의 차원을 이제 축소하는 것을 확인할 수가 있겠습니다. 그리고 만약에 이 뎁스 차원은 그대로 두고 행차원만 축소를 하고 싶다면은 매개 변수를 이렇게 디멘저은 1 이렇게 지정을 해 주시면은 우리가 그와 같은 결과를 얻을 수가 있겠습니다. 토치는 랜덤 로말 함수를 사용해서 표준 정규 분포의 값들을 요소로 가지는 3행 4열의 2차원 텐서 와를 생성해 주도록 하겠습니다. 여기서 이제 언스키즈 함수를 사용할 건데요. 이 언스키즈 함수의 매개 변수로 디멘전을 0을 주도록 하겠습니다. 그러면 디멘전이 0인 뎁스 차원을 이제 확장을 하는 그러한 이제 텐서 지를 생성해 준다는 것을 알 수가 있겠습니다. 이 언스키즈 함수가 중요해 보이지는 않아도 이후 머신 러닝 실습에서 정말 유용하게 잘 쓰이는 그러한 코드이기 때문에 꼭 기억해 두시길 바라겠습니다. 이번에는 디멘전이 1인 행차원을 확장해 보도록 하겠습니다. 그러면 이제 기존의 행차원은 이제 뎁스 차원으로 이동한다는 것도 우리가 알 수가 있겠습니다. 이번에는 디멘전이 2인 열 차원을 확장해 보도록 하겠습니다. 그러면 기존의 이제 행차원은 여기 보시면은 뎁스 차원으로 갔고 기존의 열 차원은 행 차원으로 가게 되는 것을 확인할 수가 있겠습니다. 그랬을 때 우리가 금융점 하는 점에서 어떻게 병합이 달라지는지 선택해서 하겠습니다. 이제 스텝 함수를 활용해서 텐서들을 결합을 해보도록 하겠습니다. 아래의 예는 1강에서 3차원 텐서를 설명하기 위해 사용했던 예인데요. 레드 채널, 그린 채널, 블루 채널 이렇게 변수명을 가진 이행 2열의 2차원 텐서 3개를 생성해 준 것이죠. 그리고 여기서 이제 스텝 함수를 사용할 것인데 스텝 함수를 사용하고 그 아규먼트로 레드 채널, 그린 채널, 블루 채널을 투플로 묶어 변수 a에다가 할당을 해주면 됩니다. 그리고 이제 여기서 이제 매개 변수를 따로 입력해 주지는 않았는데 이렇게 작성을 하면은 이제 매개 변수는 저절로 0으로 입력이 되게 되고 디멘전 0차원 축을 생성해서 뎁스 축을 기준으로 결합을 하게 되는 것입니다. 그래서 변수 a와 변수 a의 크기를 실제로 출력을 해보면 변수 에는 3개의 이행 2열로 구성된 3차원 텐서가 우리가 생성된다는 것을 확인할 수가 있겠습니다. 이번에는 디멘전을 이제 1로 이제 그러니까 매개 변수로 이제 디멘전 1을 입력해 준 것이죠. 그러면은 디멘전 1차원 축을 생성해서 이제 행축을 기준으로 결합을 하게 되고 변수 a와 그리고 변수 a의 크기를 출력을 하게 되면은 변수 a는 두 개의 3행 2열로 구성된 3차원 텐서가 생성이 된다는 것을 확인할 수가 있겠습니다. 또 마지막으로 이제 베개 변수로 디멘전은 이를 입력해 주었는데 그러면 디멘전 2차원 축을 생성해서 열 축을 기준으로 이제 결합을 하게 되겠죠. 그리고 이제 출력을 해보면은 이제 변수 a는 2개의 2행 3열로 구성된 3차원 텐서가 생성이 된다는 것을 확인할 수가 있겠습니다. 전자 선고 내용이 전국적인 목적으로 금융법으로 공통 문법으로 선포 되어 있었다. 그리고 상품이나 한국무용 등등 들은 플랫폼.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "(4강) Manipulation of Tensors.json",
        "lecture_name": "(4강) Manipulation of Tensors",
        "course": "PyTorch",
        "lecture_num": "4강",
        "lecture_title": "Manipulation of Tensors",
        "chunk_idx": 4,
        "total_chunks": 5,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:54274792cf6ed573995e0ebc6016955e6c6a72792173c4920439a4989ff13a36"
      },
      "token_estimate": 896,
      "char_count": 1677
    }
  ]
}