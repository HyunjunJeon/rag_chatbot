{
  "source_file": "2강_행렬이_뭔가요.json",
  "lecture_name": "2강_행렬이_뭔가요",
  "course": "AI Math",
  "total_chunks": 8,
  "chunks": [
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c000_65ab66",
      "content": "[강의 녹취록] 과목: AI Math | 강의: 2강 | 제목: 행렬이_뭔가요\n\n네 안녕하세요 메스메렉스 포 알티피셜 인텔레전스 두 번째 강의 행렬이 뭔가요를 가르치게 된 고려대학교 통계학과 임성빈 교수입니다. 네 이번 시간에는 선형대수의 중요한 개념 중 하나인 행렬을 한번 배워보도록 하겠습니다. 네 지난 시간에 저희는 벡터가 뭔지 한번 공부를 해 보았는데요. 이번 시간에는 벡터의 개념을 넘어서 행렬을 이해해 보도록 하겠습니다. 행렬은 영어로 저희가 매트릭스라고 부르는데요. 바로 벡터를 원소로 가지는 2차원 배열이라고 부릅니다. 참고로 여기서 말하는 2차원의 차원은 벡터에서 얘기했던 차원과는 조금 다른 개념이니까 유의하시는 게 좋겠습니다. 네 벡터를 한번 수식으로 저희가 써 보게 되면은 앞에서 쓸 때 저희가 소문자 엑스를 썼는데요. 이번엔 행렬을 저희가 수식으로 표현하게 될 때는 대문자라는 기호를 저희가 쓰도록 하겠습니다. 그래서 보시다시피 행렬도 숫자로 이루어져 있기는 하지만 어 각각의 어떤 숫자들이 벡터로 묶여져 있고 그 벡터들을 하나의 원소로 가지게 되어 있는 게 행렬로 저희가 이해를 할 수가 있겠습니다. 원래 행렬을 이해할 때는요 저희가 열 벡터를 기준으로 이해를 할 수가 있습니다마는 어 이 수업 시간 때는 저희가 행벡터를 기준으로 해서 수식을 표현하도록 하겠습니다. 가끔씩 제가 열 벡터랑 행벡터를 나눠서 섞어서 쓸 때도 있는데요. 네 그때그때마다 수식에 좀 차이가 있기 때문에 이해하시는데 참고하시면 좋겠습니다. 저희가 행벡터를 기준으로 하는 이유는 사실 넌 파이의 경우에는 행벡터를 기준으로 벡터 행렬을 이루기 때문에 코드랑 수식을 같이 이해하기 위해서 저희가 좀 편의상으로 행벡터를 기준으로 좀 설명을 하려고 합니다. 보시다시피 행렬 안에 수식이 이렇게 9개의 지금 현재 숫자가 들어 있는데요. 이 행렬은 저희가 행렬이 3개고 열이 3개다라고 해서 3 바이 3 행렬이라고 부르게 됩니다. 이랬을 때 각 행을 이루는 행벡터가 3개 있다고 볼 수가 있겠죠. 그래서 벡터가 행벡터가 3개 또는 이렇게 열 벡터로 여기지 있는 게 3개로 이루어져 있는 게 지금 이 행렬을 이해할 때 벡터를 원소로 가진다라고 여러분들께서 이해하시면 되겠습니다. 그리고 여기서 말하는 2차원이다라는 얘기는 행과 열 두 개의 차원으로 이루어져 있기 때문에 저희가 2차원 배열이라고 부르게 되는 것이고요. 행렬을 넘파이로 한번 구현해 보시려면은 어 벡터랑 유사하게 구현해 볼 수가 있게 됩니다. 벡터의 경우에는 1차원 배열이었기 때문에 넘파의 어레이를 쓰실 때 대괄호를 하나만 쓰셨는데요. 행렬의 경우에는 대괄호를 2개를 쓰셔야 됩니다. 그래서 보시다시피 대괄호를 2개로 열고 각각의 벡터를 이렇게 담는 방식으로 행렬을 구현을 할 수가 있게 됩니다. 그래서 우측의 수식을 저희가 넘파이 코드로 구현한 게 네 이 우측의 코드로 이해하실 수가 있겠는데요. 이거를 조금 더 수식을 한번 그 일반적인 차원으로 확대를 한번 해보도록 하겠습니다. 네 그래서 우리가 행렬을 각각의 행벡터로 이루어져 있는 행렬로 한번 이해를 해 보시게 되면은 이때 각각의 스1 벡터 그리고 스투 벡터 그리고 스앤 벡터들이 이제 모두 행벡터 로 이해를 하시면 되고요. 이 n개의 행벡터로 이루어져 있는 행렬로 보시면 되겠습니다. 그렇다면 이 각각의 행벡터는 몇 개의 원소로 이루어져 있을까요? 네 행렬을 구성하실 때 각 행벡터의 원소의 개수는 저희가 따로 제한을 두지 않습니다만 각각의 행벡터의 원소들의 개수는 모두 같아야 됩니다. 그래서 행렬은 각 행벡터들이 서로 같은 길이를 가진 그리고 또는 서로 같은 차원을 가진 벡터들로 구성된 2차원 배열이다라고 여러분들이 이해를 하시면 되겠습니다. 그래서 보시다시피 스원이라는 행벡터는 엑스원1 스1 2 그리고 엑스원 엠으로 이루어져 있는 즉 엠개의 숫자들로 이루어져 있는 행벡터가 되는 것이고요. 스투라는 행벡터는 엑스 21부터 스투엠으로라는 숫자로 이루어져 있는 행 벡터가 되겠습니다. 그래서 모두 총 n개의 행벡터가 있고 각각의 행벡터는 m개의 숫자들로 이루어져 있습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 0,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 1099,
      "char_count": 2007
    },
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c001_7871da",
      "content": "[AI Math] 2강_행렬이_뭔가요\n\n다. 그래서 행렬은 각 행벡터들이 서로 같은 길이를 가진 그리고 또는 서로 같은 차원을 가진 벡터들로 구성된 2차원 배열이다라고 여러분들이 이해를 하시면 되겠습니다. 그래서 보시다시피 스원이라는 행벡터는 엑스원1 스1 2 그리고 엑스원 엠으로 이루어져 있는 즉 엠개의 숫자들로 이루어져 있는 행벡터가 되는 것이고요. 스투라는 행벡터는 엑스 21부터 스투엠으로라는 숫자로 이루어져 있는 행 벡터가 되겠습니다. 그래서 모두 총 n개의 행벡터가 있고 각각의 행벡터는 m개의 숫자들로 이루어져 있습니다. 그래서 이 벡터는 총 엔 곱하기 m개의 숫자로 이루어져 있고 행이 n개고 열이 m 개인 m바 m 행렬로 표현이 되겠습니다. 네 이때 각 행렬은 방금 전에 설명드렸던 행 로우랑 그리고 열 칼럼 두 개의 인덱스로 각 원소를 표현하게 됩니다. 그래서 행 인덱스를 먼저 표현해서 아라고 저희가 쓰고요. 그리고 칼럼 열 인덱스를 두 번째로 표기해서 제라는 인덱스를 쓰게 됩니다. 그래서 스아제라고 표시를 하게 되면은 아 번째 행 그리고 제 번째 열에 위치해 있는 숫자로 여러분들이 이해하시면 되고요. 네 행렬을 표시할 때 이렇게 스와 제이 그리고 가로로 닫는 기호로 보통 표현을 하기도 합니다. 네 이런 표현 기호는 나중에 정말 많이 쓰이게 될 기호니까요. 잘 눈여겨보시기를 바랍니다. 행렬의 특정 열을 이제 고정시켜 주게 되면은요 저희가 각각의 벡터들을 행벡터 열벡터라고 이제 부르게 되는데 가령 첫 번째 행을 고정시키게 되면은 첫 번째 행 벡터라고 부르게 되는 것이고요. 첫 번째 열을 이제 고정시키게 되면은 첫 번째 열 벡터라고 저희가 부르게 되는 것입니다. 이렇게 행렬을 구성할 때 행벡터와 열벡터로 나눠서 관찰을 할 수가 있고 지정을 할 수가 있기 때문에 이런 개념들을 꼭 기억을 해두시면 좋겠습니다. 네 저희가 행렬을 전치시킨다라는 표현을 종종 쓰게 될 텐데요. 전치라는 개념은 영어로는 트랜스포즈라고 부르고 바로 행과 열 인덱스의 순서를 바꿔서 표기하는 것을 말합니다. 저희가 수식으로 표현할 때는 이렇게 어 티 모양의 기호를 스의 우측 상단에다가 표시를 하게 되는데요. 이거를 우리가 이제 트랜스포즈 기라고 부르고 이때 행렬을 어떻게 표시가 되냐면은 원래 각각 행과 열에 있었던 인덱스 순서를 바꿔서 숫자들을 위치를 바꿔서 넣어주게 됩니다. 그래서 원래는 첫 번째 행 두 번째 열에 있었던 숫자를 두 번째 행 첫 번째 열에 있는 숫자랑 위치를 바꾸게 되죠. 대각선 모양에 있는 위치에 있는 애들끼리 어 숫자를 바꾸는 거를 저희가 전치라고 부르고요. 이렇게 숫자가 전치된 행렬을 전치 행렬 즉 트랜스포즈 매트릭스라고 저희가 부르게 됩니다. 수식으로 쓰게 될 때는 아까 전에 배웠던 XI의 제에 티라는 기호를 쓰고 각각 아이랑 제이랑 인덱스 순서가 바뀌었기 때문에 제아로 저희가 표시를 할 수가 있게 됩니다. 어 전치 행렬은 굉장히 많이 쓰이는 개념이니까 꼭 기억해 두시면 좋겠습니다. 지난 시간에 벡터를 이해하는 방법으로 벡터를 한 점으로 표현한다고 설명드렸었는데요. 그렇다면 행렬을 이해하는 방법은 무엇일까요? 네 저희가 행렬을 이해하는 방법을 두 가지를 한번 소개해 드리려고 합니다. 먼저 벡터가 공간에서 한 점을 의미한다면 행렬은 이 각각의 점들을 모두 모은 즉 여러 점을 나타내는 것으로 이해해 볼 수가 있겠습니다. 아까 전에 설명드렸다시피 행렬은 벡터로 이루어져 있는 2차원 배열이라고 말씀을 드렸죠. 즉 각 벡터가 한 점들이고 그 점들을 모은 게 행렬이면은 이 여러 점들을 표현하는 걸 우리가 행렬이라고 표현할 수가 있게 되겠죠. 그랬을 때 행렬의 행벡터 즉 아이 번째 행 벡터는 아이 번째 데이터를 의미한다라고 여러분들께서 이해해 주시면 되겠습니다. 이 행렬이 있을 때 엑스원 행벡터 그리고 스투 행벡터 그리고 스앤 행벡터가 있다면 이 각각의 스1 스2 스앤 행벡터는 우측에서 보시다시피 각각의 점들을 나타내는 것이고 이것들은 우리가 데이터로 의미를 받아들일 수가 있게 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 1,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 1077,
      "char_count": 1974
    },
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c002_201211",
      "content": "[AI Math] 2강_행렬이_뭔가요\n\n다. 이 행렬이 있을 때 엑스원 행벡터 그리고 스투 행벡터 그리고 스앤 행벡터가 있다면 이 각각의 스1 스2 스앤 행벡터는 우측에서 보시다시피 각각의 점들을 나타내는 것이고 이것들은 우리가 데이터로 의미를 받아들일 수가 있게 됩니다. 그리고 행렬의 아 제 번째 숫자는 즉 행렬의 XI제 원소는 아 번째 데이터의 제2번째 변수의 값으로 여러분이 이해를 하실 수가 있겠습니다. 그래서 기계 학습이나 통계적 모델링에서 이와 같이 데이터를 행렬로 나타내는 표현을 많이 쓰게 되니까요. 우리가 행렬은 아 어떤 데이터를 표현하는 데 쓸 수 있겠구나라고 여러분들이 이해를 하실 수가 있겠습니다. 네 이렇게 행렬을 우리가 어떤 그 공간에서 데이터들의 모임이다라고 이해를 해 볼 수가 있는데요. 그렇다면 행렬의 덧셈 뺄셈 그리고 곱셈을 어떤 벡터에서 배웠던 덧셈 뺄셈처럼 이해해 볼 수 있는지도 한번 보도록 하겠습니다. 행렬은 벡터를 원소로 가지는 2차원 배열이라고 설명드렸는데요. 행렬도 벡터와 마찬가지로 같은 모양을 가지면 덧셈과 뺄셈을 마찬가지로 계산을 할 수가 있게 됩니다. 이 원리는 벡터의 덧셈과 뺄셈과 마찬가지로 동작을 하게 됩니다. 그래서 벡터에서처럼 두 행렬이 서로 모양이 같으면 각각의 성분들을 더하고 그리고 빼는 방식으로 행렬에 덧 뺄셈을 정의할 수가 있게 되고요. 수식으로 표현하게 되면은 아 제 번째 성분과 아이제이 번째 성분들끼리의 덧셈 뺄셈으로 이렇게 표현을 할 수가 있게 됩니다. 행렬의 성분 곱도 벡터의 성분 곱이랑 똑같이 이해를 할 수가 있겠습니다. 벡터의 성분 곱은 각 성분들끼리의 곱셈을 의미하는 것이었는데요. 행렬의 성분 곡도 마찬가지입니다. 행렬을 이루는 각 성분들의 곱셈으로 저희가 표현할 수가 있게 되고 벡터의 성분 급과 똑같은 기호를 사용해서 행렬의 성분곱을 우리가 다음과 같이 표현할 수가 있게 됩니다. 그래서 각 인덱스끼리의 위치에 해당하는 숫자들을 곱하는 걸로 우리가 성분곱을 이해를 할 수가 있게 됩니다. 마찬가지로 스칼라 곱도 벡터와 똑같이 정의를 할 수가 있고요. 행렬의 스칼라 곱은 가 성분들의 똑같은 숫자를 곱해 준 것으로 이해를 하시면 되겠습니다. 네 하지만 행렬은 곱셈이 한 종류만 있는 것은 아닙니다. 저희가 매트릭스 멀티플리케이션을 한번 배워보게 될 텐데요. 네 행렬 곱셈은 두 행렬의 행벡터와 그리고 열 벡터 사이에 내적으로 행렬 곱셈을 정의를 하게 됩니다. 좀 더 구체적으로 한번 보게 되면요. x라는 행렬이 있고 y라는 행렬이 다음과 같이 주어져 있다고 보겠습니다. 이때 두 행렬의 곱셈은 x의 행벡터와 그리고 와의 열 벡터 사이의 내적으로 정의를 하게 되겠습니다. 그래서 스랑 와의 곱셈을 다음과 같이 스와라고 이제 표현을 하게 될 텐데요. 이거를 수식으로 표현해 주게 되면은 이 XY라는 두 행렬 사이의 곱에 i j번째 원소가 어떻게 표현되느냐 x라는 행렬의 아이 번째 행벡터랑 그리고 와라는 행렬의 제이 번째 열 벡터들 사이에 내적으로 계산한 값을 우리가 스와2 행렬 곱의 아제 원소로 우리가 계산을 하게 됩니다. 그래서 행렬곱은 여러분들께서 기억하셔야 할 점이 x의 열의 개수랑 그리고 y의 행의 개수가 같아야 됩니다. 즉 다시 말해 스의 행벡터를 이루는 원소의 개수와 그리고 y의 열 벡터를 이루는 원소의 개수가 같아야만 우리가 두 벡터 사이의 내적을 정의할 수가 있기 때문에 네 두 개의 원소 개수가 같아야만 우리가 어 행렬의 곱셈을 정의할 수가 있게 됩니다. 유의하실 점은 두 행렬의 원소의 개수가 같아야 되는 것이 아니라 한 행렬에 즉 스라는 행렬의 행벡터의 원소의 개수 그리고 와라는 행렬의 열벡터의 원소의 개수가 같아야 된다라는 거를 기억해 주시면 되겠습니다. 네 그렇다면 행렬 곱셈이 실제로 어떻게 계산되는지를 저희가 한번 n파이로 관찰을 해보도록 하겠습니다. x라는 행렬은 다음과 같이 3개의 행과 3개의 열로 이루어져 있는 3 바이 3 행렬로 표현을 해 봤고요. 와라는 행렬은 다음과 같이 3개의 행으로 이루어져 있고 그리고 두 개의 열로 이루어져 있는 행렬로 표현을 해 봤습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 2,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 1096,
      "char_count": 2013
    },
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c003_eb05f1",
      "content": "[AI Math] 2강_행렬이_뭔가요\n\n다. 유의하실 점은 두 행렬의 원소의 개수가 같아야 되는 것이 아니라 한 행렬에 즉 스라는 행렬의 행벡터의 원소의 개수 그리고 와라는 행렬의 열벡터의 원소의 개수가 같아야 된다라는 거를 기억해 주시면 되겠습니다. 네 그렇다면 행렬 곱셈이 실제로 어떻게 계산되는지를 저희가 한번 n파이로 관찰을 해보도록 하겠습니다. x라는 행렬은 다음과 같이 3개의 행과 3개의 열로 이루어져 있는 3 바이 3 행렬로 표현을 해 봤고요. 와라는 행렬은 다음과 같이 3개의 행으로 이루어져 있고 그리고 두 개의 열로 이루어져 있는 행렬로 표현을 해 봤습니다. 자 이렇게 되어 있을 때 스라는 행렬과 와라는 행렬에 곱셈은 어떻게 계산이 되냐면요 스라는 행렬의 한 벡터와 그리고 와 행렬에 있는 열 벡터들 사이에 내적으로 계산이 됩니다. 이때 넌 파이에서는 행렬의 곱셈을 골뱅이 기호를 써서 연산을 해 주게 됩니다. 그래서 스라는 행렬 골뱅이 그리고 와라는 행렬을 표시해 주게 되면은 두 행렬 사이의 행렬곱을 다음과 같이 연산을 해 주게 됩니다. 네 그렇다면은 요 스라랑 행렬이랑 와라는 행렬의 행렬곱의 결과물이 어떤 식으로 계산되는지를 하나하나씩 좀 살펴보도록 하겠습니다. 먼저 첫 번째 행과 첫 번째 열 사이의 내적을 계산해 보시게 되면은 첫 번째 원소인 1과 0 사이의 곱 더하기 마이너스 2와 1 사이의 곱 더하기 세 번째인 3과 마이너스 2 사이의 곱을 다 더해준 값이 계산이 되게 되는데요. 이걸 계산해 주게 되면은 0 더하기 마이너스 2 더하기 마이너스 6이니까 마이너스 8이 결과로 나오게 되겠죠. 그래서 먼저 첫 번째 결과물이 마이너스 8이 되는 것이고요. 그다음에는 첫 번째 행과 두 번째 열 벡터 사이의 내적이 계산한다는 게 이 두 번째 위치에 오게 되는 것입니다. 그래서 이 결과값에 해당하는 행렬에 첫 번째 행 두 번째 열 위치에 있는 것은 스라는 행렬의 첫 번째 행 벡터와 와라는 벡터의 두 번째 열 벡터 사이에 내적으로 계산된 값입니다. 그래서 앞에서 했던 계산을 마찬가지로 해보시게 되면은 6이라는 숫자가 나오게 되는데요. 이게 이제 스랑 와의 행렬 곱에서 나온 결과값이 되는 것입니다. 네 마찬가지 방식으로 이렇게 두 번째 행 벡터랑 첫 번째 열 벡터를 계산해 주게 되면은 스와 와 행렬 곱백 두 번째 행 첫 번째 열에 해당하는 원소의 값을 저희가 알 수가 있게 되는 것이고요. 마찬가지로 두 번째 행 벡터와 두 번째 열 벡터 사이의 내적을 계산해 주게 되면은 네 두 번째 행 두 번째 열에 위치해 있는 값을 알 수가 있게 됩니다. 이와 같은 방식으로 저희가 행렬 곱셈을 계산할 수가 있습니다. 그렇다면 행렬에도 저희가 벡터에서 사용되는 내적이라는 개념이 있을까요? 네 사실 넌 파이에 있는 라이브러리인 함수인 엠피이너라는 함수는 어 행렬에서도 사용해 볼 수 있게 됩니다. 한 가지 유의하실 점은 네 넌 파이 이너는 아이 번째 행벡터랑 제 번째 행 벡터 사이의 내적을 계산해 주게 됩니다. 원래 행렬 곱 같은 경우에는 아이 번째 행벡터랑 제 번째 열 벡터 사이의 내적을 계산해 줬죠. 근데 이번에는 좀 다릅니다. 넘파이 이너를 가지고 두 행렬 사이에 써주게 되면은 스라는 행렬의 행벡터랑 와라는 행렬의 행벡터 사이의 내적을 가지고 계산해 주게 되기 때문에 저희가 앞에서 배웠던 매트릭스 멀티플리케이션 즉 행렬곡과는 다른 계산을 수행하게 됩니다. 그리고 이 계산은 사실 수학에서 얘기하는 내접과는 조금 차이가 있습니다. 원래 수학에서 얘기하는 두 행렬 사이의 내적은 원래는 트레이스를 같이 계산을 해줘야 되는데요. 네 어 넌파이 이너에서 계산되는 거는 트레이스 없이 이렇게 아이 번째 행벡터랑 제 번째 행벡터 사이의 내적을 계산해 준다라는 점 네 이거를 좀 주의하셔야 되겠습니다. 이거를 수식으로 표현해 주게 되면요. x라는 행렬과 그리고 y라는 행렬을 트랜스포에 취한 즉 y의 전체 행렬의 두 행렬 사이의 고불로 즉 x라는 행렬과 y의 정치 행렬 사이의 행렬곱으로 여러분이 이해를 하실 수가 있게 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 3,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 1072,
      "char_count": 1986
    },
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c004_bd99a9",
      "content": "[AI Math] 2강_행렬이_뭔가요\n\n다. 원래 수학에서 얘기하는 두 행렬 사이의 내적은 원래는 트레이스를 같이 계산을 해줘야 되는데요. 네 어 넌파이 이너에서 계산되는 거는 트레이스 없이 이렇게 아이 번째 행벡터랑 제 번째 행벡터 사이의 내적을 계산해 준다라는 점 네 이거를 좀 주의하셔야 되겠습니다. 이거를 수식으로 표현해 주게 되면요. x라는 행렬과 그리고 y라는 행렬을 트랜스포에 취한 즉 y의 전체 행렬의 두 행렬 사이의 고불로 즉 x라는 행렬과 y의 정치 행렬 사이의 행렬곱으로 여러분이 이해를 하실 수가 있게 됩니다. 그래서 넌 파이이너라는 함수는 사실 앞에서 배운 매트릭스 마이티플리케이션과 좀 달리 y라는 행렬의 전체 행렬과 원래 행렬 x 사이의 행렬곱으로 네 여러분이 이해를 하시면 되겠습니다. 참고로 이 계산은 수학에서 아까 전에 설명드렸던 트레이스 계산을 포함하지 않고 있기 때문에 네 수학에서 얘기하는 내적과는 조금 차이가 있어서 넘파이랑 수식 간의 어떤 그 정의가 좀 다르니까요. 네 이해하실 때 꼭 주의하시면 좋겠습니다. 네 그래서 마찬가지로 스라는 행렬과 와라는 행렬을 이렇게 정의를 했을 때 저희가 엠피 이너를 한번 사용할 수가 있게 됩니다. 유의하실 점은 이번에는 두 행렬의 행벡터 사이의 내적을 계산하는 것이기 때문에 내적을 계산하려면 두 벡터 사이의 원소의 개수가 모두 같아야 됩니다. 그러므로 x의 행벡터의 원소의 개수 즉 차원의 값과 y라는 행렬에 각각 행벡터의 원소의 개수가 모두 같아야 됩니다. 그래서 두 개가 서로 차원이 같아야 된다는 점을 여러분들께서 주의하셔야 되겠습니다. 이렇게 두 행벡터 사이의 내적으로 값을 계산해 주게 되면은 우리가 두 행렬 사이에 엠피 이너 값 즉 내저 값을 우리가 계산을 해 볼 수가 있게 되겠습니다. 마찬가지로 첫 번째 스라는 행렬의 첫 번째 행벡터와 y라는 행렬에 두 번째 햄벡트 사의 내적으로 마찬가지로 이렇게 값을 계산해 볼 수가 있고 이게 MP 이너라는 결과값을 어 여러분이 계산하실 때 사용하게 된다라고 이해하시면 되겠습니다. 수식적으로는 x의 아케 번째 인덱스와 y의 제케 번째 인덱스 사이의 곱을 모두 케이에 대해서 더해주는 것이 네 스랑 와의 그 엠피 이너 함수로 계산되는 결과다라는 거를 여러분들께서 이해하시면 되겠습니다. 네 이렇게 행렬의 내적을 우리가 계산해 보는 방법을 배워봤습니다. 이제 두 번째로 행렬을 이해하는 두 번째 방법을 한번 배워보도록 하겠습니다. 앞에서 배웠던 행렬을 이해하는 방법은 각각 벡터로 이루어져 있는 행렬을 우리가 벡터를 데이터로 보아서 각각의 점들로 이루어져 있는 행렬 즉 데이터를 이해할 때 우리가 행렬을 쓴다고 배워보았는데요. 행렬을 이해하는 두 번째 방법은 이와 같이 데이터로 이해하는 방법도 있지만 벡터 공간에서 사용되는 연산자 즉 오퍼레이터로 여러분이 이해할 수가 있겠습니다. 연산자학이라는 개념은 조금 처음 접하시는 분들이 계실 텐데요. 여러분들께서 수학 시간에 배웠던 함수라는 거를 네 우리가 벡터 공간을 사용할 때 연산자라는 개념을 쓰게 됩니다. 조금 더 구체적으로 한번 살펴보도록 하겠습니다. 이렇게 x라는 열 벡터가 x1 x2 그리고 xm 이렇게 m 차원으로 구성된 열 벡터가 있다고 하겠습니다. 이때 이 x라는 열 벡터를 우리가 g라는 어떤 벡터로 보내주는 함수를 찾고자 할 때 이 함수의 역할을 하는 것이 바로 이 행렬 a가 되는 것입니다. 그래서 스는 현재 보시면은 m개의 원소로 이루어져 있고요. z는 보시면 n개의 원소로 이루어져 있습니다. 즉 n 차원이고 z는 n 차원이고 x는 m 차원을 벡터로 보시면 되는데 이때 x를 m 차원 어 성분을 가지는 공간에서 엔 차원 성분을 가지는 공간으로 보내줄 때 사용되는 연산자로 우리가 행렬 a를 사용해 볼 수가 있게 됩니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 4,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 1006,
      "char_count": 1857
    },
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c005_ba216d",
      "content": "[AI Math] 2강_행렬이_뭔가요\n\n다. 이때 이 x라는 열 벡터를 우리가 g라는 어떤 벡터로 보내주는 함수를 찾고자 할 때 이 함수의 역할을 하는 것이 바로 이 행렬 a가 되는 것입니다. 그래서 스는 현재 보시면은 m개의 원소로 이루어져 있고요. z는 보시면 n개의 원소로 이루어져 있습니다. 즉 n 차원이고 z는 n 차원이고 x는 m 차원을 벡터로 보시면 되는데 이때 x를 m 차원 어 성분을 가지는 공간에서 엔 차원 성분을 가지는 공간으로 보내줄 때 사용되는 연산자로 우리가 행렬 a를 사용해 볼 수가 있게 됩니다. 구체적으로 어떻게 계산이 되냐면요. 각각의 스들의 성분들로 우리가 구성되어 있는 벡터에서 이 각각의 스들을 우리가 선형 결합이라는 즉 AI 제 이 행렬 a에 들어있는 구성 성분들로 이렇게 선형 결합을 해서 제로라는 제트의 벡터의 원소들을 계산해 주는 네 우리가 연산을 한번 생각해 볼 수가 있는데요. 이 연산은 잘 살펴보시면 a라는 행렬과 그리고 x라는 벡터의 행렬 곱으로 여러분이 이해하실 수가 있게 됩니다. 그래서 잘 보시면 x의 제2번째 인덱스에 해당하는 숫자와 a의 아이 번째 행에 속하는 행 벡터들 사이에 내적 계산이 바로 이 계산 즉 행렬곱 연산이 되는 것이기 때문에 이 에아제 곱하기 x제는 에의 아이 번째 행벡터와 그리고 엑스라는 벡터의 내적 계산이 되는 것이고요. 그 결과물에 해당하는 것이 바로 이 z라는 벡터의 i번째 구성 성분을 계산하는 수식이 되겠습니다. 네 이렇게 행렬을 이용을 해서 어떤 한 벡터를 다른 벡터가 존재하는 공간으로 보내주는 함수 즉 연산자로 정의해서 사용할 수가 있게 됩니다. 즉 행렬곡을 통해서 어떤 한 벡터를 다른 차원의 벡터 즉 다른 차원의 공간으로 보내는 것으로 이해할 수가 있겠습니다. 그래서 스라는 벡터는 엠 차원 공간에서 존재하는 벡터였다면 지라는 벡터는 엔 차원 공간에서 존재하는 벡터이니까 엠 차원에서 엔 차원으로 보내주는 함수를 생각할 때 우리가 쓸 수 있는 게 바로 이 행렬 곱이 되겠습니다. 물론 행렬이 어 이 엠 차원 공간으로 보내주는 유일한 방법은 아닙니다만 우리가 선형 함수라는 측면에서 가장 흔하게 사용하는 것이 바로 이 행렬 곱이기 때문에 여러분들께서 이해를 하시면 될 거고요. 딥러닝에서 즉 오늘날 인공지능 연산에서 가장 많이 사용되는 것이 바로 이 행렬곱을 이용한 이 행렬의 연산자로서의 어떤 기능이기 때문에 여러분들께서 이 연산을 꼭 이해를 하시면 좋겠습니다. 네 그래서 이 행렬곱을 통해서 기계 학습 또는 통계학에서는 패턴을 추출하는 데 사용할 수도 있고 또한 데이터를 압축하는 데도 사용이 가능합니다. 참고로 수학적으로는요. 모든 선형 변환 즉 리니어 트랜스포메이션에 해당하는 것은 저희가 행렬곱으로 계산할 수가 있다라는 아주 유명한 정리가 있습니다. 그렇기 때문에 모든 선형 모든 리니어 트랜스포메이션은 행렬 곱으로 표현할 수 있다라는 원리를 통해서 우리가 n차원 공간에서 n차원 공간으로 보내는 모든 선형 변화는 행렬로 표현할 수가 있겠구나라고 이해하시고 이 행렬을 우리가 가장 많이 사용하는 이유가 되는 것입니다. 네 앞에서 우리가 이제 행렬을 연산자로서 이해해 볼 수 있다라고 설명을 드렸는데요. 이때 연산자로서 정말 중요한 기능 중 하나가 바로 역행렬이라는 개념이 있습니다. 네 이번에는 역행렬이 뭔지 한번 살펴보도록 할 텐데요. 어떤 행렬 a의 오퍼레이터 즉 연산자로서의 연산을 거꾸로 되돌리는 행렬을 우리가 역행렬 즉 인버스 매트릭스라고 부르고요. 이때 이 연산에 대해서 우리가 기호를 표시할 때 어떤 행렬이 있으면 그 행렬에다가 마이너스 1승처럼 우리가 기호를 쓰게 됩니다. 어 사실 이거 같은 경우는 우리가 숫자에서는 보통 분수를 표현할 때 개념인데요. 행렬에서는 사실 분수라는 개념은 없습니다만 마치 분수랑 비슷한 역할을 하기 때문에 우리가 이렇게 마이너스 1승이라는 기호를 쓰는데 이 기호는 실제로 분수가 아니라 행렬에서는 역행렬을 뜻하는 거다라고 여러분이 기억하시면 되겠습니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 5,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 1067,
      "char_count": 1960
    },
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c006_74b288",
      "content": "[AI Math] 2강_행렬이_뭔가요\n\n다. 어 사실 이거 같은 경우는 우리가 숫자에서는 보통 분수를 표현할 때 개념인데요. 행렬에서는 사실 분수라는 개념은 없습니다만 마치 분수랑 비슷한 역할을 하기 때문에 우리가 이렇게 마이너스 1승이라는 기호를 쓰는데 이 기호는 실제로 분수가 아니라 행렬에서는 역행렬을 뜻하는 거다라고 여러분이 기억하시면 되겠습니다. 역행렬이란 행과 열 숫자가 같고 그리고 행렬 시력이라고 부르는 디타미넌트 값이 0이 아닌 경우에만 계산할 수가 있는 네 행렬인데요. 즉 다시 말해서 어떤 행렬이 행위 개수랑 열의 개수가 같을 때만 우리가 역행렬을 계산할 수가 있고 또한 행의 개수랑 열의 개수가 같아도 행렬식이 0인 경우에는 우리가 역행력을 도출할 수는 없습니다. 참고로 역행렬을 계산할 때 행렬식이 뭔지는 조금 이따가 뒤에서 배우게 될 텐데요. 일단 역행렬의 성질이 무엇인지부터 살펴보도록 하겠습니다. 어떤 행렬 a가 있을 때 그 행렬 a에다가 이렇게 역행렬을 행렬곱으로써 곱해주게 되면은 그 결과물은 항등 행렬 아가 나오게 됩니다. 항등 행렬이란 대각선 위치에 있는 값들은 모두 1이고 나머지 위치에 있는 구성 성분들은 0인 행렬을 의미하는 것인데요. 이 항등 행렬은 우리가 마치 숫자 2를 이런 어떤 행렬의 세계에서 1처럼 이해하실 수가 있게 되겠습니다. 그래서 이름도 아이덴티티 매트릭스 항등 행렬이라는 것인데요. 이 역행렬이라는 걸 이용을 해서 마치 분수처럼 어떤 행렬 a에다가 역행렬을 곱해 주게 되면은 네 아이덴티티 매트릭스 항등 행렬을 얻을 수 있다라는 거를 이해를 하시면 되겠습니다. 참고로 항등 행렬의 성질은 이 원래 어떤 벡터 스가 있을 때 항등 행렬을 곱해 주게 되면은 자기 자신이 나오게 됩니다. 그럼 이 개념은 어떤 뜻으로 바라볼 수가 있게 되냐면요. 스라는 벡터가 있을 때 이 스라는 벡터를 a를 통해서 지를 보내고 다시 z에서 역행렬을 통해서 자기 자신으로 돌아온다로 여러분이 이해를 하시면 되겠습니다. 이때 유의하실 점은 역행렬이 존재하려면 반드시 x랑 지가 둘 다 같은 차원의 공간에 있어야만 정의가 되고 연산자에 해당하는 행렬 a가 역행 행렬식이 0이 되면 안 된다라는 사실을 꼭 기억해 주시길 바랍니다. 이때 역행렬을 계산하는 넘파이 코드는요. 네 미니어 알지브라 라이브러리 안에 아이엠브 즉 인버스라는 함수를 이용해 가지고 여러분이 역행렬을 구현해 볼 수가 있게 됩니다. 다음과 같이 스라는 행렬이 이렇게 3개의 행과 3개의 열로 이루어져 있는 행렬을 생각해 보도록 하겠습니다. 다시 말씀드리지만 역행렬을 계산하려면 행의 개수랑 열의 개수가 모두 같아야 됩니다. 이때 넘파이 리니얼 제브라 인버스 함수에다가 이 x라는 행렬을 넣어주게 되면은 다음과 같이 역행렬이 계산이 됩니다. 네 그렇다면 이게 실제로 원래 x에다가 곱해줬을 때 항등 행렬이 나오는지 한번 살펴보시면요. x라는 행렬에다가 이렇게 구한 인버스 매트릭스를 행렬곱으로 계산해 줘봤더니 보시면 어떤 값이 이렇게 쭉 나오게 되는데요. 대각선에 해당하는 값들은 모두 1이 나왔다는 거를 여러분이 살펴보실 수가 있고 대각선에 해당하지 않은 값들은 정확하게 0은 아니지만 10의 마이너스 17승, 10의 마이너스 16승에 해당하는 굉장히 작은 값이 나오는 거를 보실 수가 있게 됩니다. 네 참고로 컴퓨터의 경우에는요 플로팅 넘버 시스템에 쓰이게 되기 때문에 정확하게 0이 나오기는 어렵지만 0에 충분히 가까운 값이 나오는 걸로 우리가 아 이 행렬이 역행렬의 기능을 하는구나라고 여러분이 이해하시면 되겠습니다. 이 역행렬을 이용을 해서 저희가 다양하게 사용해 볼 수가 있는데요. 먼저 우리가 행렬을 사용해 볼 수 있는 가장 흔한 어 애플리케이션 응용은 연립 방정식을 풀어보는 것입니",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 6,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 1006,
      "char_count": 1843
    },
    {
      "id": "transcript_ai_math_2강_행렬이_뭔가요_c007_7fe0d4",
      "content": "[AI Math] 2강_행렬이_뭔가요\n\n다. 네 참고로 컴퓨터의 경우에는요 플로팅 넘버 시스템에 쓰이게 되기 때문에 정확하게 0이 나오기는 어렵지만 0에 충분히 가까운 값이 나오는 걸로 우리가 아 이 행렬이 역행렬의 기능을 하는구나라고 여러분이 이해하시면 되겠습니다. 이 역행렬을 이용을 해서 저희가 다양하게 사용해 볼 수가 있는데요. 먼저 우리가 행렬을 사용해 볼 수 있는 가장 흔한 어 애플리케이션 응용은 연립 방정식을 풀어보는 것입니다. 그래서 우리가 넘파이 리뉴얼 제브라 인버스 함수를 이용하게 되면은 연립 방정식의 해를 구해 볼 수가 있는데요. 연립 방정식의 해를 구하려면은 가장 중요한 조건이 변수의 개수랑 그다음에 식의 개수가 모두 같아야 되겠죠. 이때 변수의 개수에 해당하는 것 그리고 식의 개수에 해당하는 것이 뭔지를 한번 잘 살펴보시면요. 스1 스2 스엠에 해당하는 것이 우리가 변수라고 부르는 것입니다. 그리고 a 1 번 a12 a1 m에 해당하는 것이 이 각각의 변수들의 첫 번째 식에서의 개수라고 보시면 되겠고요. a 1 2 2 2 a2m은 이 각각의 변수들의 두 번째 식에 해당하는 개수라고 보시면 되겠습니다. 그래서 ij라는 것은 제 번째 변수의 아이 번째 식의 개수로 여러분들이 이해하실 수가 있고요. 그때 결과물이 모두 비1 비2 비엔이 되겠습니다. 그냥 자연스럽게 이거를 행렬로 여러분들이 나타내 보실 수가 있겠습니다. 네 각각의 AI 젤들을 우리가 행렬 a로 표시를 할 수가 있고요. 그리고 스1 스2 스엠 변수들을 우리가 열 벡터인 스로 표시할 수가 있고 그리고 비1, 비투비 엔도 우리가 열 벡터인 비로 표시를 할 수가 있게 됩니다. 이때 에에라는 행렬의 원소의 개수는 정확히 행과 열의 개수가 모두 같아야 된다는 점을 이해를 하셔야 됩니다. 왜냐하면 연립 방정식의 해를 구하려면 반드시 시계 개수란 변수의 개수가 모두 같아야 되기 때문에 그렇습니다. 네 그리고 이때 시계 개수란 변수의 개수가 같고 행렬 a의 행렬식이 0이 아니면 우리가 역행렬을 이용해 가지고 이 연립 방정식을 만족하는 해인 스를 다음과 같이 역행렬을 비에다가 곱해서 우리가 구할 수가 있게 됩니다. 즉 이 연립 방정식의 해는 b라는 열벡터에다가 a라는 행렬의 역행렬을 곱해서 우리가 해를 구할 수가 있게 됩니다. 중학교 시간 때 배웠던 연립방정식의 풀이법은 우리가 개수의 숫자를 맞춰줘서 소거해 주는 방식을 사용했었죠. 사실은 이 방식이 이 역행렬을 이용해서 계산하는 방식과 정확히 일치하는 방식입니다. 네 이렇게 지금까지 행렬이 뭔지를 한번 배워보았습니다. 다음 시간에는 행렬에서 사용되는 개념을 좀 더 깊게 공부해 보도록 하겠습니다. 네 그럼 다음 시간에 뵙겠습니다.",
      "metadata": {
        "doc_type": "lecture_transcript",
        "source_file": "2강_행렬이_뭔가요.json",
        "lecture_name": "2강_행렬이_뭔가요",
        "course": "AI Math",
        "lecture_num": "2강",
        "lecture_title": "행렬이_뭔가요",
        "chunk_idx": 7,
        "total_chunks": 8,
        "schema_version": "2.0.0",
        "pipeline_version": "2.0.0",
        "corpus_version": "2025.11.27",
        "processed_at": "2025-12-04T15:35:42Z",
        "source_hash": "sha256:b588b7f6ed743ff843440cbfe826e470919f6c7d0af7af065123dd92ee8ba6ba"
      },
      "token_estimate": 715,
      "char_count": 1332
    }
  ]
}