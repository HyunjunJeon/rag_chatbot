{
  "lecture_name": "[Object Detection] 1.OD Overview",
  "source_file": "[Object Detection] 1.OD Overview_112.mp4_2025-12-04-104635198.json",
  "text": "네 안녕하세요 저는 이제 오브젝트 디렉션 강의를 맡은 송원호라고 합니다. 네 먼저 저희 1강에서는 오브젝트 디텍션을 이해하는 데 필요한 여러 가지의 백그라운드 지식들이 있습니다. 그 백그라운드 지식들에 대해서 한번 짚고 넘어가 보는 시간을 갖도록 하겠습니다. 먼저 이제 첫 번째로 저와 제작 멘토님들 소개를 해드리도록 하고요. 그다음에 오브젝트 디텍션 테스크란 무엇인지 그다음에 리얼 월드에서 오브젝트 디텍션이 어떻게 응용이 되고 있는지 그다음에 많은 연구자들이 이 오브젝트 디텍션을 위해서 어떤 식으로 연구를 했는지 그 히스토리에 대해서 짚어보고 그다음에 이 디텍션 테스크를 어떻게 평가를 하는지 그 이밸류에이션 방법들이 있잖아요. 그 이밸류에이션 방법들에 대해서 이제 말씀드린 다음에 디텍션을 위한 그 라이브러리들이 있는데 그 라이브러리에는 대표적인 라이브러리에는 무엇이 있는지 설명을 해드리도록 하겠습니다. 그다음에 저희 강의에서 이 디텍션 테스크를 어떤 식으로 학습할 수가 있는지 그 커리큘럼이랑 저희가 제공해 드릴 미션들에 대해서 이제 말씀을 해 드리도록 하겠습니다. 네 먼저 이제 저랑 저희 멘토님들 제작 멘토님들 입니다. 바로 이제 오브젝트 디텍션 테스크 쪽으로 넘어가서 네 먼저 이제 컴퓨터 비전에는 정말 여러 가지 테스크가 있죠 그중에서 이제 가장 대표적인 테스크가 클래시피케이션 테스크인데요. 클래시피케이션 테스크란 어떤 이미지 사진이 주어졌을 때 해당 사진이 이제 무엇인지 예측하는 테스크를 의미를 합니다. 가장 대표적으로 이제 0부터 9 숫자를 구분을 하는 앱리스트 테스크가 있습니다. 다음으로 이제 오브젝트 디텍션인데요. 클래시피케이션보다는 좀 더 난이도가 높은 테스크입니다. 어 이미지 속에서 어떤 객체를 식별해 내는 테스크라고 보시면 되겠는데요. 즉 이미지에서 객체가 어디에 있는지 찾고 그 찾은 객체가 무엇인지 이제 식별해 내는 테스크라고 보시면 되겠습니다. 이 클래시피케이션 같은 경우는 이미지 한 장당 레이블 한 장이 이렇게 매핑이 되어 있잖아요 지금 보시면은 이미지 한 장의 캔 이런 식으로 각 이미지들마다 정답이 매핑이 되어 있는 반면 오브젝트 디텍션 같은 경우는 이미지 안에서 이제 정답이 정말 여러 가지가 있을 수가 있습니다. 예를 들어서 오른쪽 이미지 같은 경우는 한 이미지 안에 지금 객체가 두 가지가 있는 케이스죠 페이퍼 컵이랑 플라스틱 뚜껑이 이렇게 두 가지가 있습니다. 지금은 두 가지가 있지만 실제로는 객체가 2개가 있을 수가 있고 3개가 있고 4개가 있을 수가 있고 10개가 있을 수가 있습니다. 그래서 이제 저희가 객체가 몇 개인지 알 수가 없기 때문에 클래시피케이션보다 훨씬 어려운 테스크라고 볼 수가 있습니다. 다음으로는 그 세그멘테이션 테스크인데요. 어 이 중에서 이제 시멘틱 세그멘테이션은 저희 뒤에 현우 님 강의에서 좀 더 자세히 학습하실 수 있을 것입니다. 간단하게 해당 테스트가 무엇인지 설명드리자면 시멘틱 세그멘테이션 같은 경우는 객체의 이 영역을 구분하는 일입니다. 즉 이미지가 존재했을 때 시멘틱한 영역들이 존재를 하게 되고 그 시멘틱한 영역을 서로 다른 영역을 이제 구분하는 그런 테스크를 시멘틱 테스크라고 합니다. 단 같은 클래스를 갖는 그런 객체의 영역은 서로 이제 구분을 하지가 않습니다. 즉 만약에 사람이 이렇게 겹쳐 있다고 했을 때는 겹쳐 있는 부분에 대해서는 구분을 하지는 않습니다. 반면에 이제 인스턴스 세그멘테이션 같은 경우는 시멘틱 세그멘테이션의 어떤 오브젝트 디텍션 영역이 추가된 개념인데요. 객체의 영역을 구분을 하고 그 구분된 영역이 어떤 객체인지까지 이제 예측을 하는 일입니다. 어 이 과정에 있어서는 같은 클래스의 객체도 실제로 구분을 하게 됩니다. 만약에 사람이 여러 명이 이렇게 겹쳐 있다고 했을 때 어 겹쳐 있는 사람 한 명 한 명 한 명을 각각 이제 따로 예측을 해야 되는 것입니다. 어 이렇게 저희가 비전의 대표적인 테스크에 대해서 살펴봤는데요. 저희가 이번 강의에서 다룰 테스크는 오브젝트 디텍션 즉 이미지 안에서 객체를 검출하는 그런 테스크를 이번 강의에서 살펴보도록 하겠습니다. 그렇다면 이제 리얼월드에서는 객체 검출 테스크가 어떤 식으로 활용이 될 수 있는지에 대해서 살펴보도록 하겠습니다. 먼저 첫 번째로 자율 주행이 있습니다. 자율주행 같은 경우는 여러분들이 이제 최근 테슬라 AI 데이 뭐 그런 거 컨퍼런스 같은 거를 보시면 아시겠지만 최근 테슬라는 이제 테슬라의 자율 주행 자동차는 완전한 카메라 기반의 이제 객체 검출을 이용을 해서 개발될 것이라고 선언한 바 있죠. 또 사진 속에서 텍스트를 뽑아내는 어떤 이제 OCR 테스크도 객체 검출을 정말 많이 이용하는 그런 도메인이라고 보시면 되겠습니다. 그다음으로는 이제 캐글 컴피티션에서 오브젝트 디텍션과 관련된 예시인데요. 먼저 이제 왼쪽 그림 같은 경우는 그 휘트를 구분해내는 테스크입니다. 오른쪽 그림과 같은 경우는 그 어떤 흉부 엑스레이 사진이 있을 때 그 사진에서 병이 있을 법한 위치를 찾아내는 그런 테스크입니다. 실제로 이제 의료 도메인에서는 이 오브젝트 디텍션 테스크가 정말 많이 중요해지고 있고 따라서 이에 따른 정말 많은 연구가 이제 같이 수행되고 있습니다. 다음은 이제 CCTV에서 사람을 검출해 낼 수 있는 그런 실 사례가 있는데요. 최근 중국에서는 CCTV로 모든 사람들의 행동을 추적해서 개인 정보와 관련된 어떤 이슈가 발생하고 있기도 하죠. 이처럼 객체 검출은 실제 영역에서 정말 많이 응용이 될 수가 있습니다. 따라서 저희가 객체 검출 테스크를 이해를 하고 관련 알고리즘이 어떻게 발전을 했는지 아는 것은 정말 중요하다고 할 수가 있습니다. 그럼 지금부터 이제 객체 검출을 위해서 많은 연구자들이 어떤 식으로 연구를 했는지 살펴보도록 하겠습니다. 객체 검출 도메인에 있어서 반드시 알아야 할 굵직굵직한 연구들이고 저희 강의에서는 이 모든 알고리즘에 대해서 다룰 예정입니다. 먼저 이제 2013년 RCN 페이퍼부터 최근에 이제 2021년 CVPR에 나온 스윙 t 페이퍼까지 정말 많은 발전이 쭉 이루어져 왔습니다. 다음으로는 이제 객체 검출 테스크를 평가를 할 수 있는 평가 방법들에 대해서 한번 알아보도록 하겠습니다. 객체 검출은 크게 이제 두 가지 측면으로 평가를 할 수가 있는데요. 첫 번째는 얼마나 객체를 잘 검출해냈는지 그 성능적인 요소 두 번째는 얼마나 빠르게 객체를 검출을 했는지 속도적인 요소입니다. 성능적인 요소는 저희가 map를 활용을 하고요. 속도적인 요소는 프피스와 플롭스를 활용을 합니다. 이게 이제 오브젝트 디텍션 테스크 자체가 되게 이제 리얼 월드랑 정말 많이 맞닿아 있잖아요. 그래서 리얼 타임을 많이 요구하는 편이고 그에 따라서 이제 속도 측면이 정말 많이 강조됩니다. 먼저 이제 성능을 평가하는 가장 대표적인 지표인 map에 대해서 설명을 해드리도록 하겠습니다. map 같은 경우는 미 에버리지 프리시전으로서 각 클래스에 대한 에버리지 프리시전을 평균을 낸 것을 의미합니다. 다시 말해서 클래스별로 AP를 계산을 하고 그 계산된 AP를 평균 내는 것을 의미를 합니다. 그렇다면은 이제 에버리지 프레시전이란 무엇일까요? 에버리지 프리시전을 이해하기 위해서는 여러 가지 이제 개념에 대해서 선 이해가 필요한데요. 컴퓨전 매트릭스 프리시전 리콜 그다음에 PR 커브 AP iou 이런 개념들에 대한 성별 이해가 필요합니다. 지금부터 하나씩 한번 살펴보도록 하겠습니다. 네 먼저 이제 컨퓨전 매트릭스인데요. 다음 도표를 보시면 아시겠지만 정말 많이 이제 봤던 그런 차트이죠. 먼저 이제 아시는 분들 많으시겠지만 간단하게 리뷰를 해보고 넘어가도록 하겠습니다. 먼저 이제 실제 정답이 있을 때 모델이 얼마나 잘 예측했는지 평가하고 싶을 때 어 예측과 정답 각각 케이스에 따라서 총 4가지 경우가 존재할 수 있습니다. 먼저 이제 정답을 positive라고 예측했을 경우 정답이 positive인 거를 positive라고 예측했을 경우 정답이 negative인 거를 positive라고 예측했을 경우 정답이 positive인 것을 negative라고 예측했을 경우 이제 정답이 negative인 애들을 negative라고 예측했을 경우 이렇게 크게 이제 네 가지 케이스가 있는데요. 먼저 이제 모델이 파시티브라고 예측한 케이스에 대해서 한번 먼저 보도록 하겠습니다. 모델이 이제 파시티브 즉 1이라고 예측을 했을 때 실제 맞춘 경우와 틀린 경우가 있을 수가 있습니다. 그중에서 이제 맞춘 경우를 트루파시티브라고 하고 틀린 경우를 퍼스트 positive라고 합니다. 반면에 이제 모델이 0이라고 예측을 할 수가 있죠. 모델이 이제 negative라고 예측을 할 수가 있는데 그중에서 이제 맞은 경우와 틀린 경우가 있을 수가 있습니다. 그중에서 이제 맞은 경우를 투루 negative라고 하고 틀린 경우를 퍼스트 negative라고 합니다. 다시 이제 정리해서 설명드리자면은 그 앞에 TPFP랑 FNTN 중에서 이제 뒤에 p나 n이 붙어 있잖아요 이 뒤에 붙은 부분을 모델의 예측이라고 보시면 됩니다. 즉 트루 positive 같은 경우는 아 일단 모델이 일단 positive라고 예측을 했다 그중에서 앞에 트루가 붙어 있으니까 아 positive를 예측한 게 트루구나 맞았구나라고 보시면 됩니다. 반면에 펄스 파시티브 같은 경우는 positive라고 예측했는데 펄스 틀렸구나 아 그래서 실제로 어 0인 애를 1로 예측했구나라고 그런 식으로 이제 이해를 하시면 됩니다. 반면에 이제 트루 negative 같은 경우는 실제로 negative라고 예측했는데 투루 맞았구나 그런 식으로 이제 이 부분에 대해서 이해를 하시면은 헷갈리시지 않을 수가 있습니다. 다음으로는 이제 각각 티피와 프피 뭐 티엔프앤에 대해서 이해를 했으면은 저희가 이제 프리시전에 대해서 이해를 할 수가 있는데요. 프리시전은 다음과 같은 식으로 정의가 될 수가 있습니다. 어 모델의 예측 관점에서 정의한 매트릭인데요. 즉 저희의 모델이 파시티브라고 예측한 모든 케이스들 중에서 맞은 케이스의 비율을 이제 프리시전이라고 정의합니다. 리콜 같은 경우는 다음과 같은 식으로 정의가 되는데 실제 그라운드 트루스 정답 관점에서 볼 수 있는 매트릭입니다. 실제 이제 정답 관점에서 봤을 때 정답인 모드 케이스 중에서 모델이 옳게 예측한 게 어느 정도가 되냐가 이제 리콜이라는 지표가 될 수 있습니다. 예시로 이제 한 번 더 확인해 볼 텐데요. 먼저 다음과 같이 한 이미지의 객체 라이터 객체죠. 라이터가 총 5개가 존재하 예측을 총 파란색이 4개, 빨간색이 4개 총 이제 8개의 예측을 한 이런 케이스에 대해서 한번 생각을 해보도록 하겠습니다. 이 중에서 이제 프리시션 같은 경우는 어떻게 계산을 하면 좋을까요? 앞서 설명은 프리시전은 이제 예측 관점이라고 했잖아요. 모델이 예측을 몇 개를 했냐면은 총 8개를 예측을 했죠. 8개 중에서 몇 개를 맞췄냐면은 어 빨간색 박스가 이제 맞춤 박스인데요. 총 4번을 맞췄습니다. 그래서 이제 8분의 4 프리시전은 이제 0.5가 될 것입니다. 반면에 리콜 같은 경우는 실제 이제 정답 관점에서 보시면 되는데요. 그라운드 트로스가 총 몇 개가 있죠? 5개가 있습니다. 5개의 그라운드 트루스 중에서 몇 개를 찾았죠? 4개를 찾았습니다. 따라서 리콜은 5분의 4 해서 이제 0.8이 되겠습니다. 다음으로는 이제 그 피알 커브에 대해서 설명을 해드리도록 하겠는데요. 프리시전 리콜까지는 정말 많은 분이 이해를 하고 계시는데 피알 커브부터는 어느 정도 약간 개념이 조금 복잡해지기 때문에 이해하는 데 약간 난이도가 있을 수가 있으니 지금부터는 잘 따라와 주시기를 바라겠습니다. 먼저 이제 다음과 같이 저희가 총 10개의 예측을 했다고 합시다. 1번부터 10번까지 총 10개의 예측을 한 거죠. 그다음에 각각의 예측에는 컨피던스와 이게 이제 맞게 한 예측인지 아니면은 틀린 예측인지 트루파시티브인지 퍼스파시티브인지 그 여부를 이제 담고 있습니다. 예를 들어서 1번 예측 같은 경우는 저희가 플라스틱이라고 예측을 했고 72%의 확신 확신을 가지고 아 얘는 플라스틱이야라고 예측을 한 거죠. 그다음에 실제로 봤더니 트루파스티브 맞은 케이스입니다. 반면에 이제 한 버스 positive인 3번을 보면은 플라스틱이야라고 예측을 했는데 41%의 확신을 가지고 플라스틱이라고 예측을 했습니다. 근데 실제 얘가 맞았는지 틀렸는지 봤는데 펄스 파시티브였던 거죠. 이런 식으로 저희가 한 예측들에 대해서 맞았는지 틀렸는지 레이블링이 가능하고 각각의 컨피던스가 존재한다고 했을 때 이를 이제 컨피던스 스코어를 기준으로 이렇게 쭉 내림 차순으로 정렬을 할 수가 있습니다. 내림차순으로 정렬을 했을 때 어 누적 트루파스티브와 누적 펄스 positive를 이제 계산을 할 수가 있습니다. 예를 들어서 지금 같은 경우는 컨피던스 스코어가 8번이 제일 크고 8번 같은 경우는 투루 positive 그다음에 이제 첫 번째 로우에 해당할 때 누적 투루 positive는 1 누적 퍼스 positive는 0입니다. 어 이때 저희가 프리시전과 리콜을 이 누적되어 있는 트루파스티브와 퍼스 positive로 계산을 할 수가 있는데요. 먼저 프리시전을 계산을 하게 되면은 지금 같은 경우는 첫 번째 로우에 한해서는 예측이 아직 한 번이잖아요. 예측이 한 번인 것 중에서 트루파스티브가 몇 개냐면은 하나죠 그러니까 한 번 예측 중에서 한 번 맞춘 케이스입니다. 그래서 프리시전 같은 경우는 1이 되겠습니다. 반면에 리콜 같은 경우는 총 10개의 객체 중에서 몇 개를 맞췄죠 1개를 맞췄죠 그러니까 0.1이 되겠습니다. 그러니까 이제 각각 저희가 모든 예측에 대해서 컴피던스 스코어로 내림차순 정렬을 했을 때 각각 로우에 한해서 누적 트루파스티브, 누적 버스 positive를 계산을 해서 트루파스티브와 퍼스 positive로부터 프리시전과 리콜을 계산을 해 주면 되겠습니다. 이제 두 번째 로우에 대해서 한번 생각을 해볼까요? 이제 컴피던스가 90%죠 90% 컴피던스로 예측을 했을 때 두 번째도 맞췄습니다. 투루 파시티브죠 그러면은 지금까지의 누적 트루파스티브는 몇 개죠? 2개죠? 누적 펄스 positive는 아직 0개입니다. 그러면은 프리시엄 같은 경우는 실제 두 번의 예측 중에서 두 번 다 맞췄죠 따라서 1이 되고 리콜 같은 경우는 총 10개 중에서 아까 하나 맞췄지만 지금은 하나 더 맞췄기 때문에 2개 맞췄죠 0.2가 되겠습니다. 다음 로우에 대해서도 한번 생각을 해 볼까요? 다음 로우 같은 경우는 82%의 컨피던스를 가지고 예측을 했는데 어 레이블링을 해보니 틀렸습니다. 퍼스트 positive인 거죠. 그러면은 세 번째 로우까지 이제 계산을 했을 때 누적 트루 positive는 몇 개죠? 어 2개죠 8번 9번은 맞췄지만 7번은 틀렸으니까 총 2개의 누적 투루 positive가 있고 어 퍼스트 positive는 지금까지 이제 총 하나가 존재하게 됩니다. 왜냐하면은 7번은 틀렸어 으니까 퍼스트 positive가 하나가 이제 카운트가 되겠죠. 그러면은 총 3개 중의 예측 중에서 몇 개를 맞췄죠? 2개를 맞췄으니까 프리시전 같은 경우는 3분의 2인 0.66이 되겠습니다. 반면에 리콜 같은 경우는 세 번째 컨비던스로 예측을 했을 때는 맞추지 못했잖아요 틀렸으니까 리콜 같은 경우는 0.2가 되겠습니다. 마지막으로 그다음 케이스까지 한번 같이 살펴볼까요? 그다음 케이스는 이제 80%의 컨피던스를 가지고 예측을 했는데요. 트루파스티브 맞췄습니다. 그러면 지금 이 4가지 케이스들 중에 한해서 총 몇 개를 맞췄냐면 3개를 맞췄죠 8번 9번 6번 3개를 맞췄고 몇 개를 틀렸냐면은 하나를 틀렸죠 7번 그래서 이제 누적 트루파스티브는 3이 될 것이고 누적 퍼스트 퍼시티브는 1이 될 것입니다. 따라서 이제 프리시전과 리콜을 계산을 했을 때 프리시전은 총 4번의 이 중에서 3개를 맞췄으니까 0.75가 될 것이고 리콜 같은 경우는 0.3이 될 것입니다. 왜냐하면 10개 중에서 3개를 맞췄으니까요. 이런 식으로 이제 모든 예측액들에 한해서 누적 투루 positive와 누적 발수 positive를 계산을 하고 각각에 따른 프리시전과 리콜을 계산을 할 수가 있습니다. 다음과 같이 이렇게 쭉 계산을 했을 때 어 저희가 이제 모든 예측 그 쌍에 한해서 어 프리시전과 리콜을 그러면 다 이제 계산을 할 수가 있잖아요 그러면은 이를 그래프에 찍을 수가 있습니다. 즉 리콜 콤마 프리시전으로 그래프를 이렇게 다음과 같이 찍을 수가 있습니다. 보시면은 첫 번째가 0.1 콤마 1이죠 0.리콜은 0.1이고 프리시전은 1이니까 0.1 콤마 1이 다음과 같이 이제 찍히게 됩니다. 두 번째로는 이제 0.2 콤마 1이죠 오른쪽 보시면은 0.2콤마1 그래프가 이렇게 찍히게 됩니다. 그럼 각각의 이제 그래프를 찍었다고 했을 때 이렇게 찍힌 그래프가 피알 커브라고 저희가 이제 이해를 할 수가 있습니다. 정리하자면 피알 커브 같은 경우는 그 모든 이제 예측에 대해서 컴피턴스 스코어로 쭉 정렬을 했을 때 각각의 누적 트루파스티브와 누적 버스 positive를 계산을 해서 프리시전과 리콜을 계산을 할 수가 있습니다. 그때 리콜 콤마 프리시전으로 그래프를 찍게 되면은 그게 이제 피알 커브가 됩니다. 네 다음으로는 이제 피알 커브에서 다음과 같이 이렇게 선을 긋고 아랫 면적을 계산을 할 수가 있는데요. 어 이 아랫 면적을 계산을 했을 때 이 면적 자체가 에버리지 프리시전이 될 것입니다. 그러니까 에버리지 프리시전 같은 경우는 큐알 커브를 그린 다음에 큐알 커브의 아랫 면적으로 계산을 할 수가 있습니다. 보시면은 에버리지 프리시전의 맥스 값은 1 곱하기 1로 1이 될 것이고 에버리지 프리시전의 최솟값은 어 0 곱하기 0으로 0이 될 것입니다. 따라서 이제 0부터 1 사이의 값을 갖는 그런 매트릭이라고 할 수가 있습니다. 그다음에 이제 엠에피 같은 경우는 다음과 같이 앞선 예제에서는 플라스틱이라는 클래스에서 에버리지 프리시전을 저희가 계산을 했잖아요. 근데 이제 플라스틱 말고 뭐 종이 박스 여러 가지 각각 클래스에 대해서 이런 식으로 AP를 다 계산을 할 수가 있습니다. 이렇게 계산된 AP를 어 평균을 냈을 때 그게 이제 미 레버리지 프리시전이라고 할 수가 있습니다. 그렇다면은 디텍션에서 이제 트 positive와 퍼스트 positive를 어떻게 판단을 할 수 있는지 그 방법에 대해서 한번 생각을 해보도록 하겠습니다. 어 클래시피케이션 같은 경우는 트루파스티브와 퍼스트 positive가 사실상 명확하죠 왜냐하면은 한 이미지에 레이블이 정해져 있고 그다음에 예측도 그냥 한 클래스로 이제 예측을 하기 때문에 레이블을 예측을 했는지 아니면 그 레이블을 못했는지에 따라서 이 예측이 트루인지 이 예측이 이제 펄스인지가 정말 이제 명확합니다. 하지만 디텍션의 경우에는 약간 경우가 다른데요. 디텍션의 경우에는 이제 저희가 어떤 식으로 예측을 하게 되냐면 어 클래스를 직접적으로 이렇게 예측을 하는 게 아니라 이제 클래시피케이션이랑 약간 다르게 객체가 있을 법한 그 바운딩 박스를 이제 같이 예측을 하게 되잖아요. 그렇다면은 어 어떤 그라운드 트루스 박스가 있고 저희가 예측한 박스가 있을 때 어 이 예측한 박스가 과연 이 그라운드 트루스가 맞냐 아니냐를 이제 어떤 판단을 하는 그런 조건이 필요합니다. 예를 들어서 그라운드 트루스의 한 10% 겹쳐 있다고 어 이게 제대로 한 예측일까 아니면 그라운드 트루스의 50% 겹쳐 있다고 이게 제대로 한 예측일까 이런 식으로 이제 어느 정도 겹쳐 있는지에 따라서 트루인지 펄스인지 구분하는 그런 과정이 필요합니다. 또 이게 이제 사람마다 우리 연구에서는 10%를 맞는 예측으로 할래 또 다른 사람은 우리 연구에서는 우리는 90%를 맞는 예측으로 할래 이게 연구마다 다 다르면 안 되잖아요. 그래서 어떤 이제 공통된 기준이 필요한데 그 공통된 기준을 저희가 이제 아이오유로 계산을 할 수가 있습니다. 아이유 자체는 정말 쉬운 개념인데요. 어떤 박스 2개가 있을 때 그 박스에 전체 영역 분에 이제 겹치는 영역으로 계산을 할 수가 있습니다. 그래서 이런 iou 콘셉트를 가지고 이제 실제로 그라운드 트루스와 비교를 해서 저희가 예측한 박스가 어느 정도 겹쳤는지를 기준으로 해서 IO가 0.5 이상일 때 트루 iu가 0.6 이상일 때 트루 이런 식으로 이제 트루 퍼스티브와 퍼스 positive의 기준을 부여를 할 수가 있게 되는 것입니다. 예를 들어서 다음 그림과 같이 그라운드 트루스 박스와 예측 박스가 있다고 한번 해봅시다. 그라운드 트루스 박스는 이제 빨간색 박스가 될 것이고 예측 박스는 저기 이제 파란색 보라색 파란색 박스가 될 것입니다. 그래서 이제 첫 번째 예측 같은 경우 왼쪽 이미지죠. 왼쪽 이미지 같은 경우 IO를 계산을 해봤더니 0.4 그러니까 40%가 나왔다고 합시다. 오른쪽 같은 경우 iou를 계산을 해봤더니 0.660%가 이제 나왔다고 한번 생각을 해봅시다. 근데 이제 저희가 IO가 0.5 즉 50%가 넘는 애들은 트루 50% 아래인 애들은 펄스라고 이제 기준을 정했을 때 왼쪽 40%인 케이스에 대해서는 저희가 펄스라고 레이블링을 할 것이고요. 오른쪽 60%인 케이스에 한해서는 트루라고 이제 레이블링을 할 것입니다. 반면에 iu 402 기준이라고 하면은 왼쪽과 오른쪽 두 경우 모두 트루라고 이제 매핑이 되겠죠. 하지만 만약에 저희가 아이유 70% 이상인 예측에 대해서 트루라고 할 거야라고 만약에 이제 기준을 정하면 두 케이스 모두 틀린 예측이 될 것입니다. 그러니까 저희가 정하는 iu의 기준에 따라서 트루파시티브가 될 수도 있고 펄스 파시티브가 될 수도 있는 거죠. 이렇게 됐을 때 어 map를 만약에 계산을 했을 때 map는 그 트루파스티브와 퍼스트 positive의 누적을 계산을 해서 각각 프리시전과 리콜을 계산을 하잖아요. 그러니까 저희가 정한 이 아이유 기준에 따라서 어 프리시전이 그 트루파스티브와 퍼스트 positive가 달라질 것이고 그러면 그에 따른 프리시전과 리콜의 값이 달라지게 될 것입니다. 따라서 이 디텍션 테스크 같은 경우는 단순하게 엠에피만 사용하는 것이 아니라 엠에이피와 함께 아이유의 기준을 같이 부여를 해야 됩니다. 그래서 엠에피 50 같은 경우는 아오가 0.5 이상인 애들은 트루 아오가 0.25 미만인 애들은 펄스라고 했을 때 그때 엠에피가 어떻게 되냐라는 이제 평가 매트릭입니다. map 60 같은 경우는 그 기준이 0.6이고 map 70 같은 경우는 그 기준이 0.7이 되겠죠. 그래서 이렇게 쭉 계산을 해봤을 때 쭉 이제 생각을 해봤을 때 어 map 95가 이제 가장 엄격한 그런 평가 매트릭이라고 할 수가 있는 거죠. 실제 그라운드 트루스 박스와 95% 이상이 겹쳐야지만 우리는 트루라고 인정을 해 줄 거야라고 이제 하는 그런 기준이니까요. 지금까지 이제 성능 평가를 위한 매트릭에 대해서 한번 살펴봤고요. 지금부터는 속도 평가를 위해서 어떤 매트릭들을 사용하는지에 대해서 한번 살펴보도록 하겠습니다. 먼저 이제 FPS인데요. 이제 초당 처리할 수 있는 프레임의 숫자죠. 그래서 이제 프피스가 크면 클수록 1초에 60프레임을 처리를 할 수 있는 거고 프피스가 24면은 1초에 24 프레임을 처리를 할 수가 있는 겁니다. 이제 크면 클수록 모델이 빠르다고 볼 수가 있겠죠. 두 번째로는 이제 플러스인데요. 플러스 같은 경우는 그 플로팅 포인트 오퍼레이션의 개수를 의미를 합니다. 모델이 얼마나 빠르게 동작하는지 측정하기 위해서 필요한 그런 매트릭인데요. 연산량의 횟수라고 이제 보시면 되겠습니다. 이 플러스 같은 경우는 작으면 작을수록 빠른 모델이라고 보시면 되겠습니다. 예를 들어서 왼쪽 그림과 같이 3 b 2 텐서와 2b 3 텐서를 저희가 이제 행렬 곱을 한다고 했을 때 최종적으로 행렬 곱 결과가 나오게 되는 텐서는 3이 3이잖아요. 이때 3 바이 3 각 셀 당 연산을 살펴보시게 되면은 a 원 곱하기 b11 플러스 a12 곱하기 b21이 될 첫 번째 셀 같은 경우는 1 2 곱하기 21이 될 것입니다. 두 번째 셀 같은 경우는 a11 곱하기 b 1 2 그다음에 a 1 2 곱하기 b 22 결과가 되겠죠. 이런 식으로 쭉 행렬곱을 했을 때 총 9개의 이제 결과가 나오게 될 텐데요. 각 셀 당 연산이 몇 개 있는지 한번 생각을 해봅시다. 먼저 이제 각 셀당 곱셈은 총 2개가 생기죠. 그래서 총 이제 9개의 셀 곱하기 곱셈 두 번 해서 곱셈은 18번이 될 것이고요. 각 셀 당 덧셈은 한 번씩이 있죠. 그래서 총 9개의 셀 곱하기 1 해서 총 9번의 덧셈을 할 것입니다. 따라서 이 플록스 같은 경우는 18 더하기 9인 27이 나오게 될 것입니다. 그러니까 플롭스가 작으면 작을수록 연산의 적은 그런 모델이라고 보시면 되겠습니다. 예를 들어서 이제 콤블루션 네트워크의 플록스 같은 경우는 다음과 같이 계산을 할 수가 있는데요. 먼저 채널 인 채널에서 아웃 채널로 가는 시인과 시 아웃을 곱해주게 되겠죠. 그다음에 커널 커널의 사이즈가 케이바이케라고 하면은 케바케만큼 또 곱하기 연산이 추가가 될 것입니다. 그다음에 이제 높이와 너비에 따른 이제 연산도 이렇게 같이 추가가 될 것입니다. 따라서 이제 컨볼루션 연산의 플록스 같은 경우는 c인 곱하기 c 아웃 곱하기 k 곱하기 k 곱하기 h아웃 곱하기 w아웃이 될 것입니다. 일반적으로 덧셈 같은 경우는 이제 플러스 계산에서 생략을 하는 편입니다. 이런 식으로 이제 디텍션 모델들에 대해서 어떻게 평가를 하는지 저희가 살펴봤고요. 음 지금부터는 디텍션 모델의 대표 라이브러리에 대해서 한번 이제 소개를 해드리도록 하겠습니다. 먼저 첫 번째로는 엠엠 디텍션이라는 라이브러리가 있고요. 엠엠 디텍션 같은 경우는 어 오픈 엠엠 랩에서 디텍션 테스크를 수행하기 위해서 만들어낸 그런 라이브러리라고 보시면 되겠습니다. 실제로 이제 디텍션 외에도 세그멘테이션이나 기타 등등 여러 가지 프로젝트를 같이 병행을 하고 있습니다. 이런 식으로 이제 mm 클래시피케이션 mm 세그멘테이션 기타 등등 이런 프로젝트들이 있습니다. 라이브러리의 구조 같은 경우는 다음과 같이 이런 식으로 동작을 하는데요. 실질적으로는 정말 많은 페이퍼들이 엠앤디텍션 기반으로 해서 많은 연구를 수행을 하고 있습니다. 그래서 실제 이제 에앤디텍션 기업 홈페이지를 방문을 하셨을 때 거기에 없는 모듈들도 이제 다른 연구에 이제 기토 페이지를 방문했을 때 엠엠디텍션으로 구현되어 있는 그런 케이스들을 보실 수가 있습니다. 그다음으로는 이제 디텍터런 투인데요. 디텍트론 2 같은 경우는 이제 페이스북 AI 리서치에서 만들어낸 라이브러리로 파이토치 기반이고 오브젝트 디텍션과 세그멘테이션 포즈 에스티메이션 등을 수행할 수 있게끔 하는 그런 라이브러리라고 보시면 되겠습니다. 그다음으로는 이제 욜로 버전 5 욜로 기반의 모델들을 통합한 라이브러리라고 볼 수가 있는데요. 코코 데이터셋으로 사전 학습된 모델들을 제공을 하고 있고요. 이제 뭐 수천 시간 연구와 개발에 걸쳐서 발전된 오브젝트 디텍션 라이브러리라고 합니다. 뭐 콜랩 케을 도커 에블스 뭐 지시피 등 여러 이제 플랫폼에서 오픈 소스로 제공을 하고 있습니다. 다음으로는 이제 이피션트 댓 페이퍼에 속해 있는 코드 라이브러리인데요. 이피션트 댓 같은 경우는 구글 리서치와 브레인에서 이제 함께 연구한 모델로 그 이피션트 네트워크가 있는데 그 네트워크를 그대로 응용을 해서 만든 오브젝트 디렉션 모델입니다. 이제 원래 라이브러리 같은 경우는 텐서 플로우로 제공이 되어 있는데 이제 기업의 파이토치로 포팅해 놓은 버전의 라이브러리 역시 존재합니다. 어 지금 보시면 아시겠지만 디텍션 같은 경우는 되게 라이브러리가 통합되어 있지 않고 각 연구마다 이렇게 산재되어 있죠 네 다음은 이제 저희가 어떤 식으로 오브젝트 디텍션을 여러분들께 설명을 드릴지 그 저희의 렉처에 대해서 설명을 해 드리도록 하겠습니다. 먼저 전체적인 커리큘럼인데요. 2강 때 그 대표적인 투 스테이지 오브젝트 디텍터들에 대해서 다루고 3강 때 그 앞에서 설명한 라이브러리인 에미 디텍션과 디셉트론 투가 있잖아요. 각 라이브러리에 대해서 설명을 해드리도록 하겠습니다. 그다음에 4강에서는 이 디텍션의 한계를 어느 정도 극복하려고 했던 그 넥 알고리즘들에 대해서 이제 설명을 해드리도록 하겠습니다. 그다음에 5강에서는 투 스테이지를 벗어나 이제 빠른 오브젝트 디텍션을 만들고자 했던 원 스테이지 오브젝트 디텍터들에 대해서 설명을 해드리고요. 그다음 강의에서는 방금 이피션트 라이브러리에서 설명드렸던 그 이피션트 댓 오브젝트 디텍터에 대해서 설명해 드리도록 하겠습니다. 그다음에 7강 8강에서는 이 오브젝트 디텍션의 발전된 지금까지 베이직적인 내용이었다면은 어드반스 된 내용들에 대해서 설명을 해드리고요. 9강에서는 저희가 이제 컴피티션을 진행을 해야 되는데 컴피티션을 진행을 하면서 오브젝트 디텍션에서 어떤 내용들을 알아야 되는지에 대해서 설명을 해드리고 맨 마지막 10강에서는 케글에서 오브젝트 디텍션 테스트가 되게 많은데 몇 가지 대표적인 사례를 소개를 해드리면서 어 디텍션 강의를 마무리하도록 하겠습니다. 저희의 이제 강의 진행 방식은 다음과 같이 투 트랙으로 구성이 되어 있는데요. 먼저 1강부터 10강까지 수업을 들으시고 이론적인 부분에 대해서 학습합니다. 이후 실제 디텍션 컴피티션을 진행을 하면서 이론에서 배운 부분들을 진짜 데이터셋 저희는 이제 재활용 데이터셋을 활용하고 있거든요. 재활용 데이터셋에 적용시켜서 실제 이제 테스크를 수행을 하게 됩니다. 일반적으로 이제 이론과 컴피티션 둘 중 하나만 학습해서 디텍션 테스크를 완벽하게 이해했다라고 보기 어려운데요. 예를 들어서 이론적인 백그라운드 없이 어떤 라이브러리나 코드 기반으로 모델링만 진행을 하게 되면은 단순하게 이제 기계적으로 실험을 반복할 수밖에 없습니다. 이론적인 이해가 있어야 라이브러리를 어떻게 커스텀하고 하이퍼 파라미터 등을 어떻게 바꾸는지 저희가 완벽하게 이해를 할 수가 있습니다. 그렇다면은 이론적인 예만 갖고 갑자기 이제 실제 현업에서 디텍션 테스크를 수행할 수 있을까요? 또는 어떤 컴피티션에서 갑자기 디텍션 테스크를 수행할 수 있을까요? 그거는 되게 어려운 내용인데요. 특히 이제 디텍션 테스크 같은 경우는 엔지니어링적인 측면을 정말 많이 요구합니다. 따라서 실제 컴피티션을 진행을 해보면서 개발적인 능력도 함께 키울 수 있어야 합니다. 더욱이 이제 컴피티션 같은 경우는 그 랭킹 자체가 실시간으로 이렇게 왔다 갔다 반영이 되거든요. 따라서 어느 정도 승부욕을 자극을 하고 자발적인 참여를 훨씬 이제 기대할 수 있습니다. 이에 저희는 컴피티션과 이론 이 투트랙 기반의 이제 강의를 구성을 하게 되었습니다. 다음으로는 저희가 이제 강의를 듣고 이론적인 내용을 학습하면서 저희가 이제 어떤 미션들을 제공할 계획인데요. 캠퍼분들이 반드시 수행하면 좋을 베이징 미션과 어 뭐 반드시 필수적인 건 아니지만 이제 본인이 캠퍼분들께서 디팅션 쪽으로 아예 좀 더 이제 딥하게 파보겠다 하시는 분들을 위해서 제공해 드리는 챌린지 미션이 존재하게 됩니다. 베이징 미션 같은 경우는 강의를 수강하기만 하면은 충분히 따라갈 수 있는 난이도로 설계되어 있고요. 챌린지 미션의 경우에는 강의에 대해서 완벽한 이해를 요구를 하고 어느 정도 추가적인 구글링을 요구를 하기 때문에 어느 정도 이제 스스로 학습을 하셔야 하는 그런 난이도로 구성이 되어 있습니다. 마지막으로 이제 오브젝트 디텍션의 어떤 특성에 대해서 설명을 해드리도록 하겠습니다. 오브젝트 디텍션 같은 경우는 다른 도메인들과는 다르게 통합된 라이브러리가 많이 부족한 편입니다. 아까 앞에서 살펴봤듯이 mm 디텍션 디텍트 1 2 욜로 계열 따로 모아놓은 것들 이피션트 댓 기타 등등 어떤 통합된 라이브러리가 상당히 부족합니다. 따라서 이제 한 라이브러리로 개발된 모델의 이식성이 매우 부족하기 때문에 라이브러리의 의존도가 이제 정말 많이 높은 편입니다. 그래서 만약에 본인이 뭐 mm 디텍션 테스크를 수행한 모델을 디텍트론으로 구현을 하려면 아예 새롭게 다시 구현을 해야 되는 그런 코스트가 존재하는 편입니다. 하지만 이런 모든 모델들을 프롬 스크래치부터 처음부터 구현한다고 하면은 어 정말 많은 공부가 될 수가 있지만 진짜 많은 노력을 요구하기 때문에 실제 컴피티션에서 응용을 하기에는 정말 많이 어려운 부분이 있습니다. 따라서 저희 강의에서는 mm 디텍션이든 디텍트론 2든 욜로 버전 5 코드 셋이든 어떤 라이브러리에 대해서 이해를 정말 많이 요구를 하고 있고 그래서 이제 코딩 능력이 정말 많이 요구되는 그런 도메인이라고 보시면 되겠습니다. 두 번째로 이제 오브젝트 디텍션 자체는 엔지니어링 측면이 매우 강한 도메인인데요. 모델의 이론적인 부분을 이해했다고 해서 모델을 그 리얼 월드의 데이터에 적용하기가 정말 쉽지 않습니다. 해당 모델을 구현하는 데 있어서 정말 많은 개발 능력을 요구하기 때문입니다. 그래서 어떤 모델이 이제 풀고자 하는 문제에 적합한지 그런 실험적인 측면도 많이 해야 되고 그렇기 때문에 이제 엔지니어링 측면을 많이 요구하는 편입니다. 세 번째로 디텍션 파이프라인이 뭐 클래시피케이션보다 훨씬 복잡한 편입니다. 그다음에 네 번째로 이제 높은 성능을 내기 위해서는 무거운 모델들을 정말 많이 활용을 해야 됩니다. 즉 모델을 학습하는 데 있어서 학습에 이제 들어가는 절대적인 시간 자체가 매우 길어서 실험에서 어떤 트라이를 했을 때 그 결과를 보기까지의 그 텀 자체가 매우 긴 편입니다. 그러니까 공부를 막 엄청나게 실험 결과가 빨리빨리 나오면 어 되네 안 되네 바로바로 판단을 할 수 있지만 실질적으로 이 모델이 크기 때문에 바로 판단할 수가 없습니다. 마지막으로 이제 이미지의 레졸루션들이 있는데요. 그 레즈 솔루션이 성능에 정말 큰 영향을 미칩니다. 즉 레졸루션이라고 하면 이미지 해상도 사이즈라고 볼 수가 있는 거죠. 그래서 이제 왜냐하면 디텍션 같은 경우는 작은 객체도 잘 구분을 해야 하기 때문에 이미지 사이즈가 일반적으로 많이 큰 편이고 이에 따라서 이제 연산량 자체가 정말 많아지게 되겠죠. 따라서 한 GPU 배치에 담을 수 있는 이미지 개수가 상당히 적어지는 편이고요. 즉 정리하자면 이론적인 이해도 정말 많이 필요하고 개발적인 능력도 정말 많이 요구하는 그런 도메인이라고 할 수가 있는데요. 하지만 이제 저희 리얼 월드 사회 전반적으로 이제 디텍션에 대한 테스크가 많이 요구되고 있습니다. 또 이에 따라서 디텍션을 제대로 학습하고 이 분야에 이제 전문가가 되기만 한다면은 어 아주 강력한 무기를 가지고 있는 상당히 경쟁력 있는 이제 데이터 과학자가 될 수 있을 것입니다. 지금까지 뭐 강의 자료를 제작하는 데 필요한 레퍼런스는 다음과 같고요. 이것으로 1강을 마무리하도록 하겠습니다. 다음 강의에서 뵙겠습니다. 감사합니다."
}