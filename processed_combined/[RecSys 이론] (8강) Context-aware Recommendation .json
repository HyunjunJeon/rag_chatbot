{
  "lecture_name": "[RecSys 이론] (8강) Context-aware Recommendation ",
  "source_file": "[RecSys 이론] (8강) Context-aware Recommendation _136.mp4_2025-12-04-110124509.json",
  "text": "안녕하세요. 추천 시스템 강의를 맡고 있는 강사 이준원입니다. 이번 시간은 여덟 번째 강의 컨텍스트의 레코멘데이션이라는 이름으로 진행하겠습니다. 기본적으로 추천 시스템 분야는 유저와 아이템 사이의 상호 작용을 모델링하는 컬라버레이트 필터링으로부터 시작한 모델들이 주를 이룹니다. 하지만 이번 시간에는 유저 아이템, 아이디 피처 외에 다양한 부가 정보 즉 컨텍스트 정보를 풍부하게 활용하여 추천을 제공하는 모델들을 위주로 살펴보겠습니다. 네 먼저 컨텍스트 어여 레코멘데이션 문제가 무엇이고 어떤 분야에 활용되는지 주로 어떤 데이터를 사용하여서 모델링을 하는지 살펴봅시다. 다음으로 콘텍스트 어여 레코멘데이션 가운데 대표적인 문제인 CTR 프리딕션 문제 사용되는 이 FM 팩토라이제이션이 머신과 필드어의 팩토라이제이션 머신 FFM의 모델에 대해서 학습합니다. 이 FM과 FFM 모델은 딥러닝이 등장하기 전에 이 분야에서 가장 뛰어난 성능을 보인 머신러닝 모델이고요. 지금 현재도 현업에서 활발하게 사용되고 있습니다. 마지막으로 CTR 예측 문제를 포함하여서 그 외에 다양한 컴퍼티션에서 다양한 캐글 컴퍼티션에서 좋은 성능을 내고 있는 그레디언트 부스팅 머신에 대해서 다뤄보겠습니다. 첫 번째 컨텍스트의 레코멘데이션이 무엇인지 앞에서 다룬 컬래버이트 필터링과 어떻게 다른지를 이해하고 이 테스크가 어떠한 양상으로 발전해 왔는지를 간단하게 살펴보겠습니다. 컨텍스트와 레코멘데이션 문제를 정의하기 이전에 우리가 지금까지 추천 시스템에서 사용했던 데이터는 크게 세 가지로 분류할 수 있습니다. 유저 정보와 아이템 정보 그리고 유저와 아이템의 상호작용 정보 있죠? 우리가 지난 7강까지 학습했던 모델들은 주로 유저의 아이디와 아이템 아이디 정보를 사용하고 그 외에 유저와 아이템의 상호작용 정보를 주로 잘 사용해서 이 모델에 반영하는 컬라버레이트 필터링 기반의 모델이었습니다. 그래서 유저와 아이템의 고유한 아이디 외에 다른 이런 성별이나 연령이라든지 혹은 아이템의 적혀 있는 카테고리나 출시 연도 같은 유저 아이템의 메타 데이터 정보는 사용하지 않거나 혹은 사용하기 어려운 모델들이 주로 많았습니다. 가장 대표적인 CF 컬라버레이트 필터링 모델인 MF 매트리스 팩토라이제이션 모델이죠. 이것을 학습하기 위한 학습 데이터를 기억해 봅시다. 이 유저의 데모 그래픽 혹은 아이템의 카테고리와 같은 정보들 풍부한 정보들이 존재함에도 불구하고 이러한 특성들을 사용할 수 없었습니다. 왜냐하면 매트릭스 팩토라이제이션은 유저와 아이템으로 이루어진 유저 아이템 매트릭스 데이터를 가지고 학습 데이터를 활용했기 때문에 그 외에 다른 정보들은 사용할 수가 없는 모델이었죠. 이와 같이 이 MF의 학습 데이터는 오로지 유저가 어떤 아이템을 소비했다라는 상호작용 데이터만으로 구성되는데요. 이 경우에 상호 작용 정보가 아직 부족하거나 혹은 아예 데이터가 없는 유저 아이템에 대해서 이 엠프 추천 모델을 사용할 경우 좋은 추천을 제공하기가 어렵습니다. 그래서 이러한 문제를 콜드 스타트라고 하는데요. 이제 이 엠프와 같은 모델들은 콜드 스타트에 대한 대처가 어려운 부분이 있죠. 그래서 컨텍스트 어어 레코멘데이션은 유저 아이디 혹은 아이템 아이디 말고 그 유저가 가지고 있는 혹은 아이템이 가지고 있는 다양한 특성들을 추천 시스템에 오히려 반영할 수 있게 발전돼 왔습니다. 컨텍스트 기반 추천 시스템의 경우 유저와 아이템의 상호작용 정보는 가장 중요하기 때문에 당연히 필수적으로 사용하지만 그뿐만이 아니라 해당 상호작용이 일어났던 맥락적 정보 컨텍스트 정보를 함께 사용합니다. 여기서 이 컨텍스트라는 단어 안에는 유저의 부가 정보와 아이템의 부가 정보도 들어가고요. 유저와 아이템 정보 외에 그 추천이 일어났던 그 아이템의 소비가 일어났던 당시의 시간이나 공간적 정보 같은 다양한 정보들이 다 컨텍스트라는 단어로 표현됩니다. 그래서 이 컨텍스트 정보는 서비스와 데이터마다 모두 형태와 사용되는 종류가 다르기 때문에 그러한 피처들을 모두 담을 수 있는 제너럴한 모델이 설계되어야 합니다. 따라서 기존의 CF 기반의 추천 모델이 해결하는 문제와 접근 방법이 달라지고 그에 따라서 데이터를 구성하는 방법도 달라지게 됩니다. 가장 큰 차이점은 유저 아이템 매트릭스의 빈 공간을 채우는 게 아니라 다음과 같이 주어진 x에 대해서 y 값을 추론하는 우리가 보통 일반적인 예측 문제를 접근할 때 어떤 x가 주어지고 그 x에 대한 y 값을 예측하는 문제로 풀게 되죠. 그래서 이런 식의 데이터로 구성을 해야 한다는 것입니다. 이제 아래 데이터가 방금 전 슬라이드의 유저와 아이템 매트릭스의 데이터와 같은 데이터인데요. 이 하나의 로우가 하나의 데이터 포인트가 됩니다. 즉 유저 3이라는 사람이 아이템 1을 소비하고 그 외에 다른 컨텍스트 피처들이 있을 때 그때의 선호도는 3점 이다. 즉 x는 유저와 아이템과 컨텍스트로 이루어져 있고 y는 레이팅을 예측하는 것이죠. 그래서 이러한 형태는 보통 제너럴한 프리딕터의 모델 구조 가 됩니다. 그래서 원하는 만큼 유저 아이템 컨텍스트 그 컨텍스트가 하나가 아니라 되게 다양한 피쳐들이 있을 수 있겠죠. 내가 원하는 만큼 모델을 만드는 사람이 원하는 만큼 컨텍스트 피처를 옆으로 붙일 수 있고요. 그래서 이러한 피쳐를 통해서 결국에 최종 예측하는 값은 유저의 상호작용 정보인 웨이팅이 됩니다. 네 이제 이러한 컨텍스터 레코멘데이션 줄여서 car 이라고 불리는 테스크의 대표적인 분야는 CTR 예측 도메인입니다. 이 CTR 예측 문제는 유저가 해당 아이템이 주어졌을 때 그 아이템을 클릭할 확률을 예측하는 문제입니다. 추천 시스템에서 이제 온라인 에이비 테스트를 한다고 했을 때 가장 많이 사용되는 지표가 매출 혹은 CTR이라고 첫 번째 강의에서 언급했었습니다. 사실 매출이라는 지표는 추천 외에도 다른 요인이 굉장히 많기 때문에 보통 추천 시스템을 적용했을 때 좋아졌다 좋아지지 않았다라는 것을 평가하기 위한 지표는 CTR을 많이 사용합니다. 그 말은 추천 후보 아이템의 예측 CTR이 높은 것을 잘 추천해 준다면은 그에 따른 CTR이 상승할 수 있다는 것이죠. 따라서 추천 시스템에서는 CF 기반의 모델도 사용하지만 CTR 예측 모델을 사용한 추천 시스템도 굉장히 많이 사용하고 있습니다. 그래서 CTR 예측 문제는 예측해야 하는 y 값이 클릭을 했냐 안 했냐 0과 1이기 때문에 바이너리 클래시피케이션 문제라고 볼 수 있습니다. 근데 우리가 원하는 값은 0이냐 1이냐가 아니라 클릭할 확률이기 때문에 0과 1 사이의 확률로 아이템의 CTR이 출력되어야 합니다. 그래서 예측 모델을 다 만든 이후에 그 출력 값을 최종적으로 시그모이드 함수에 통과시켜서 0과 1 사이의 값으로 출력되게 하고요. 그 값이 곧 예측 CTR 값이 됩니다. 이 CTR 예측은 주로 광고 추천에서 가장 많이 사용되는데요. 광고 추천을 잘하면 광고주로부터 돈을 많이 받기 때문에 바로 돈이 됩니다. 그래서 광고 추천이 굉장히 많이 연구되었고 또 중요한 분야 중에 하나가 되었습니다. 이제 광고가 노출된 상황에 다양한 유저 광고 컨텍스트 피처가 존재하고 이 다양한 피처들을 위치하게 사용하여서 씨티알 예측의 정확도를 높이는 테스크가 많이 이루어지고 있습니다. 어떠한 데이터 같은 경우에는 유저 아이디가 아예 존재하지 않는 데이터도 있는데요. 우리가 지금 콜라보레이트 필터링 문제를 푸는 것이 아니기 때문에 유저 아이디가 존재하지 않더라도 다른 유저 피처나 컨텍스트 피처를 사용하여서 해당 아이템의 씨티알을 예측할 수 있습니다. 현업에서는 실제로 유저 아이디를 피처로 사용하지 않는 경우가 광고 추천에서는 굉장히 잦은 일입니다. 네 다음은 가장 기본적인 CTR 예측 모델인 로지스틱 리그레션을 간단하게 언급하고 넘어가겠습니다. 기본적인 선형 모델에다가 시그모이드를 씌운 모델인데요. 이제 우리가 정의한 유저 아이템 컨텍스트 피처들은 이 x아라는 입력 변수로 사용되게 되고 이제 입력 변수에 대한 선형 모델링을 통해서 클릭 예측 확률을 예측하는 가장 기본적인 로지스틱 리액션 모델이 있습니다. 이제 앞으로 배울 다양한 CTR 예측 모델 앞으로 FM이나 FFM 그리고 이 다음 아홉 번째 강의인 딥 CTR 모델 들이 다 이 로지스틱 리그레션으로부터 발전된 것을 기억해 두시기 바랍니다. 이 수식을 보면 로지스틱 리그레션은 어떤 변수 간의 상호 작용을 전혀 모델링 할 수 없습니다. 즉 유저 정보와 아이템 정보 간의 다양한 상호 작용 이 모델에 반영되지 않는다는 것인데요. 추천 모델에서는 그 피처들 간의 상호작용을 모델에서 반영하는 것이 사실 추천 모델뿐만이 아니라 모든 머신 러닝 모델에 대해서는 피처 간의 상호작용을 반영하는 것이 굉장히 중요하기 때문에 단순하게 이렇게 선형 모델 즉 로지스틱 리그레션만 사용하게 된다면은 예측 성능이 굉장히 떨어지게 됩니다. 따라서 아래와 같이 강제로 두 개의 변수를 상호작용을 만들어서 이 상호작용을 카테시안 프로덕트라고 하는데요. 카테시안 프로덕트를 만들어 가지고 강제로 두 개의 변수 상호작용을 w아제라는 파라미터로 학습하게 합니다. 이것을 폴리노미얼 모델이라고 하는데요. 즉 1차 항 말고 2차 이상의 항이 존재한다는 것을 의미합니다. 가장 큰 이 모델의 취약점은 파라미터 수가 급격하게 증가한다는 점입니다. 세컨오더 폴리노미얼 모델만 확인해도 파라미터 수가 엔 곱하기 n 즉 n의 제곱 배로 증가하게 되는데요. 그래서 이러한 상호작용을 단순하게 카테시안 프로덕트로 표현하는 것은 한계가 있습니다. 그래서 이 한계를 극복한 모델이 우리가 이후에 배울 프엠과 프프엠이고 이 프엠과 프엠의 모델에 대한 자세한 내용은 이 뒤에 있는 파트에서 다루겠습니다. 자 그렇다면 씨티알 예측 모델에는 다양한 유저 아이템 컨텍스트 피처 등을 사용할 수가 있는데요. 이제 이러한 피처들은 보통 두 가지 분류로 나눌 수가 있습니다. 첫 번째는 댄스 피처인데요. 벡터로 표현했을 때 비교적 작은 공간에 밀집되어 분포하는 수치형 변수를 의미합니다. 유저가 아이템에 매긴 절대 평점 1점부터 5점까지 있는 평점을 피처로 사용한다면 댄스한 피처가 될 수 있고요. 그리고 어떤 수치로 나타날 수 있는 다른 기온이나 시간과 같은 정보도 수치형 벡터 댄스한 피처가 되겠죠. 그와 그의 반대로 스파스한 피처 벡터로 표현했을 때 비교적 넓은 공간에 분포하는 피처가 스퍼스 피처입니다. 사실 이 두 개념은 여러분들이 앞선 강의에서도 충분히 많이 배웠을 텐데요. 유저의 아이템의 아이디 같은 경우라든지 혹은 요일이나 뭐 키워드 태그 같은 정보들이 다 스프레스한 피처입니다. 요일과 같은 경우에는 월요일부터 일요일까지 총 7개의 공간이 있기 때문에 수요일 금요일이 다음과 같이 원핫 인코딩으로 표현될 수가 있고요. 이제 키워드나 태그 같은 경우에는 아이템 하나가 1개가 아닌 2개 이상의 키워드나 태그를 가질 수도 있죠. 따라서 이 경우에는 멀티샷 인코딩으로 표현되긴 하지만 여전히 그 그 피처는 스퍼스 한 피처입니다. 이제 이 두 개의 피처를 봤을 때 씨티알 예측 문제에서 가장 많이 사용되는 피처는 이 위에 댄스 피처가 아니라 대부분 스퍼스 피처입니다. 다음 공개되어 있는 씨티알 예측 모델링을 위한 데이터를 살펴봅시다. 이제 이 데이터를 살펴보면 대부분의 피처가 스퍼스 한 피처라는 것을 알 수 있는데요. 이 하나하나의 컬럼이 피처를 의미합니다. 이제 공개 데이터 셋이기 때문에 모두 암호화가 된 해시 값으로 이루어져 있긴 하지만 이 전체 데이터 가운데 전체 피처 가운데 파란색으로 씌워져 있는 모든 피처들은 다 카테고리컬 데이터 즉 스파스한 피처로 나타나야 한다는 것입니다. 뭐 사이트의 아이디라든지 광고가 노출된 도메인 같은 것들은 다 스트링 값이고 이 스트링 값을 모델의 입력 변수를 사용하기 위해서는 보통 원핫 인코딩으로 표현해야 하기 때문에 각각의 피처들은 다 스프레스 한 피처로 표현되게 됩니다. 그래서 CTR 예측 문제의 데이터를 모두 다 원핫 인코딩만으로 표현하여서 모델링을 할 경우에는 학습 파라미터 수가 그 차원의 개수만큼 생기기 때문에 아주 많아질 수 있고, 학습 데이터에 등장하는 빈도에 따라서 특정 카테고리나 특정 피처는 과적합되거나 즉 오버 피팅 되거나 언더피팅 될 수 있습니다. 이를 막기 위해서 원아 인코딩을 보통 그대로 사용하지 않고 피처 인베딩을 합니다. 이 인베딩도 사실 이전 시간에 굉장히 많이 배웠죠. 우리가 5강에서 배웠던 아이템 투 백이나 혹은 자연어 처리에 사용되는 LDA와 같은 토픽 모델링이나 혹은 이제 버트와 같은 프리트 랭귀지 모델의 인베딩도 다 피처를 임베딩하는 기법이고 이 인베딩을 CTR 예측 모델의 피처 데이터로 사용할 수 있습니다. 그래서 우리가 앞으로 배울 CTR 모델 공통점이 있는데요. 첫째로는 스퍼스 한 피쳐를 인베딩을 통해 잘 표현하는 것 인베딩, 둘째로는 이 스프레스 한 피처들 간의 상호작용을 모델 설계에서 고려한다는 점입니다. 상호작용은 인터랙션이 되겠죠. 그래서 이 두 가지를 어떻게 모델에서 잘 표현할 것인가를 생각하시면서 이 이후의 내용들을 배우시면 크게 도움이 될 것입니다. 그래서 간단하게 컨텍스트 레코멘데이션 추천 알고리즘의 변천사를 살펴보면은 먼저 딥러닝 이전 AI에서는 로지스틱 리그레션과 SVM 모델이 등장하였고요. 그 이후에 매트리스 팩토라이제이션과 함께 추천 시스템 연구 분야가 크게 발전하였습니다. 그다음에 이제 컨텍스트의 레코멘데이션이라는 개념이 등장하고 전통적인 머신 러닝 모델들과 인베딩을 결합한 기법들이 많이 사용되었습니다. 이제 그 이후에 우리가 배울 팩토라이제이션 머신과 필드 어이어 팩토라이제이션 머신이 출연하였고 이 두 가지 모델에 대해서 자세히 살펴보겠습니다. 네 이번 파트는 팩토라이제이션 머신 모델과 해당 논문에 대해서 리뷰하겠습니다. 이 FM 모델의 등장 배경과 장점을 이해하고 그 원리가 어떻게 작동하는지 살펴보겠습니다. 팩토라이제이션 머신은 2010년에 동일한 이름의 논문을 통해 발표된 모델입니다. 당시 ML 모델 가운데 가장 많이 사용되었던 이 SVM과 MF와 같은 팩토라이제이션 모델의 장점을 결합한 논문입니다. 이 팩토라이제이션 모델의 대표적인 모델이 바로 아까 4강에서 배웠던 지난 4강에서 배웠던 MF입니다. 먼저 FM의 등장 배경입니다. 이 딥러닝이 등장하기 전에는 서포트 벡터 머신이 가장 ML 분야에서 많이 사용되는 모델 중에 하나였습니다. 커널 공간을 사용한 논 리니어 데이터셋에 대해서 이 SVM이 가장 높은 성능을 보였습니다. 모델링을 하기에 가장 어려운 게 이런 비선형 데이터 셋이었는데요. 랜덤 플러스 같은 모델도 괜찮은 성능을 그 당시에 냈지만 SVM 즉 커너를 사용한 SVM이 당시에 가장 좋은 성능을 보였습니다. 이제 그럼에도 불구하고 콜라버레이트 필터링 환경에서는 MF 계열의 모델이 SVM보다 더 좋은 성능을 내왔습니다. 이 CF 문제 CF 환경이라는 것은 앞에서 많이 다루었는데요. 유저 아이템에 대한 평점을 예측하는 것입니다. 이 CF 환경은 유저 아이템이 굉장히 개수가 많기 때문에 굉장히 스퍼스한 데이터로 이루어져 있고 이런 스파이스한 데이터는 SVM이 좋은 성능을 내지 못하는 분야였습니다. 하지만 MF 모델은 여러분들이 잘 아시다시피 특별한 환경과 특별한 데이터에 대해서만 적용할 수 있는데요. 그 특별한 환경이랑 아 아래와 같이 주어진 스가 유저 아이템일 때 예측해야 되는 것이 레이팅 이렇게 구성된 데이터를 말하고요. 이 데이터에 대해서만 엠프 모델링이 가능했습니다. 그래서 본 논문 팩토라이제이션 머신이라는 논문은 SVM과 MF 모델의 장점을 결합할 수 없을까라는 아이디어에서 시작했습니다. 자 그래서 다음은 FM 모델의 수식을 나타냈습니다. 먼저 입력 변수는 x1부터 xn 총 n개의 변수가 존재하고요. 이 FM에서 학습하는 파라미터는 먼저 글로벌 바이어스가 있고요. 그리고 각각의 변수마다 대응되는 1차 파라미터 WI가 존재합니다. 그리고 제일 중요한 부분이 바로 이 두 번째 텀 팩토라이제이션 텀입니다. 여기서 학습하는 파라미터는 VI와 VJ이고 이 VI와 VJ는 스칼라 값이 아니라 k 차원의 벡터로 이루어진 파라미터입니다. 그래서 XI와 xj가 상호작용을 할 때 그 XI에 해당되는 VI x 제에 해당되는 VJ가 각각 곱해져서 상호작용 즉 피처 간의 상호작용을 모델링하고 있습니다. 이 둘의 곱은 스칼라 곱 즉 내적을 의미합니다. 이제 이 수식과 앞서 다루었던 로지스틱 리그레션을 비교해 보도록 하겠습니다. 이 아래에 있는 수식이 로지스틱 리그레션의 수식인데요. 앞에 있는 이 부분이 로지스틱 리그레션과 동일함을 알 수 있습니다. 그런데 팩토라이제이션 머신은 뒤에 두 피처의 상호작용을 표현할 수 있는 팩토라이제이션 텀이 추가된 것이죠. 로지스틱 리그레션은 아까 설명한 대로 두 피처의 상호 작용을 모델링 할 수 없다고 말씀드렸습니다. 자 그리고 두 피처의 상호 작용을 강제로 카테시안 프로덕트를 만들어 가지고 이 wij라는 파라미터를 정의한 모델이 바로 이 폴리노미얼 모델이었습니다. 이제 이 두 수식을 비교해 보면은 이 앞에 있는 글로벌 바이어스와 1차 텀은 동일하지만 두 상호작용을 모델링하는 텀이 달라짐을 알 수 있습니다. 이 폴리노미 모델은 XI와 xj의 상호작용을 wij라는 하나의 파라미터로 표현했다면은 FM 같은 경우에는 XI와 xj의 상호작용을 각각 VI와 v제 즉 k 차원의 팩토라이제이션 파라미터로 표현하여서 좀 더 일반화시켰습니다. 자 그렇다면 이 FM 모델을 가지고 스파스한 데이터를 직접 예측해 보겠습니다. 우리가 제일 많이 다루었던 제일 익숙한 데이터는 바로 컬래버레이트 필터링에서 다루었던 유저와 영화 아이템에 대한 평점 데이터입니다. 이 유저 아이템 매트릭스에서 다루던 평점 데이터는 대표적인 하이 스프레시티 스프레시티가 굉장히 높은 데이터라는 것입니다. 그 데이터를 한번 보시면 이 아래 데이터가 여러분들이 잘 아시는 유저와 아이템 아이디에 대해서 평점이 주어져 있는 데이터입니다. 일반적인 CF 문제 입력 데이터와 같죠 이제 우리는 이 데이터를 일반적인 제너럴 프리딕터 가 소화할 수 있는 스와로 바꿔서 이 아래와 같이 표현해 보도록 하겠습니다. 일반적인 입력 데이터로 바꾸면 여기 있는 유저 원의 영화 2가 5점 평점을 갖는다는 것을 이렇게 표현할 수 있습니다. 그래서 이 처음에 있는 앞에 유의 차원이 유저 전체가 되고요. 뒤에 있는 이 m이 영화 전체의 차원이 됩니다. 그래서 유저 1이 영화 2를 봤을 때 5점을 매겼다는 것은 유저 1에 해당하는 원 핫 인코딩이 1 유저 2에 해당하는 원화 인코딩이 1이고 최종 예측값은 5다. 마찬가지로 유저 3은 세 번째 차원이 1이고 영화 1은 첫 번째 차원이 1인 이것이 x가 되겠고요. 얘가 y가 되겠죠. 그래서 입력 값의 차원이 전체 유저와 아이템 수만큼 증가한다는 것입니다. 그런데 이 데이터셋을 보시면 아주 적은 변수만 1이고 나머지 모두 다 0이죠. 이제 이러한 데이터가 바로 하이 스프레시티 데이터라는 것입니다. 네 그렇다면 프엠에서 가장 중요한 것은 이 스파스한 피처들의 인터랙션이 어떻게 학습되느냐입니다. 다음 예시를 통해 살펴보겠습니다. 먼저 유저 a를 기준으로 유저 a가 이미 봤던 영화들은 여기 데이터 3개에 표현되어 있습니다. 이 유저 a에 해당하는 영화 하나 둘 세 개 즉 이 유저 a는 ti와 NHSW 총 3개의 영화에 대해 평가를 5점 3점 1점으로 진행했지만 ST에 대한 영화 ST 영화에 대한 평가는 내리지 않았습니다. 그래서 우리는 이 모델을 통해서 유저 a의 ST에 대한 평점을 예측하고 싶은데요. 어떻게 예측값을 구할 수 있는지 보겠습니다. 자 이 둘의 상호 작용을 구하기 위해서는 여기 있는 데이터를 가지고 a라는 유저와 에스티라는 영화에 대한 학습 파라미터가 학습될 텐데요. 그 파라미터 가운데 제일 중요한 것이 바로 이 팩토라이제이션 파라미터입니다. 그래서 이 a에 대한 팩토라이제이션 파라미터와 ST에 대한 팩토라이제이션 파라미터가 어떻게 학습되는지를 살펴보면 이 둘이 상호 작용을 했을 때 예측 값이 정확하게 나올 것이다라는 것을 확인할 수 있겠죠. 먼저 이 VST 영화 ST에 대한 팩토라이제이션 학습 파라미터 같은 경우에는 이 ST라는 영화가 유저 b와 유저 c가 이미 평가를 했음을 알 수 있습니다. 그리고 또 유저 b와 c는 동시에 스블라는 영화를 같이 평가했습니다. 그래서 유저 b씨가 동시에 스티와 스블 영화를 보았기 때문에 이 스티라는 영화가 sw에 비해서 상대적으로 어떤 특징을 가졌는지가 학습될 것이고요. 그 학습을 통해서 이 VST가 적절하게 학습이 되겠죠. 반대로 이 vaa에 대한 팩토라이제션 파라미터의 경우에도 보시면은 유저 a가 평가했으면서 동시에 유저 BC도 같이 평가한 영화가 존재합니다. 바로 이 sw라는 영화인데요. 이 sw라는 영화는 유저 a b c가 동시에 같이 평가했죠. 그래서 이 데이터를 학습하게 되면은 유저 b c와는 또 다른 유저 a의 특징이 이 VA라는 팩토라이제이션 파라미터에 학습이 될 것입니다. 그래서 이 둘의 인터랙션 데이터는 없지만 여기에 있는 다른 데이터를 통해서 각각의 팩토라이제이션 파라미터가 학습이 잘될 것이고 그 파라미터를 통해서 최종적으로 유저 a의 아직 보지 않은 영화 ST에 대한 평점 예측이 정확하게 구해집니다. 여기서는 유저와 아이템의 예시만을 들었지만 또 다른 장점은 이 뒤에 있는 부분인데요. 유저 아이템 아이디 외에 뒤에 있는 다양한 콘텍스트 정보를 계속 붙일 수 있다는 점입니다. 그리고 이 서로 서로의 인터랙션들 이 둘의 인터랙션 말고도 이들의 인터랙션 그리고 이 안에서의 인터랙션들도 다 FM에서 모델링이 된다는 것이죠. 그래서 이렇게 스프레스 한 데이터셋에 대해서 FM은 효율적으로 피처 간의 인터랙션을 표현하고 좋은 예측 성능을 보입니다. 마지막으로 2개 모델 SVM과 MF의 장점을 결합한 모델이 FM이라고 했는데요. 각각의 모델에 비해서 에프엠이 어떤 것이 좋은지 어떤 장점을 가지고 있는지 정리하면서 프엠 모델의 설명을 마치도록 합니다. 먼저 에브엠 같은 경우에는 어 스파스한 데이터에 대해서 예측 성능이 나쁘다고 했는데요. 그에 비해서 에프엠은 굉장히 스파스한 피처를 가지고도 높은 예측 성능을 보이고 있습니다. 또한 자세히 설명하진 않았지만 sv엠에 비해서 FM은 학습할 때 선형 복잡도를 가지기 때문에 학습 데이터가 굉장히 많더라도 이 모델은 빠르게 학습이 됩니다. 반면에 에브엠 같은 경우에는 학습 데이터가 굉장히 많이 늘어날수록 학습 시간은 이 5m보다 더 많이 증가하기 때문에 학습 데이터가 아주 많은 데이터에 대해서는 에비엠 학습을 하기가 어렵습니다. 굉장히 오래 걸리기 때문이죠. 그다음에 매트리스 팩터라이제이션과도 비교해 보면 이제 매트리스 팩터라이제이션은 오로지 콜라버레이트 필터링 환경으로 구성된 데이터만 소화할 수 있었는데요. 이 FM 같은 경우에는 콜라버트 필터링 형태의 모양이 아닌 다양한 예측 문제에도 활용 가능한 일반적인 제너럴 프리딕터임을 아까 설명드렸습니다. 그래서 엠프와 비교했을 때 유저 아이디와 아이템 아이디만 피처로 사용하는 것이 아니라 그 외에 다른 부가 정보들 즉 컨텍스트 정보들을 입력 값으로 사용하고 더 정확한 예측을 할 수 있습니다. 네 그래서 여기까지가 에프엠 모델에 대한 내용이었고요. 다음은 프프엠 필드 어웨어 팩토라이제이션 머신입니다. 이 모델의 원리를 이해하고 방금 전에 배웠던 프엠 모델과의 차이점을 살펴보도록 하겠습니다. 네 본 논문은 FM을 변형시킨 모델인 FFM을 제안하였고 이 FFM 모델은 CTR 예측 데이터셋 즉 컨텍스트어 레코멘데이션에서 가장 활발하게 풀리고 있는 그 문제에 대해서 높은 성능을 보였다고 이야기하고 있습니다. 먼저 앞서 설명했듯이 FM은 예측 문제 두루두루 적용 가능한 제너럴한 프리딕터 모델이라고 말씀드렸고요. 특히 스파스한 데이터에 아주 강력하다고 했는데요. 우리가 처음에 CTR 예측 모델 문제를 이야기할 때 CTR 예측 문제의 피처들은 대부분 스파스하다고 했죠. 따라서 이 CTR 예측 문제에서 FM은 굉장히 좋은 성능을 내고 있었습니다. 이제 여기서 필드 어웨어라는 말이 FM 앞에 붙었고요. 이게 FFM인데요. FFM은 FM을 발전시킨 모델로서 이 pitf라는 모델에서 아이디어를 얻었습니다. 그래서 이 pitf 모델에 대해서 간단히 설명을 드릴 텐데요. pitf 모델은 매트리스 팩토라이제이션 모델을 발전시킨 모델인데요. 어떻게 발전시켰냐면은 매트리스 팩토라이제이션 같은 경우에는 2차원 매트릭스로 유저 아이디와 아이템 아이디로 구성되어 있지만 이 pitf는 텐서 팩토라이제이션 즉 3차원으로 엠프를 확장시킨 모델입니다. 그래서 pitf에는 유저 아이디와 아이템 아이디에다가 태그 아이디까지 총 3개의 필드로 구성되어 있습니다. 그래서 이 pitf는 유저와 아이템 인베딩 외에 태그의 인베딩까지 총 3개의 인베딩을 학습하게 됩니다. 3차원 텐서이기 때문에 원래 MF는 이 둘의 곱으로만 이루어져 있지만 3차원 텐서 같은 경우에는 유저와 아이템 아이템과 태그 태그와 유저 각각의 인터랙션이 모두 가능한데요. 이제 여기서 pitf의 핵심적인 아이디어는 유저가 아이템이랑 곱해질 때의 레이턴트 팩터와 유저가 태그와 곱해질 때 레이턴트 팩터를 서로 다른 레이턴트 팩터 즉 서로 다른 인베딩을 정의하여서 구했다는 것입니다. 하나의 인베딩만을 사용해서는 서로 다른 필드와의 인터랙션을 표현하기에는 그 인베딩의 표현력이 부족했기 때문에 곱해지는 반대편의 필드가 무엇인지에 따라서 서로 다른 인베딩을 사용하는 것입니다. 그리고 프프엠은 방금 얘기했던 이 pitf에 서로 다른 레이턴트 팩터 즉 서로 다른 인베딩을 사용하는 그 아이디어를 일반화하여서 여러 개의 필드에 대해서 이 레이턴트 팩터를 정의한 것입니다. pitf는 필드가 3개지만 FFM은 사용자가 정의하는 개수만큼 필드를 늘려서 인베딩에 인터랙션을 시킬 수 있다는 것입니다. 앞서 말한 대로 FFM은 주어진 입력 변수에 이 필드라는 속성을 추가합니다. 그리고 필드별로 서로 다른 레이턴트 팩터를 가지도록 하고 그렇게 해서 팩토라이즈를 합니다. 기존의 FM은 하나의 변수 x1에 대해서 k g로 팩토라이즈 하는 vk라는 하나의 팩토라이제이션 파라미터만을 가졌지만 FFM은 필드가 총 2개 있다고 했을 때 프개의 팩토라이제이션 파라미터를 갖습니다. 자 그렇다면 필드를 보통 어떻게 정의하고 어떻게 나눌까요? 이제 필드는 모델을 설계할 때 사용자가 정의하는 것입니다. 이 모델이 알아서 정해주는 것이 아니라 사용자가 어떤 변수를 같은 필드로 묶을지를 정해야 하는데요. 보통 이제 유저나 아이템이나 콘텍스트 피처를 사용할 때 보통 우리가 시멘틱하게 성별이나 디바이스 같은 피처를 사용한다고 하지만 이 성별은 사실 남자 여자 그리고 디바이스 같은 경우에는 뭐 안드로이드 아이폰 같이 2개 이상의 피처 공간으로 표현하게 되겠죠. 그러면 그 두 개 이상의 변수가 하나의 필드가 되는 거죠. 그래서 성별 필드 디바이스 필드 운영 체제 필드 될 수 있고요. 아이템 같은 경우에는 카테고리 필드 등이 존재할 수 있는 거죠. 카테고리가 하나가 아니라 10개가 있으면은 그 카테고리는 10개의 원핫 인코딩으로 표현돼야 되기 때문에 10개의 변수로 표현되고요. 그 10개의 변수가 하나의 카테고리 필드에 포함되는 것이죠. 그래서 이 외에도 CTR 예측에는 훨씬 더 다양한 피처가 사용되는데요. 보통 피처의 개수만큼 필드를 정의하여서 사용하게 됩니다. 자 다음은 FFM의 수식을 다음과 같이 표현하였는데요. 보시면 이 앞에 있는 이 부분은 이제 리니어한 부분 로직스 리그레션 부분이고요. 이제 가장 큰 차이는 FM과 비교했을 때 여기 팩토라이제이션 더이 가장 큰 차이가 됩니다. 기존의 FM은 2개의 xixj 즉 2개의 변수가 인터랙션 할 때 각각에 해당하는 k 차원 내 파라미터를 내적이 되는 형태로 이 모델에서는 그 인터랙션을 표현하였는데요. 이제 보시면은 FFM 같은 경우에는 단순히 XI에 해당하는 VI가 아니라 이 뒤에 f제가 포함되어 있습니다. 이것은 무엇이냐 XI 그러니까 곱해지는 반대편인 xj의 필드에 해당하는 팩토라이제이션 파라미터를 사용한다는 것이죠. 그래서 이 하나의 변수는 총 2개의 필드를 갖고 각 필드별로 팩토라이제이션 파라미터가 정의되는 것입니다. 수식이 좀 복잡할 수 있으니 다음 슬라이드에서 예시를 통해 좀 더 쉽게 이해해 보겠습니다. 다음과 같은 광고 클릭 데이터가 존재하고 이제 이 데이터를 FM과 FM FFM 모델을 사용하여서 각각 표현해 보겠습니다. 먼저 좌측에 있는 FM인데요. FM은 필드가 존재하지 않기 때문에 각각 하나의 변수에 대해서 하나의 팩토라이제이션 파라미터만 존재합니다. 그래서 이 왼쪽에 이 수식을 표현해 보면은 글로벌 바이오스가 있고요. 각각의 변수가 하나씩 있기 때문에 ESPN 블크 블메일 이 부분은 1차 항이죠. 이제 이 뒤에 있는 부분이 팩토라이제이션 텀인데요. 각각의 변수에 해당하는 팩토라이제이션 파라미터가 선택돼서 이 둘이 내적으로 곱해지게 됩니다. 반면에 프프엠은 이 앞에 있는 글로벌 바이어스와 1차 텀은 똑같지만 이 뒤에 있는 팩토라이제이션 텀이 다소 복잡하게 되어 있습니다. 자 요 텀과 이 텀만을 비교해 보도록 하겠습니다. 이제 FM에서는 이 ESPN이라는 변수에 해당되는 파라미터가 단순히 vesp엔 하나였고 그 ESPN이 반대편인 나이키와 곱해지게 됐는데요. 이 에프엠에서는 먼저 확인해야 될 게 이 ESPN이라는 피처 변수는 퍼블리셔 필드에 속해 있고 나이키라는 변수는 광고주 에드벌 타이스 필드에 속해 있고 이 메일은 성별 필드에 속해 있음을 사용자가 지정을 했습니다. 자 그 상황에서 이 ESPN과 나이키의 인터랙션은 ESPN의 반대편 곱해지는 나이키가 바로 에드벌 타이스 필드이기 때문에 브이피엔 콤마 에 즉 2스피엔 변수면서 에드벌 타이즈 필드가 곱해진다는 의미인 이 파라미터를 사용하게 됩니다. 반대로 이 나이키 같은 경우에는 반대편 곱해지는 ESPN이 바로 퍼블리셔 필드에 속해 있기 때문에 브나이키 콤마 피라는 파라미터를 사용하여서 팩토라이제이션을 합니다. 그래서 이렇게 곱해지는 반대편 즉 인터랙션이 일어나는 반대편 변수의 필드를 고려하여서 팩토라이제이션을 수행하기 때문에 그래서 이름이 바로 필드 어웨어 팩토라이제이션 머신인 것입니다. 그래서 에프엠 모델은 주로 CTR 예측 문제에 많이 사용되고 이 문제 데이터의 대부분은 카테고리컬 피처라고 언급하였습니다. 그래서 카테고리컬 피처는 보통 같은 피처 그룹을 같은 필드로 묶어서 정의한다고 했습니다. 그래서 에프엠 같은 경우에는 필드가 필요 없지만 이 아래에 있는 에프엠은 각각의 변수가 속한 피처 그룹을 필드로 정의합니다. 그래서 이스피에는 이 피처가 퍼블리셔 피처였기 때문에 퍼블리셔 필드라고 정의하였고요. 이 뒤에 있는 것도 마찬가지로 각각의 피처가 속해 있는 필드를 사용하였습니다. 문제는 뉴메릭 피처인데요. FFM은 모든 변수가 반드시 어떤 필드에 속해야 하는데요. 실수 피처 같은 경우에는 필드에 할당하기가 다소 부족합니다. 하나의 피처가 0 콤마 1 같은 원 핫 인코딩으로 표현되는 것이 아니라 그냥 하나의 변수의 실수 값을 갖기 때문에 첫 번째 방법은 더미 필드를 사용하는 것입니다. 이 오른쪽에 있는 각각의 피처와 이 값들이 모두 예측 모델에 사용돼야 되는 입력 변수인데요. 더미 필드 같은 경우에는 그냥 하나의 변수에 하나의 필드만을 할당하고 그 외에 다른 변수는 이 에알이라는 필드를 사용하지 않습니다. 즉 피처 1개당 하나의 필드만을 할당하기 때문에 실제로 이 필드는 큰 의미를 가지진 않죠. 그렇기 때문에 더미 필드라고 명명을 하였고요. 두 번째 방법은 이 각각의 실수 피처를 어떤 n 개의 구간으로 나누는 디스크리타이즈 방법입니다. 그러면 이제 이 실수 값이 n 개의 구간으로 나눠지기 때문에 n 차원의 원핫 인코딩으로 표현될 것이고 그 n 차원의 원핫 인코딩은 총 n개의 입력 변수가 되겠죠. 그래서 그 값을 하나의 AR 필드 hidx라는 필드로 매핑하고 그 n개의 변수를 하나의 필드로 사용하여서 FFM 모델링을 수행합니다. 그래서 이 두 가지 방법은 모두 정답이 있는 것은 아니고 각 피처가 가진 특징을 적합하게 고려하여서 선택하시면 됩니다. 그래서 논문의 최종 결과입니다. 이 논문에서는 우리가 다루었던 4가지 모델을 모두 비교하고 있습니다. 이 LM이 바로 로지스틱 디렉션 기본적인 선형 모델이었고요. 이 폴리 2가 두 개의 변수에 대한 상호작용을 강제로 카테시안 프로덕트 형태로 나타내는 것이고 이 뒤에 있는 FM과 FFM은 방금 전에 우리가 배웠던 모델들이죠. 그래서 데이터셋에 따라서 조금씩 다르고 표현형에 따라서 조금 다르긴 하지만 이제 FM과 FM이 당연히 이 두 모델보다는 좋은 성능을 보이고요. 어떤 데이터셋에 대해서는 FFM이 좋은 성능을 보이지만 그렇지 않은 데이터 셋도 있습니다. 이제 그 이유는 어떤 데이터셋은 필드를 사용하여서 명시적으로 피처를 구분하는 것이 별로 도움이 되지 않았을 수 있기 때문입니다. 그래서 FFM은 필드 개수만큼 팩토라이제이션 파라미터가 늘어나기 때문에 필드를 사용하는 것이 적절하지 않을 경우에는 프프엠을 사용했을 때 오히려 오버피팅이나 반대로 언더 피팅이 발생할 수도 있기 때문입니다. 그래서 데이터셋에 따라서 FFM이 좋을 때도 있고 FM이 좋을 때도 있다는 점 현업에서 사용하실 때 기억해 두시면 좋을 것 같습니다. 아무튼 결과적으로는 lme 리니어 리그레션 죄송합니다. 로지스틱 리그레션 그리고 폴리 2 모델보다 FM이나 FM이 좋은 성능을 보이고 있고 특히 CTR 예측 데이터셋 같은 스퍼스 한 데이터셋에서 이런 팩토라이제이션 머신 계열의 모델이 굉장히 효율적이면서 뛰어난 예측력을 가지고 있다고 정리할 수 있습니다. 자 마지막 네 번째 파트는 그레디언트 포스팅 머신입니다. CTR 예측에 효과적이라고 알려진 그레디언트 부스팅 기법의 원리를 이해하고 대표적인 지비엠 계열의 모델들에 대해서 간단히 리뷰해 보겠습니다. 최근에 케이글과 같은 컴퍼티션에도 많이 등장하는 이 그래디언트 부스팅 머신 모델은 다양한 오픈 씨티알 데이터셋에 대해서도 뛰어난 성능을 보이고 있습니다. 이제 프엠이나 프프엠 같은 계열의 모델을 포함하여서 다른 추천 모델보다도 때로는 높은 예측력을 보이고 있으며 그래서 종종 지비엠을 사용해서 개인화된 추천 모델을 학습하고 사용하는 사례도 있습니다. 이제 하나의 예시로 하이퍼커넥트의 서비스인 하쿠나 라이브의 사례를 들고 왔습니다. 하쿠나 라이브에서는 기존의 인기도 기반 혹은 휴리스틱 기반의 추천 시스템 에서 탈피하여서 이제 더 성능이 좋은 추천 모델을 사용하고자 다양한 모델을 테스트했습니다. 특히 실시간 서비스 데이터의 경우 다양한 환경에 의해서 데이터의 특징이 자주 변하기 때문에 비교적 데이터의 특성에 관계없이 하이퍼 파라미터에 민감하지 않은 모델을 사용하고 싶었는데요. 그래서 이 추천 모델링을 위해서 다양한 시티형 예측 모델을 비교한 결과 우리가 잘 알려진 프엠이나 프프엠 계열의 모델 보다도 그리고 기존에 사용하던 휴리스텍 모델보다도 이 GBM 계열의 모델을 사용했을 때 더 높은 예측 정확도를 보였다는 것을 논문을 통해 발표하였습니다. 자 그렇다면 그레디언트 부스팅 모델이 무엇인지 알아보기 전에 이 부스팅이라는 단어 이 부스팅이 무엇인지를 알아봅시다. 부스팅은 앙상블의 일종인데요. 먼저 앙상블이란 한 가지 모델만 사용할 경우 모델에 생기는 예측 오차를 줄이기 위해서 그 모델의 편향을 줄이기 위해서 2개 이상 여러 가지의 모델을 동시에 결합하여서 사용하는 기법입니다. 그래서 부스팅 기법은 다양한 앙상블 기법 중에 하나로 분류되는 것입니다. 그렇다면 어떻게 앙상블을 진행할까요? 이 의사결정 나무 디시전 트리로 된 위크 러너들을 연속적으로 학습하여 이를 결합하는데요. 여기서 계속 등장하는 이 위크 러너라는 단어는 정확도와 복잡도가 비교적 낮은 간단한 분류기를 의미합니다. 그래서 먼저 연속적으로 학습한다는 것은 이전 단계의 위클 러너 니가 취약했던 부분을 위주로 해당 데이터를 샘플링해서 다음 단계의 위클 언어를 학습한다는 것입니다. 그래서 이 과정을 계속해서 반복되면은 위클 언어가 한 개가 아니라 여러 개가 생성되겠죠. 그 여러 개의 위클 러너들에 대해서 인퍼런스를 진행하고 그 인퍼런스를 최종적으로 다 합쳐서 최종 예측 값을 구하게 됩니다. 그래서 이렇게 여러 개의 위클 러너들을 동시에 한꺼번에 사용해서 예측하는 기법이나 예측하는 모델을 부스팅이라고 합니다. 그래서 부스팅을 기반으로 하는 대표적인 모델은 아다부스트 우리가 배우고 있는 지금 그레디언트 부스팅 머신이 있는데요. 이제 이 그레디언트 부스팅 머신을 발전시킨 모델인 xg 부스트나 라이트 GBM 캣 부스트 같은 것도 많이 있지만 이번 시간에는 주로 그레디언트 부스팅 머신을 위주로 살펴보겠습니다. 그레디언트 부스팅을 살펴봅시다. 그레디언트 부스팅이랑 그레디언트 디센트를 사용하여서 노스 펑션이 줄어드는 방향으로 위크 러너드를 반복적으로 결합하는 방법입니다. 이 로스 펑션이 줄어드는 방향이 바로 negative 그래디언트 방향인데요. 보통 우리가 그래디언트 디센트라는 말을 어디서 많이 들었냐면은 스토캐스트 그레디언트 디센트라는 것을 사용하여서 모델의 학습 파라미터를 업데이트 할 때 배웠던 개념입니다. 근데 이 그레디언트 부스팅은 그레디언트 디센트를 이용해서 학습 파라미터를 업데이트하는 것이 아니라 로스 펑션이 줄어드는 방향 으로 위크 러원을 추가한다라는 점에서 완전히 다릅니다. 이 아래 수도 코드를 보시면은 이 세 번째 라인이 그래디언트를 계산하는 수식인데요. 스토캐스트 그레디언티티 센터와 다른 점은 이 그레디언트의 분모를 보시면 알 수 있습니다. 이 분모에 파라미터가 아니라 그 학습하는 러너 그 자체 FX가 들어가 있습니다. 즉 FX로 이 로스를 미분한 그레디언트를 구하는 것이죠. 그리고 이 그래디언트의 음수를 취한 negative 그래디언트가 새로운 예측값 y 틸드가 되고요. 이 와 틸드을 다시 예측하는 새로운 위클러너 치를 학습하게 됩니다. 그래서 이 치가 그다음 위클 러너가 되는 것이죠. 그래서 그래디언트 포스팅은 로스 펑션이 줄어드는 방향인 negative 그래디언트를 예측해서 위클 언어를 생성한다고 했는데요. 사실 이 말 자체가 굉장히 이해하기 어렵기 때문에 좀 더 쉽게 이해할 수 있도록 설명해 보겠습니다. 통계학적인 관점에서 negative 그래디언트는 실제 값과 예측값의 차이인 레지듀얼이라고 볼 수 있습니다. 즉 그레디언트 부스팅에서 이 윌크 러너가 학습되는 과정은 바로 이전까지의 레지 듀어를 계산하고 이 레지 듀엣을 예측하는 다음 단계의 위클 러너를 학습하여서 기존 모델에 이를 결합하는 것입니다. 그림을 통해 원리를 쉽게 이해해 봅시다. 좌측에 스와 와이의 학습 데이터가 있고요. 이를 표현하는 큐 펑션이 녹색 곡선처럼 생겼다고 가정합시다. 그럼 우리는 예측 모델을 학습하여서 이 녹색 곡선과 최대한 비슷하게 만들어야 합니다. 먼저 첫 번째 위클 언어인 트리 1을 학습하여서 해당 모델과의 실제 값의 차이인 레지 듀어를 구합니다. 그래서 이 차이는 레지듀얼이 이렇게 되겠죠. 이제 이 값들을 다음 번 위크 러너에 사용하는데요. 이 레지듀얼을 예측하는 두 번째 트리를 학습하는 것입니다. 그리고 이 차이의 레지듀얼을 다시 구해줍니다. 그리고 이 레지듀얼을 다시 예측하는 세 번째 위클 러너 트리를 학습합니다. 이렇게 해서 계속해서 반복되면서 트리가 추가되고 레지듀얼은 점점 작아지면서 최종적으로 실제 출 펑션과 굉장히 비슷한 예측 모델이 학습될 것입니다. 그래서 그레디언트 부스팅을 사용하여서 이 리그레션 테스크 즉 회귀 테스크를 수행할 경우에는 방금 설명했던 것처럼 이 위클런의 예측 값으로 레지듀얼을 그대로 활용하고요. 이 레지듀얼이라고 하는 것은 실측값에서 예측 값을 뺀 차이를 말하는 것이죠. 그리고 분류 문제 클래시피케이션 테스크에서는 0과 1 사이로 예측하는 것을 어떤 실수로 표현하기 어렵기 때문에 로그 오즈 값을 사용하여서 레지듀어를 계산합니다. 자 다음의 예제를 통해서 그레디언트 부스팅 모델이 학습되는 과정을 좀 더 잘 이해해 봅시다. 이제 본 문제는 리그레션 테스크를 가정하고 이 리그레션 테스크 문제를 푸는 과정을 설명하였습니다. 그래서 먼저 주어진 데이터가 이렇게 3개 주어진 피처가 3개가 있겠죠. 이 입력 변수 3개에 대해서 우리는 이 웨이트 값을 예측하는 리그레션 모델을 학습해야 합니다. 첫 번째 스텝 제로 즉 아무런 트리도 없을 때는 전체 웨이트의 평균값으로 초기 예측 값을 설정합니다. 이것이 트리 제로가 되는데요. 이제 이 트리 제로와 실제 값의 차이가 바로 레지듀얼리입니다. 그래서 이 첫 번째 트리 첫 번째 위클 러너는 이 레지듀얼을 예측하게 되고요. 그래서 그 레지듀얼의 예측 값이 오른쪽에 있습니다. 그래서 이 첫 번째 트리는 실제 레지듀얼 값을 예측할 수 있도록 각각의 트리의 노드에 예측 레지듀얼 값이 적히게 됩니다. 그다음에 이 트리 제로와 트리 1을 합쳐 합치게 되면은 최종 예측 값이 나오게 되고요. 이 최종 예측값과 원래 실측값을 다시 빼면은 또 다른 레지듀얼 두 번째 레지듀얼이 나오겠죠. 이 레지 듀얼을 다시 학습하는 두 번째 트리를 또 학습합니다. 그래서 이 두 번째 레지듀얼이 학습되면은 또 그 차이를 계산해서 세 번째 레지듀얼을 구할 수 있겠죠. 그래서 이 세 번째 레지듀얼이 바로 이 부분이죠. 그래서 이렇게 해서 계속해서 트리를 하나씩 하나씩 학습해서 이 레지듀얼 값을 줄여 나가게 되면은 최종적으로 정확한 예측 부스팅 모델을 학습할 수 있습니다. 그래서 n 번째 트리까지 학습한 이후에 언제 멈추냐 손실 함수 즉 로스 펑션 값이 일정 수준 이하이거나 마지막 리프 노드 즉 마지막에 위클 러너에 학습했던 그 노드에 속한 데이터 수가 굉장히 적어질 때 멈추게 됩니다. 그래서 몇 번의 학습을 통해서 굉장히 예측 값이 정확해졌음을 확인해 볼 수 있습니다. 레즈 듀얼이 거의 0에 가깝기 때문에 이 정도 학습한 이후에는 이제 더 이상 트리를 생성하지 않고 부스팅이 멈추게 됩니다. 그래서 이 GBM 은 다른 트리 계열의 앙상블 모델 대표적인 랜덤 포레스트가 있는데요. 그 랜덤 포레스트보다 대체적으로 좋은 성능을 보입니다. 랜덤 포레스트는 앙상블 중에 배깅을 활용한 방법인데요. 같은 디시전 트리 같은 위클 러너를 배깅하는 것보다는 부스팅하는 것이 더 예측 정확도가 뛰어나다고 알려져 있습니다. 하지만 이 그래디언트 부스팅 모델의 문제는 학습 속도가 굉장히 느리다는 것입니다. 순차적으로 계속해서 위클 언어를 학습하기 때문에 학습 속도가 랜덤 프로젝트보다 훨씬 느리게 되고요. 또한 모델이 계속해서 레지 듀얼에 맞게 계속 학습하게 되면은 이제 트레이닝 데이터 즉 학습 데이터에 대해서는 굉장히 잘 피팅하지만 반대로 테스트 데이터에 대해선 취약한 제너럴라이제이션에서는 취약한 모델로 학습될 위험이 있습니다. 즉 오버피팅이 된다는 것이죠. 그래서 이 GBM의 두 가지 문제 오버피팅이 쉽게 되고 학습 속도가 느리다는 단점을 보완한 다른 모델과 라이브러리들이 등장하였습니다. 그래서 이 다음과 같은 세 가지 모델이자 라이브러리가 제일 기본적인 그레디언트 부스팅의 문제점을 해결하였습니다. 사실 이 세 가지 모델을 제대로 이해하기에는 각각의 모델의 구현과 난이도가 다소 높기 때문에 지금 당장은 이런 기법들이 있다 정도로 기억해 주시고, 나중에 이 모델을 직접 사용하게 될 때 해당 모델과 관련 논문에 대해서 자세히 학습드리길 추천드립니다. 그래서 엑스지 부스트 같은 경우에는 익스트 그레디언트 부스팅의 약자로서 학습 과정에서의 병렬 처리와 근사 알고리즘을 통해 속도를 굉장히 빠르게 한 라이브러리입니다. 그리고 라이트 GBM 같은 경우에는 마이크로소프트에서 제안한 가벼운 그래디언트 부스팅 머신이고요. 그리고 캡 푸스트 같은 경우에는 이제 피처들 가운데 특히 카테고리컬 피처가 많을 때 이 카테고리컬 피처의 효과적인 알고리즘을 구현하여서 예측 정확도를 높이고 과적합을 방지한 모델입니다. 네 이상 GBM에 대한 강의까지 모두 마쳤고 여덟 번째 강의를 모두 마무리하였습니다. 모두 수고하셨습니다."
}