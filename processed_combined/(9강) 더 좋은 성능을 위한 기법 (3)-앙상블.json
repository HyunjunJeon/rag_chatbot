{
  "lecture_name": "(9강) 더 좋은 성능을 위한 기법 (3)-앙상블",
  "source_file": "(9강) 더 좋은 성능을 위한 기법 (3)-앙상블_58.mp4_2025-12-04-103553375.json",
  "text": "안녕하세요. 도메인 공통 프로젝트 9강 더 좋은 성능을 위한 기법 세 번째 앙상블 시작하겠습니다. 이번 강의에서는 여러 모델의 결과를 섞어서 더 좋은 성능을 내는 모델 앙상블에 대해서 이야기해 보겠습니다. 다음으로는 여러분들이 사용할 수 있는 몇 가지 앙상블 기법에 대해서 소개해 드리겠습니다. 첫 번째 모델 앙상블입니다. 앙상블의 개념은 간단합니다. 단일 모델을 사용하는 것보다 여러 모델의 결과를 같이 사용하는 것이 더 좋은 예측 성능을 보여줄 수 있다라는 의미입니다. 예시에서 볼 수 있듯이 테스트 샘플을 마이 모델 이외에도 다른 종류의 여러 모델들의 결과를 출력한 뒤에 이를 합산해서 결과를 만들어내는 앙상블이 더 좋은 성능을 보여줄 수 있다라는 것입니다. 조금 더 직관적으로 이해해 보겠습니다. 우리가 전교 1, 2, 3, 4등의 4명의 학생이 있다고 가정해 보겠습니다. 전교 2 3, 4등의 학생은 전교 1등과 개개인의 성적을 비교했을 때 이길 수 없다고 가정을 해 보겠습니다. 하지만 전교 2등, 3등, 4등 학생이 잘하는 과목이 다르다면 그리고 이 3명의 점수 혹은 이 3명의 풀이를 혹은 정답을 합쳐서 성적을 낸다면 모두 준수하게 잘하는 전교 1등을 이길 수 있다 이런 식으로 이해하시면 좋겠습니다. 하지만 성적이 고만고만한 학생들끼리 뭉치는 경우에는 어떻게 해도 전교 1등보다 높은 성적을 받기는 어렵습니다. 이는 여러분들이 모델을 앙상블을 할 때 모든 모델을 기반으로 결과를 내는 것이 아니라 어느 정도 성능이 좋은 성능이 비슷한 모델들의 결과들을 섞어야 더 좋은 성능을 얻을 수 있다는 것을 의미합니다. 앙상블의 대표적인 방식인 베깅에 대해서 개념적으로 이해해 보겠습니다. 베깅은 bing로 이해하시면 됩니다. 가지고 있는 데이터셋을 여러 분할로 쪼개어서 가방에 담는다고 상상해 보겠습니다. 각각의 모델들은 각 가방에 담긴 여러 서로 다른 데이터셋을 기반으로 모델을 학습하게 됩니다. 이 학습한 결과를 기반으로 예측 값을 만들어 내는 것이 베깅입니다. 여기에서 각 모델들의 결과를 섞는 방식이 섞는 방식을 우리가 보팅이라고 하는데요. 그래서 베깅은 보팅 앙상블의 어떤 예시로 이해할 수도 있습니다. 다음은 보팅이 어떤 식으로 이루어지는지 조금 더 자세히 다뤄보겠습니다. 현재 우리가 풀고자 하는 문제는 주어진 입력에 대해 이 입력이 어떤 음식을 뜻하는지 분류하는 문제입니다. 먼저 하드 보팅입니다. 하드 보팅은 말 그대로 레이블 그 자체로 보팅을 수행합니다. 첫 번째 모델은 애플, 두 번째 세 번째 모델 모두 애플이라고 답했습니다. 하지만 네 번째 모델은 핫도그라고 답변을 했는데요. 여기에서 4개의 모델의 앙상블 결과는 3개의 사과 1개의 핫도그가 됩니다. 이를 통해 결과가 사과가 되는 것을 확인하실 수가 있습니다. 다음은 소프트 보팅입니다. 제가 우리 강의에서 사실 분류 모델이 반환하는 것은 어떤 분류 클래스가 아니라 그 직전에 확률 값을 반환한다고 언급한 적이 있습니다. 예시에서 볼 수 있듯이 모델 1 2 3 사과 출력하는 각 클래스에 대한 확률을 볼 수가 있습니다. 이 과정에서 모델 1 2 3이 사과라고 답변을 했지만 실제로는 각 모델이 보여주는 컨피던스는 약간 다를 수 있습니다. 1번 모델은 0.5의 확률로 사과하라고 답했고요. 2번 모델은 0.8의 확률로 사과하라고 답했습니다. 모델 3은 0.7의 확률로 사과하라고 답했습니다. 이런 식으로 각각 레이블의 확률을 출력으로 삼아서 이 확률을 모두 평균을 낸 뒤에 가장 평균 확률이 높은 클래스를 선택하는 방식이 소프트 보팅입니다. 우리가 가능하다면 일반적으로는 하드 보팅보다는 소프트 보팅을 사용하는 것을 추천드리고 조금 더 일반적인 방법입니다. 다음은 앙상블의 대표적인 다른 형태인 부스팅에 대해서 설명하도록 하겠습니다. 부스팅은 내부적으로 여러 개의 모델을 생성을 합니다. 각각의 모델은 순차적으로 학습되고 평가됩니다. 각 모델에서 틀린 샘플, 잘못 맞춘 샘플에 대해 다음 모델이 더 잘 맞출 수 있도록 가중치를 주거나 혹은 그레디언트를 통해 더 높은 로스를 발생시켜 많은 업데이트를 할 수 있도록 만드는 것이 부스팅입니다. 조금 쉽게 말하면 1번 모델이 틀린 문제를 2번 모델이 집중적으로 학습하고, 2번 모델이 틀린 문제를, 3번 모델이, 3번 모델이 틀린 문제를, 4번 모델이 이런 식으로 점진적으로 취약점을 해결해 나가는 방안으로 모델이 업데이트됩니다. 결과적으로는 부스팅 과정을 통해 생성된 모든 모델의 결과를 보팅 연산을 통해 만들어내게 됩니다. 다음은 부스팅 학습 과정을 보여줍니다. 첫 번째 예시를 보겠습니다. 백인과 동일하게 학습 셋은 랜덤하게 샘플링을 합니다. 여기서 랜덤하게 샘플링한다라는 것은 랜덤하게 행을 선택하는 것도 포함하며, 랜덤하게 피처 컬럼을 열을 선택하는 것도 포함을 합니다. 그래서 첫 번째 학습 셋에 대해서 첫 번째 모델을 학습하고 밸리데이션을 진행합니다. 예측을 진행한다는 것이죠. 예측된 밸리데이션 레이블과 실제 밸리데이션 레이블의 결과를 비교하여 잘못 예측된 에러를 계산합니다. 그리고 이 잘못 예측된 에러를 다음 모델 학습에 포함하게 하여 더 잘 맞출 수 있도록 합니다. 이런 식으로 이터레이션을 반복해 나가면서 이전 단계에서 틀렸던 샘플에 대해 좋은 모델을 학습할 수 있도록 모델을 개선합니다. 좀 쉽게 말하면 이런 작은 위클 러너들이 서로 예측하기 어려운 부분들을 반복적으로 개선해 나가면서 결과적으로 마지막에 앙상블 된 모델에서는 강한 모델 스트롱 러너가 되는 과정을 표현한 앙상블 기법이라고 생각하시면 되겠습니다. 다음은 모델의 분산과 편향에 대해서 이야기를 해 보겠습니다. 먼저 편향은 얼마나 예측 값이 실제 값보다 다른지 이야기합니다. 예측값의 평균과 실제 값을 뺀 값을 이야기합니다. 다음은 분산입니다. 분산은 모델이 출력하는 예측값이 같은 샘플들에 대해 얼마나 달라질 수 있는지를 뜻합니다. 예측값과 예측값의 평균을 뺀 뒤 제곱한 것의 평균을 취합니다. 이는 우리가 정의한 로스 펑션을 분해하면 편향과 분산으로 표현되는 것을 알 수 있습니다. 다음은 모델의 분산과 편향에 따라 우리가 언더피팅 혹은 오버피팅이라고 말하는 양상을 보여줍니다. 먼저 왼쪽부터 보겠습니다. 높은 편향과 낮은 분산이 있는 경우 우리는 이를 과소 적합이라고 이야기를 합니다. 예시에서 볼 수 있듯이 결정 경계 혹은 회귀선이 데이터셋을 전혀 표현하지 못하는 것을 보실 수가 있습니다. 다음으로는 로우 바이어스 로우 베리언스로 보겠습니다. 편향이 낮고 모델이 표현하는 분산이 낮은 경우 다음과 같이 적절하게 어느 정도 오차를 허용하면서 결정 경계 혹은 회귀선을 만들어 내는 것을 보실 수가 있습니다. 마지막 오른쪽의 경우는 로우 바이어스 하이 베리언스를 갖습니다. 이는 우리가 이야기하는 과적합 형태입니다. 주어진 데이터에 대해서는 매우 잘 표현하는 어떤 결정 경계나 회귀선을 보여주지만 실제로 관측하지 않은 데이터에 대해서는 잘 맞추지 못하는 문제가 발생할 수 있습니다. 정리를 해보면 하이 바이러스를 갖는 경우는 과소적합, 지나치게 단순한 모델로 인해 예측력이 감소된 상태입니다. 하이베리언스는 과대적합 오버피팅으로 지나치게 복잡한 모델로 인해 일반화가 되기 어려운 상태를 이야기합니다. 앙상블을 통해 편향과 분산이 낮아지게 되는데요. 이 이유에 대해서 살펴보겠습니다. 왼쪽에 있는 것은 단일 모델로 분류한 결정 경계입니다. 오른쪽에 있는 그림은 베깅 앙상블을 통해 구성된 결정 경계입니다. 단일 모델을 사용하면 과대적합이 되어 분산이 높아지지만 배깅 앙상블을 통해 분산을 줄일 수가 있습니다. 이를 조금 더 직관적인 그림으로 이해해 보겠습니다. 위에서 오른쪽에 있는 그림은 낮은 베리언스를 갖지만 높은 바이러스를 갖는 언더피팅 된 데이터입니다. 이는 부스팅 과정을 통해 잘 맞추지 못한 샘플을 더 잘 맞추도록 하여 높은 바이러스를 낮은 바이러스 쪽으로 가져올 수 있게 됩니다. 아래의 왼쪽에 있는 그림을 보겠습니다. 이는 낮은 바이어스를 갖지만 높은 베리언스를 갖습니다. 이는 배깅 앙상블을 통해 높은 베리언스를 낮은 베리언스 쪽으로 가져와서 더 좋은 모델로 만들 수가 있습니다. 다음은 앙상블 기법입니다. 먼저 우리가 이전에 배웠던 교차 검증 프로세스를 통해 진행하는 앙상블에 대해서 배워보겠습니다. 우리가 이전 교차 검증에서는 주어진 데이터셋을 케익의 폴드로 분할하여 모든 폴드를 돌아가며 검증 데이터로 사용하는 교차 검증 방식이라고 배웠습니다. 여기에서 교차 검증의 단점이었던 여러 번 학습을 해야 된다라는 단점을 조금 완화하기 위해 앙상블을 사용해 보려고 합니다. 교차 검증에서는 각 폴드에 대해서 학습을 진행하고 검증 스코어를 확인하는 것으로 프로세스를 마무리했었는데요. 그게 아니라 여기에서 학습된 각 폴드의 모델을 앙상블하는 기법을 교차검증 앙상블이라고 이야기를 합니다. 단순히 검증 스코어를 확인하기 위해 모델을 학습하고 그 모델을 사용하지 않았었는데 이를 다시 재활용하면서 컴퓨팅 리소스의 효율성을 높일 수 있는 방법입니다. 다음과 같이 각 모델이 출력하는 확률 값을 소프트 보팅하여 최종 레이블을 만들어 낼 수 있습니다. 교차 검증 앙상부를 구현하는 예시를 보겠습니다. 이전에 만들었던 예시와 동일하게 k 폴드 객체를 정의하고요. 그리고 k 폴드 스플릿이라고 하는 함수를 통해 인덱스를 생성합니다. 생성된 인덱스를 기반으로 데이터셋을 먼저 만들고요. 만든 데이터셋을 데이터 로더로 만듭니다. 해당 데이터 로더는 각 폴드마다 생성이 되게 되고 트레인 밸리데이션 스텝에서 사용되게 됩니다. 이전에 봤었던 예시와 동일하게 케 폴드마다 모델을 따로 지정하게 됩니다. 즉 케이개의 모델을 학습시킨다라는 의미입니다. 각 모델 개별적으로 테스트 셋에 대해 추론을 통해 생성된 프레딕션 값을 평균을 취하면서 오프 프레딕션즈라고 하는 변수에다가 저장합니다. 이런 식으로 모든 폴드에 대해 학습을 진행을 하고 마지막으로 검증 스코어를 확인을 하면서 테스트 셋에 대한 소프트 보팅 앙상블 결과를 확인합니다. 결과는 다음과 같습니다. 각 폴드의 테스트 알피알씨는 0.741 0.6117, 0.6113, 0.7261이 나왔고요. 최종적으로 합친 테스트 ruprc의 결과는 0.8915가 나왔습니다. 이를 통해 개별보다 더 좋은 테스트 성능을 얻을 수 있었습니다. 우리가 교차검증 앙상블을 다른 말로 ro 폴드 앙상블이라고도 이야기를 합니다. 교차 검증 앙상블의 장단점에 대해서 이야기를 해 보겠습니다. 먼저 장점입니다. 모델의 일반화 성능을 평가하면서 앙상블을 진행할 수 있습니다. 데이터를 여러 부분으로 나누어 반복적으로 모델을 학습하고 평가함으로써 모델이 새로운 데이터에 대해 얼마나 잘 일반화할 수 있는지를 더 정확하게 측정할 수 있습니다. 다음은 과적합 방지입니다. 모델이 특정 데이터 분할에 과적합되는 것을 방지할 수 있습니다. 다양한 데이터 분할에 대해 모델을 평가하므로 특정 분할에만 최적화되지 않도록 합니다. 마지막으로는 안정된 성능 평가입니다. 단일 학습 검증 분할에서 발생할 수 있는 편차를 줄여줍니다. 여러 번의 평가를 통해 평균적인 성능을 구함으로써 보다 안정적인 모델 성능 평가가 가능합니다. 다음은 단점입니다. 아무리 교차 검증의 결과를 앙상블을 했다 하더라도 시간과 계산 비용은 여전히 단점입니다. 교차검증 앙상블은 여러 번의 모델 학습과 평가를 필요로 하므로 시간과 계산 비용이 증가할 수 있습니다. 다음은 복잡성의 증가입니다. 여러 번의 모델 학습과 평가를 관리해야 하므로 구현과 유지 보수가 복잡해질 수 있습니다. 다음은 데이터 요구 사항입니다. 충분한 데이터가 없는 경우 데이터의 분할이 모델 성능에 부정적인 영향을 미칠 수 있습니다. 교차 검증을 위해서는 데이터가 충분히 많아야 합니다. 다음은 스태킹 앙상블입니다. 스태킹 앙상블은 모델마다 가중치를 주어서 양상블 모델을 만드는 것이다라고 생각하시면 되겠습니다. 이때 가중치를 어떻게 주는지에 따라 최종 예측이 달라질 수 있는데요. 이때 추가적인 모델을 사용하게 됩니다. 가중치들을 어떻게 셋업할 것인지 학습하는 모델이 메타 모델이고 이러한 메타 모델을 활용한 앙상블을 스태킹 앙상블이라고 부릅니다. 그림에서 볼 수 있듯이 샘플링을 통해 형성된 여러 학습 셋을 각각의 모델들이 학습을 합니다. 그리고 각각의 모델의 결과에 대해 가중치를 부여해서 예측을 생성하는 메타 모델을 추가로 정의합니다. 다음과 같이 각 모델의 예측값을 피처로 만듭니다. 다음 샘플의 클래스를 기반으로 레이블 와를 설정합니다. 이스와 이와를 기반으로 메타 모델을 학습합니다. 다음은 티티에라고 하는 테스트 타임 어그멘테이션입니다. 학습이 끝난 모델에 대해 테스트 샘플을 어그멘테이션을 통해 한 샘플에 대해 여러 번 추론한 후 평균을 내어 추정 결과를 냅니다. 좀 쉽게 직관적으로 이해해 보겠습니다. 우리가 만약 강아지 혹은 고양이를 분류한 사진이 있다고 해 보겠습니다. 강아지와 고양이는 똑바로 보아도 강아지와 고양이일 거고요. 사진을 90도를 돌려도 강아지와 고양이처럼 보일 것입니다. 혹은 플립을 해서 뒤집는다 하더라도 똑같이 강아지와 고양이처럼 보일 거예요. 이런 식으로 이미지 혹은 비전 쪽에서는 이미지들을 추론하는 테스트 단계에서 여러 번의 어그멘테이션을 통해 동일한 이미지를 다양한 버전을 생성을 하고 이를 여러 번 추론을 합니다. 이 추론한 결과의 평균을 소프트 보팅을 처리하여 예측하는 것이 tta 테스트 타임 어그멘테이션 앙상블 기법입니다. 다음은 스톡캐스틱 웨이트 에버리지입니다. 이 개념은 모델이 어느 정도 학습이 이루어지고 나면 더 이상 옵티멀 지점에 가까이 가기 어려울 때 그 주변부에 있는 모델들을 가지고 배기 앙상블을 하면 옵티멀의 근사한 성능을 얻을 수 있게 해주는 기법입니다. 조금 더 쉽게 말하면 하나의 모델에 대해 학습을 진행합니다. 그리고 그 모델이 어느 정도 성능이 세츄레이션 됐을 때 그때부터 각 스텝 혹은 각 에폭마다 모델의 체크 포인트를 저장을 합니다. 그다음 그 모델들의 파라미터 웨이트 값을 평균을 낸 뒤에 결과를 추론하게 만드는 것입니다. 이를 통해 더 좋은 성능을 얻을 수 있는 것이 블에의 기본적인 개념입니다. 오른쪽 예시에서 볼 수 있듯이 w1, w2, w3라고 하는 같은 모델의 3개의 웨이트 값을 앙상블을 한 모델로 추론했을 때 더 좋은 성능을 보일 수 있었습니다. 다음은 믹스트 오브 엑스퍼트입니다. 이 앙상블 기법은 최근 엘엘엠에서 많이 선택되는 구조인데요. 입력에 따라 서로 다른 전문가 모델 중 일부만 선택적으로 활성화되는 구조입니다. 각 전문가의 특화된 예측을 게이트 모델이 조합하여 전체 예측 성능을 높입니다. 이 과정에서 게이트 모델은 탑 k개의 엑스퍼트를 선택을 하고 선택된 엑스퍼트들에 대한 노드만 활성화하는 방식으로 구현합니다. 앞서 여러 가지 앙상블 기법을 설명을 드렸는데요. 여러분들이 쉽게 사용할 수 있는 강력한 앙상블 기법인 스태킹 앙상블에 대해 조금 정리하고 넘어가겠습니다. 먼저 장점입니다. 첫 번째는 일반화 성능 향상 부분입니다. 스태킹 향상블은 여러 모델의 예측 결과를 종합하여 최종 예측을 수행하므로 개별 모델의 과적합을 방지하고 더 나은 일반화 성능을 제공합니다. 다음은 복잡한 패턴 학습입니다. 메타 모델은 예측 모델의 예측 결과를 입력으로 사용하여 복잡한 패턴을 학습할 수 있습니다. 이는 단일 모델로는 잡아내기 어려운 복잡한 데이터 구조를 더 잘 포착할 수 있습니다. 다음은 유연성입니다. 스태킹 영상물은 다양한 모델을 자유롭게 결합할 수 있어 매우 유연합니다. 예를 들어 선형 모델, 결정, 트리, 신경망 등 서로 다른 유형의 모델을 함께 사용할 수 있습니다. 다음은 단점입니다. 단점에서는 시간과 계산 비용이 있는데요. 스태킹 영상물은 여러 모델을 학습시키고 예측을 종합하는 과정이 필요하므로 시간과 계산 비용이 증가할 수 있습니다. 또한 복잡성이 증가될 수 있습니다. 여러 모델을 결합하고 메타 모델을 학습시켜야 하므로 구현과 유지 보수가 복잡해질 수 있습니다. 마지막은 모델 선택의 어려움입니다. 적절한 기본 모델들과 메타 모델을 선택하는 과정이 어렵고 최적의 조합을 찾기 위해 많은 실험이 필요할 수 있습니다. 이번 강의에서는 앙상블 모델의 분산과 편향, 교차 검증, 앙상블과 스태킹 앙상블 기법 등 앙상블을 활용하는 방법에 대해서 배웠습니다. 먼저 앙상블에서는 여러 모델을 결합하여 성능을 향상시키는 기법이라고 이야기했습니다. 그중 백인 앙상블의 경우 여러 모델의 예측 결과를 투표로 결합하여 최종 예측하는 앙상블 기법이라고 했었고요. 여기서 중요한 부분은 데이터를 샘플링해서 동일한 데이터를 사용하는 것이 아닌 행과 열을 랜덤하게 구성하는 서로 다른 데이터셋을 사용한다는 점입니다. 부스팅 앙상블은 백인 강상블의 아이디어에 더해 순차적으로 모델을 학습시켜 오차를 줄이는 방법이었습니다. 앙상블에서 모델의 분산과 편향이 낮아지는 이유로는 여러 모델의 예측을 결합해서 평균화하기 때문이라고 이야기했습니다. 교차 검증 앙상블은 교차 검증을 통해 모델을 평가하고 이를 보팅 기법으로 결합하는 방법이라고 설명을 드렸었고요. 스태킹 앙상블은 여러 모델의 예측 결과를 다시 학습하는 메타 모델을 사용하여 최종 예측하는 앙상블 기법이었습니다. 이번 강의는 여기까지입니다. 고생 많으셨습니다."
}