{
  "lecture_name": "[RecSys 이론] (9강)  DeepCTR",
  "source_file": "[RecSys 이론] (9강)  DeepCTR_137.mp4_2025-12-04-11011386.json",
  "text": "안녕하세요. 추천 시스템 강의를 맡은 강사 이준원입니다. 이번 시간에는 지난 8강에 이어서 컨텍스트 어 레커멘데이션 모델에 대해서 학습합니다. 이 car 테스크의 대표적인 씨티알 예측 테스크 관련된 모델을 오늘 강의 동안 학습할 것인데요. 지난 강의에서 로지스틱 리게이션부터 시작하여서 프엠과 프프엠 등의 모델을 다루었고 바로 이 모델들이 씨티알을 예측하는 테스크에서 좋은 성능을 보였다고 말씀드렸습니다. 이번 시간에는 딥러닝의 모델로 넘어옵니다. 딥러닝 모델을 이용한 CTR 예측 모델들을 차례로 배워보고 어떻게 모델의 표현력과 성능이 발전했는지를 살펴봅시다. 네 오늘 다루게 될 모델은 총 4가지입니다. 먼저 CTR 예측 문제에서 왜 딥러닝 모델이 효과적인지를 간단하게 살펴본 뒤에 딥러닝 추천 모델 가운데 가장 많이 알려진 와이드 앤 딥과 딥 FM 모델을 학습합니다. 그다음에 유저의 행동 데이터를 인풋 피처로 사용한 딥 인터레스 네트워크와 트랜스포머를 이용한 비스티 모델까지 모델이 연구를 통해 공개된 시간 순서대로 그리고 모델의 표현력과 복잡도 성능이 향상된 순서대로 차례대로 다뤄보도록 하겠습니다. 네 먼저 CTR 예측 문제에서 딥러닝을 활용하는 이유를 간단하게 짚고 넘어가겠습니다. 지난 강의에서도 CTR 예측 문제의 정의와 중요성에 대해서 언급했는데요. 네 시티알 예측 문제란 주어진 아이템을 클릭할 확률을 구하는 문제라고 말씀드렸죠. 그래서 이 시티 예측에 딥러닝이 필요한 이유는 현실의 씨티알 데이터 주로 광고 추천 데이터가 되는데요. 이 데이터는 기존의 선형 모델로 예측하는 데에는 한계가 있습니다. 굉장히 스파스한 그리고 차원이 굉장히 높은 데이터 높은 피처로 이루어져 있고요. 그리고 그 피처 간의 어떠한 관계가 굉장히 높은 비선형성을 가지고 있기 때문에 기본적인 단순한 선형 모델로 이 문제를 풀기에는 다소 어려움이 있습니다. 그래서 이러한 데이터의 효과적인 딥러닝 모델들이 시티r 예측 문제에 적용되기 시작하였습니다. 첫 번째로 와이드 앤 딥 모델의 등장 배경과 장점을 살펴보고 논문의 제목에 나타나는 와이드 컴포넌트와 딥 컴포넌트를 각각 이해해 봅시다. 네 와이드앤딥 레코멘데이션은 선형 모델과 비선형 모델의 기존이 가지고 있는 장점들을 결합하여서 각각의 모델들이 가지고 있는 장점을 모두 취하고자 한 논문입니다. 본 논문은 구글에서 발표한 논문인데요. 플레이 스토어에서 사용자가 검색한 쿼리에 대해서 앱을 추천해 주는 테스크에도 실제로 사용하고 있다고 밝혔습니다. 이 와이드 앤 딥 논문에서는 추천 시스템에서 해결해야 하는 두 가지 과제가 있다고 말하는데요. 바로 메모라이제이션과 제너럴라이제이션입니다. 먼저 메모라이제이션을 해석하면 말 그대로 암기인데요. 우리가 이미 가지고 있는 학습 데이터에 자주 등장했던 패턴은 그대로 모델이 암기하여서 예측에 활용해야 한다는 것입니다. 먼저 어떤 남자라는 피처를 가진 사람이 컴퓨터에 해당하는 CTR 데이터가 많이 있을 때 이때 이 y 데이터 클릭 데이터가 1로 많이 존재한다고 합시다. 즉 남자 사용자가 컴퓨터에 대한 아이템에 대한 CTR이 높다는 것이죠. 이 피처 관계를 모델이 그대로 학습해줘야 한다는 것이 메모라이제이션입니다. 그래서 이 메모라이제이션은 로지스틱 리그레이션과 같은 선형 모델에 딱 맞는 설명인데요. 네 모델이 단순한 만큼 학습을 통한 파라미터의 수렴이 상대적으로 빠르고 모델에 사용되는 피처가 추가되더라도 모델의 확장성과 해석이 용이하다는 장점이 있습니다. 그러나 이러한 학습 모델이 가지는 바로 단점이 있는데요. 만약에 어떤 남자에 대해서 기존의 컴퓨터 아이템이 아니라 화장품이라는 아이템을 클릭할 확률을 예측해야 한다고 가정합시다. 이제 기존 학습 데이터를 살펴보니 남자가 화장품을 노출하고 클릭했던 데이터가 굉장히 부족하거나 혹은 아예 없을 경우에 이 메모라이제이션 모델 즉 로지스트 리액션과 같은 단순한 모델은 일반화 능력이 떨어지기 때문에 이런 남자가 화장품에 대해서 예측할 확률, 클릭할 확률을 제대로 구할 수 없습니다. 그래서 이러한 단점을 극복하기 위한 방법이 바로 제너럴라이제이션 일반화입니다. 방금 얘기한 남자와 화장품의 피처 조합은 실제 학습 데이터에 거의 발생하지 않았을지라도 각각 남자와 화장품에 대한 변수 특징을 다른 관계 데이터로부터 발견하여서 이를 적절하게 표현할 수 있습니다. 보통 인베딩을 사용하여서 각각의 피처를 적절하게 표현하는데요. 두 피처의 상호 작용은 인베딩이 곱해지면서 계산이 되겠죠. 그래서 이러한 일반화 능력은 FM 같은 지난 시간에 배운 모델도 해당이 되지만 이번 시간에 다룰 DNN 기반의 딥러닝 CTR 예측 모델은 제너럴라이제이션에 훨씬 더 강한 특징을 가지고 있습니다. 그래서 이 메모라이제이션과 제너럴라이제이션이 가지고 있는 각각의 특징을 결합한 모델이 바로 와이드앤디입니다. 그래서 이 두 가지 과제를 모두 커버한다면은 사용자의 어떤 검색 쿼리에 맞는 앱을 추천하는 추천 성능이 더 향상되게 됩니다. 먼저 와이드 컴포넌트를 살펴봅시다. 이 부분은 가장 기본적인 선형 모델 로지스틱 리그레션과 거의 비슷한 모델인데요. 입력 변수가 n개가 있고 이 엔 개에 해당하는 n개의 파라미터로 이루어져 있습니다. 각각의 변수는 모두 선형 결합으로 이루어져 있고 글로벌 바이오스 도 학습 파라미터로 존재합니다. 그러나 이렇게 모델링을 할 경우 이 두 개의 변수 즉 서로 다른 두 개의 변수의 인터랙션 그 관계를 전혀 이 모델을 학습할 수 없는데요. 그래서 와이드 파트에서도 변수 사이의 인터랙션을 표현하기 위해서 다음과 같은 크로스 프로덕트 트랜스포메이션을 사용합니다. 예를 들면 아래와 같이 성별이 여자라는 변수와 그 사용자의 주요 사용 랭귀즈가 영어라는 입력 변수가 동시에 1일 경우 그 두 변수의 프로덕트 텀, 크로스 프로덕트 텀 즉 성별이 여자면서 랭귀즈가 영어라는 변수를 모델에 하나 더 추가해 주게 됩니다. 이러한 크로스 프로덕트 텀을 일반화하여서 이렇게 파케스라고 표현을 할 수 있는데요. 이 파이케이에 해당하는 웨이트도 모델에 추가되어 학습에 반영됩니다. 다만 가능한 모든 변수들 사이에 크로스 프로덕트를 표현하게 된다면은 학습해야 되는 웨이트가 기하급수적으로 증가하게 됩니다. 그래서 본 논문에서는 주요 피처 2개에 대한 세컨 오더 크로스 프로덕트만을 사용하였습니다. 이 피처는 뒤에 등장하는 모델의 아키텍처에도 표현되어 있습니다. 방금까지 설명한 이 크로스 프로덕트 트랜스포메이션. 사실 이 부분의 모델링은 우리가 지난 시간에 배웠던 이 로지스틱 리그레션에다가 2차 폴리노미얼 항을 추가한 것과 거의 동일한 수식입니다. 이 수식에서는 두 개의 서로 다른 변수에 해당하는 학습 파라미터를 정의하고 이 학습 파라미터를 가지고 두 피처의 인터랙션을 표현하였는데요. 보시다시피 엔 곱하기 n만큼 즉 n의 제곱 배로 학습 웨이트가 늘어나게 됩니다. 즉 표현할 수 있는 인터랙션의 한계가 명확한 모델이 바로 이 와이드 컴포넌트 구분입니다. 네 딥 컴포넌트는 다음과 같습니다. 이 팁 컴포넌트는 피드 포워드 뉴럴 네트워크를 사용하는 것 외에는 큰 특징은 없습니다. 아주 단순한 구조인데요. 먼저 이 팁 컴포넌트는 오른쪽에 있는 이 부분입니다. 총 3 레이어로 구성하였으며 그 각각의 레이어에 대해서는 옐로 함수를 사용했는데요. 연속형 변수는 그대로 이 MLP 레이어에 넣어주고 카테고리형 변수는 피처 인베딩을 한 뒤 전체를 컨택하여서 최종 클릭 여부를 예측하고 있습니다. 그래서 이 두 개의 와이드 모델과 딥 모델을 합쳐서 가운데에 있는 와이드 앤 딥 모델이 완성됩니다. 그래서 두 모델을 합쳐서 다음과 같은 모델을 이 와이드 앤 딥을 사용하고 있다고 하는데요. 이 수식을 보시면 이쪽 부분이 와이드 파트고요. 이쪽 부분이 딥 파트입니다. 이 와이드 컴포넌트에는 x와 파스가 있는데요. 이 x는 주어진 n개의 변수를 의미하고요. 파스는 아까 설명했던 것처럼 n개의 변수 사이의 크로스 프로덕트 트랜스포메이션을 의미합니다. 이 모델에서는 앞서 언급했듯이 n개의 모든 변수 사이에 가능한 크로스 프로덕트를 정의하지 않았고요. 이 두 개의 피처 사용자가 과거에 설치한 앱과 지금 현재 CTR을 예측할 그 앱의 크로스 프로덕트만을 이 변수에 추가하였습니다. 그리고 이 뒷부분은 딥 컴포넌트에 있는 MLP 레이어를 일반화해서 표현한 것입니다. 그래서 와이드 프로덕 와이드 컴포넌트와 딥 컴포넌트의 최종 출력 값을 더한 뒤 글로벌 바이러스를 추가하여서 최종적으로 시그모이드를 취하게 되면은 우리가 예측할 클릭 여부가 완성이 됩니다. 네 마지막으로 본 논문에서 와이드 앤 딥 모델의 성능을 온라인 매트릭과 오프라인 매트릭으로 이용하여서 비교하였습니다. 이 비교 대상은 기본적인 제너럴 라이즈 리니어 모델 크로스 프로덕트를 추가한 이 와이드 모델이 되는데요. 그리고 추가적으로 딥 모델만 사용한 성능도 같이 비교하였습니다. 이 베이스 라인인 와이드 모델과 딥 모델 각각은 오프라인에서는 와이드 모델이 좀 더 좋은 예식 성능을 보이고 온라인 서빙을 했을 때는 실제로 얻는 개인는 딥 모델이 컸는데요. 이 두 개의 모델을 합친 와이드 앤 딥은 온라인 성능 과 오프라인 성능 모두 좋은 성능을 보이고 있다고 말합니다. 이상 와이드앤딥 모델에 대한 내용이었습니다. 다음은 딥fm 모델입니다. 딥fm도 와이드앤딥과 굉장히 비슷한 구조를 가지고 있습니다. 마찬가지로 두 개의 컴포넌트 프엠 컴포넌트와 딥 컴포넌트로 이루어져 있고 이 둘을 합쳐서 딥프엠이라는 이름을 명명하였습니다. 그래서 딥프엠에는 어떤 컴포넌트가 있는지 그리고 와이드앤 딥에 비해서 어떠한 장점이 있는지도 같이 살펴봅시다. 네 딥프엠 모델은 지난 시간에 배운 팩토라이제이션 모델의 딥러닝 구조를 추가한 모델입니다. CTR 예측에서 뛰어난 성능을 보인 팩토라이제이션 모델 프엠 모델에다가 딥 컴포넌트를 추가하여서 좀 더 복잡한 상호 작용을 캡처하기 위해서 이러한 모델 구조를 설계하였습니다. 그래서 와이드 앤 딥 모델과는 달리 이 와이드에 해당하는 프엠 컴포넌트와 딥 컴포넌트가 모두 하나의 입력 값으로 공유하고 있어서 따로 피처 엔지니어링이 필요 없는 앤드 투 엔드 방식의 모델을 설계하고 있습니다. 네 딥프엠의 등장 배경을 살펴보겠습니다. 추천 시스템에서 피처 인터랙션 계속 다른 모델에서도 언급했던 내용인데요. 그만큼 추천 시스템에서는 이 인플리시트한 피처의 인터랙션을 학습하는 것이 굉장히 중요합니다. 예를 들면 식사 시간 시간이라는 피처와 배달 앱이라는 피처가 두 개가 동시에 만났을 때 이 시간에 다운로드 수가 증가한다는 것을 모델링하기 위해서는 세컨 오더 인터랙션이 필요하고요. 10대 남성이 이러한 게임을 좋아한다라는 것을 모델링하기 위해서는 10대라는 피처와 남성이라는 피처 그리고 슈팅 RPG 카테고리라는 피처 3개의 피처가 동시에 인터랙션 했을 때 CTR이 높아진다는 것을 모델링해야 합니다. 근데 이제 기존의 CTR 예측 모델들은 로우 오더 혹은 하이 오더 한쪽에만 강한 특징을 보여왔는데요. 이 와이드앤틴 모델 바로 전 슬라이드에서 배운 모델은 이 둘을 통합하여서 문제를 해결했지만 와이드 컴포넌트의 크로스 프로덕트 트랜스포메이션 같은 어떤 피처 엔지니어링이 추가적으로 필요하다는 단점이 있습니다. 그래서 이 와이드 앤 디이 가지고 있던 피처 엔지니어링 파트, 즉 와이드 파트 대신에 지난 시간에 배운 프엠 모델을 그대로 와이드 컴포넌트로 대체하여서 사용하고 있는 것이 바로 딥프엠입니다. 프엠에는 두 변수 사이에 세컨오더 인터랙션이 그대로 표현되어 있기 때문에 강제로 피처 엔지니어링을 통해 크로스 프로덕트 트랜스포메이션을 해줄 필요 없이 그대로 사용하면 됩니다. 그래서 와이드 파트에는 FM을 사용하고 d 파트에는 기본적인 DNN 피드 포워드 n 네트워크를 사용하기 때문에 이 둘을 합쳐서 딥 FM이라고 명명하고 있습니다. 다음 그림과 수식을 통해 좀 더 자세히 살펴보겠습니다. 먼저 FM 컴포넌트인데요. FM은 지난 8강에서 배웠던 이 FM 포뮬라와 수식이 완전히 일치합니다. 그래서 이 FM 모델 수식의 변수들을 살펴보면은 x1부터 xn에 피처가 있고요. 그다음에 두 개의 피처 인터랙션을 표현하는 팩토라이제이션 파라미터 가 있죠. 그래서 이것을 기억하시면서 왼쪽에 있는 그림을 살펴봅시다. 먼저 각각의 필드가 하나하나의 피처를 의미하고 이 디프엠에서는 모두 스파스한 피처로 구성하고 있습니다. 먼저 바로 이 어디션이라고 되어 있는 이 부분으로 연결되어 있는 선은 이 1차 텀을 의미합니다. 각각의 피처가 갖는 그에 대응되는 웨이트가 학습되는 것이고요. 이제 그다음에 세컨오더 피처 인터랙션 FM에서 팩토라이제이션 파라미터 텀에 해당하는 부분인데요. 각각의 피처는 동일한 차원의 인베딩 여기서는 5개의 차원인데요. 5차원으로 인베딩 즉 팩토라이제이션 된 다음에 이들끼리 서로 내적으로 인해서 서로 피처 간의 인터랙션을 학습합니다. 그리고 이 모든 것이 더해지면 다음과 같은 에프엠 포뮬라와 동일한 모델을 이렇게 비주얼라이즈 할 수 있습니다. 다음은 딥 컴포넌트입니다. 딥 컴포넌트는 좀 더 고차원 즉 하이오더 피처 인터랙션을 모델링 해 줍니다. 여기서 모든 피처는 각각 다 동일한 차원, 여기서는 5차원인데요. k 차원으로 인베딩 되는데요. 여기서 이 인베딩 되는 이 인베딩 파라미터는 FM에서 사용하는 가중치와 동일하게 사용합니다. 그래서 이 딥 레이어의 인베딩과 FM 레이어의 인베딩이 따로따로 학습되지 않고 한꺼번에 엔드 투 엔드로 학습되는 것이죠. 각각의 인베딩은 모두 컨케이트네이트 돼서 쭉 가로로 붙게 됩니다. 그래서 이 컨케이트네이트 된 전체 임베딩 벡터가 map 레이어에 처음에 인플 레이어가 되고 이 이후에 엘게의 피디 4 디뉴 네트워크를 쌓게 되면 마지막 레이어에서 최종적으로 클릭 여부를 예측할 수 있게 됩니다. 그래서 전체 구조를 보시면 FM과 딥 컴포넌트 각각의 임베딩을 공유한다는 것을 더 쉽게 이해할 수 있습니다. 각각의 필드 각각의 피처가 인베딩 된 이후에 FM 컴포넌트 쪽으로 팩토라이제이션 즉 세컨오더 인터랙션이 이루어지는 부분이 있고요. 그리고 이 전체가 컨케이트네이트 돼서 딥 컴포넌트의 인풋으로 사용되는 것이죠. 그래서 정리하면은 딥fm은 와이드 앤 딥과 비슷하게 FM 컴포넌트와 딥 컴포넌트가 가지고 있는 각각의 장점, 아까 이야기했던 메모라이제이션과 제널라이제이션의 장점을 모두 활용하여서 좋은 예측 성능을 보입니다. 다음 부분은 딥fm을 비슷한 시기에 발표했던 다른 딥 CTR 모델 들과의 성능과 특징을 비교한 부분입니다. 이 DFM 외에 위에 있는 FNN, PNN, ydnt 같은 다른 CTR 예측 논문들도 이 DFM이 등장하기 전에 발표가 되었는데요. 먼저 FNN 같은 경우에는 에프엠 모델을 사용하지만 엔드 투 엔드로 학습하지 않고 에프엠 모델을 학습한 이후에 그 인베딩을 가지고 와서 다시 딥러닝 모델을 사용합니다. 그래서 프리트레이닝이 반드시 필요한 부분이 있죠. 또한 이 PNN 같은 경우에는 DFM과 굉장히 비슷한 부분이 있지만 로우 오더 인터랙션 즉 메모라이제이션 부분에 학습 파라미터가 빠져 있습니다. 그리고 바로 전 파트에서 설명했던 와이드 앤 딥은 와이드와 딥 컴포넌트로 나누어서 각각의 장점을 활용하였지만 이 와이드 컴포넌트 쪽에 크로스 프로덕트 트랜스포메이션 같은 피처 엔지니어링이 필요하기 때문에 모델을 구성할 때마다 상당히 불편한 프리 프로세싱 과정을 거쳐야 한다는 단점이 있습니다. 그래서 DFM은 이와 같은 모델들이 표현할 수 없는 일부 특징이나 혹은 모델이 가진 단점을 보완한 모델입니다. 네 그래서 최종적으로 모델의 예측 성능을 비교해 보았는데요. 이 표에는 우리가 지난 강의부터 다루었던 많은 CTR 예측 모델들을 확인할 수 있습니다. 가장 기본적인 로지스틱 리그레션과 프엠프엔엔 그리고 여기에서는 이렇게 표현하였지만 이 모델들은 모두 와이드 앤 딥 에 해당하는 모델입니다. 그래서 먼저 이 AUC라는 예측 성능은 보통 바이너리 클래시피케이션에서 쓰이는 성능 지표로 높을수록 좋고요. 이 로그로스 같은 경우에는 CTR 예측 모델의 바이너리 크로스 엔트로피 손실 함수를 의미합니다. 그래서 이 모델을 발표한 화웨이의 데이터셋과 그리고 오픈 시티알 데이터셋으로 유명한 크리테오에 대해서 모두 딥프엠이 가장 우수한 성능을 보이고 있는 것을 알 수 있습니다. 네 여기까지가 딥fm에 대한 내용이었습니다. 다음은 디아n 딥 인터레스 네트워크입니다. 이 디아에서 사용된 특징은 기존에 사용하지 않았던 유저의 행동 피처, 유저의 비에이비어 피처를 사용했다는 것인데요. 다음을 통해 모델의 전체 구조를 이해해 봅시다. 이 모델에서는 유저가 과거에 행동했던 기록인 유저 비에뷰어 피처를 인풋 피처로 사용하여서 좀 더 정확한 CTR을 예측 하고 있습니다. 이 피처를 어떻게 사용할 수 있도록 본 모델을 설계했는지 전체 구조를 이해해 봅시다. 먼저 dim 모델 이 딥 인터레스트 네트워크 모델은 더 많은 유저 정보 더 많은 유저의 과거 행동 정보와 같은 다양한 피처를 모델에 사용하고 싶다는 니즈에서 출발하였습니다. 기존의 딥러닝 기반 모델 우리가 방금 전에 배웠던 와이드 앤 딥과 딥fm 같은 경우에는 모두 인베딩 이후에 멀티 레이얼 퍼셉트론 즉 피드 포워드 뉴럴 네트워크를 통과시키는 이러한 패러다임을 계속해서 다뤘습니다. 그래서 스프러스한 피처들을 인베딩 변환한 이후에 컨택해서 이 풀 커넥티드 레이어인 MLP의 입력으로 사용하는 방식으로 계속 모델 구조를 설계하였는데요. 이제 이러한 기본 기존의 방식들은 사용자의 다양한 관심사를 반영할 수 없는 모델의 구조였습니다. 예를 들면 사용자는 여러 종류의 식재료와 생필품 같은 서로 다른 카테고리에 관심사가 동시에 존재할 수도 있고요. 그리고 원래 어떤 특정 카테고리의 상품을 검색하던 도중에 중간에 추천 목록에 상품이 떠 있을 때 그 클릭한 데이터를 살펴보면 사실 그 사용자는 원래 특정 카테고리의 상품에 관심이 있다는 컨텍스트가 있는 것이죠. 그래서 이러한 피처를 사용하기 위해서는 좀 더 사용자의 행동이나 관심을 더 잘 담을 수 있는 모델을 설계했어야 합니다. 그래서 사용자가 기존에 소비한 아이템을 리스트 즉 유저 비에이비어 피처로 만들어서 사용자의 관심사를 더 반영하고 그래서 예측 대상 아이템과 내가 과거에 소비한 아이템의 관련성을 더 학습할 수 있도록 그래서 씨티알 예측을 더 정확하게 할 수 있도록 디아의 모델을 설계하였습니다. 네 그래서 이 피처 목록은 din에서 사용한 피처들인데요. dim 모델에서는 지금까지 배웠던 CTR 예측 모델의 인풋에서는 없던 처음 등장하는 피처가 바로 이 유저 baby 피처입니다. 물론 dim 모델에서도 과거의 모델에서 사용하였던 워낫 인코딩 피처 유저 프로파일이나 우리가 지금 예측하려고 하는 그 아이템 여기서는 광고를 의미하는데요. 이런 피처들이 다 원핫 인코딩의 형태로 표현되어 있지만 가운데 있는 유저 BA비어는 특이하게 멀티아 인코딩으로 표현된다는 점이 있습니다. 그 이유는 유저가 과거에 소비했던 아이템이 하나가 아니라 2개 이상 즉 n 개까지 있을 수 있고 이를 사용하기 위해서는 이를 표현하기 위해서는 단순한 원핫 인코딩이 아니라 멀티샷 인코딩의 방식으로 모델 인풋에 넣어야 하기 때문입니다. 그럼 이러한 멀티엣 인코딩 피처를 어떻게 모델이 담고 있는지 다음 슬라이드를 통해 살펴봅시다. 네 모델의 구조는 다음과 같습니다. 크게 3개의 레이어로 구성되어 있는데요. 첫 번째 레이어는 따로 언급하진 않았지만 각각의 모든 스팟 피처를 임베딩하는 레이어이고요. 중요한 부분은 이 두 번째 로컬 액티베이션 레이어입니다. 그리고 마지막 부분은 여러분들이 이미 익숙한 피디 포드 뉴럴 네트워크로 이루어져 있는 엠엘피 레이어입니다. 다른 레이어에는 특별한 특징은 없고 이 두 번째 로컬 액티베이션 레이어에서 바로 유저 비에뷰 피처와 지금 노출하려고 하는 아이템의 관련성을 학습하게 되는데요. 여기서 사용하는 것이 바로 이 액티베이션 유닛입니다. 이 두 번째 레이어가 본 모델의 핵심적인 부분입니다. 그래서 이 로컬 액티베이션 레이어를 통해 좀 더 자세하게 유저 비에이비어 피처에 대해서 살펴봅시다. 먼저 이 우측에 보이는 아까 언급했던 로컬 액티베이션 유닛을 통해서 우리가 지금 노출하려고 하는 즉 CTR을 예측하려고 하는 후보 광고와 과거 유저 비에이뷰어, 과거 유저가 어떤 아이템을 소비했는지의 관련성을 계산하게 됩니다. 그래서 이 예측 아이템과 과거에 소비했던 아이템들을 각각 페어로 계산하여서 이 액티베이션 유닛에 넣게 되면 최종적으로 각각의 인베딩이 하나의 리니어한 즉 스칼라 값으로 출력되게 되고 이 값이 바로 액티베이션 웨이트 입니다. 이 액티베이션 웨이트는 내가 지금 예측하려고 하는 아이템과 과거에 내가 소비했던 아이템이 얼마나 연관이 있는지를 말하는 것이고요. 그래서 그 웨이트가 높다는 것은 연관성이 높아서 이 정보를 더 많이 활용하겠다는 것이고, 웨이트가 낮다는 것은 최근에 소비한 이 아이템의 경우에는 현재 노출하려고 하는 아이템과 연관성이 낮기 때문에 최대한 덜 반영하겠다는 것이죠. 그래서 여기에 있는 이 n개의 인베딩이 웨이트가 곱해지고 나서는 선플링 즉 이 전체 인베딩을 다 더해서 그 차원이 늘어나지 않고 계속해서 같은 차원으로 유지시키도록 만듭니다. 참고로 이 로컬 액티베이션 레이어는 트랜스포머의 어텐션 메커니즘과 유사합니다. 물론 트랜스포머보다 훨씬 간단하게 계산이 이루어지지만 이 타겟 아이템과 이 타겟 아이템을 기준으로 연관도가 높은 아이템 이 n개 중에 무엇이 높은지를 계산하여서 거기에 더 높은 웨이트를 주어서 신호를 더 많이 전달하려고 하는 원리가 바로 트랜스포머의 어텐션이 하는 역할과 유사하다고 볼 수 있습니다. 그래서 이 로컬 액티베이션 레이어를 통해 더해진 썸플링을 통해 더해진 모든 인베딩 값과 그 외에 다른 원핫 인코딩 피처들은 이 레이어를 통과하지 않고 곧바로 마지막 레이어로 들어가게 됩니다. 그래서 이 모든 레이어를 cncat 네이트 한 다음에 마지막에는 MLP 레이어를 통과시켜서 최종 클릭 여부 01을 아웃풋 레이어에서 예측하게 됩니다. 이 로컬 액티베이션 레이어의 연산을 좀 더 잘 이해할 수 있도록 그림으로 비주얼라이즈 한 결과입니다. 이 왼쪽에 있는 아이템들이 유저가 과거에 소비한 유저 비에뷰 피처이고 이 아이템은 이제 노출하려고 하는 즉 씨티알을 예측하려고 하는 아이템인데요. 이 아이템과 비슷한 아이템을 과거에 많이 소비했을수록 이 두 관계를 통해서 웨이트가 높게 반영되고 그렇지 않은 아이템들은 웨이트가 굉장히 낮게 반영됨을 볼 수 있습니다. 그래서 과거에 내가 소비한 아이템들과 지금 여기에 패딩이 있는데요. 이 패딩과 비슷한 아이템들을 많이 소비했을수록 웨이트가 높게 반영되고 즉 연관성이 높기 때문에 이 아이템에 대한 CTR, 즉 이러한 소비 패턴을 가지고 있는 유저에 대해서 이 패딩을 노출시켰을 때 CTR이 더 높게 학습될 수 있도록 모델의 구조를 설계한 것입니다. 이렇게 해서 유저가 과거에 소비했던 피처를 사용하면 이 유저에게 아이템을 노출했을 때 이 예측 CTR이 더 높게 잘 되는지 혹은 낮게 잘 되는지를 정확하게 구할 수 있는 것입니다. 네 마지막으로 논문에서는 기존에 알려진 다른 CTR 예측 모델들과의 성능을 비교하였습니다. 여기 보시면 우리가 계속해서 보았던 기본적인 로지스틱 리그레션 모델과 와이드 앤 딥 딥fm 등이 있는데요. 이제 이 모델들보다 이 디아이엔 모델이 더 높은 에유시 성능을 보임을 알 수 있습니다. 그리고 여기에 있는 이 다이스라는 것은 디아엔 논문에서 제시한 새로운 액티베이션 펑션인데요. 사실 강의 전체적으로 중요한 부분은 아니지만 이 액티베이션 펑션이 궁금하신 분들은 이 논문을 찾아서 읽어보시길 바랍니다. 그래서 이렇게 유저 비에비 피처를 사용했을 때 CTR 예측 정확도가 더 올라간다는 특징을 가진 디아엔 논문이었고요. 이상 디아엔 전체적인 내용을 모두 마쳤습니다. 네 마지막 파트 babr 시퀀스 트랜스포머라는 BST라는 CTR 예측 모델 논문입니다. DCTR의 마지막 파트인데요. CTR 예측에 여러분들도 잘 알고 있는 트랜스포머 아키텍처를 사용한 모델입니다. 그래서 먼저 트랜스포머에 대해서 간단하게 리뷰를 한 이후 어떻게 트랜스포머를 씨티알 예측에 활용하고 있는지 살펴봅시다. 본 논문은 dim 모델을 발표한 알리바바에서 후속으로 발표한 예측 모델인데요. 트랜스포머를 CTR 예측에 사용했을 때 가장 뛰어난 성능을 보인다고 말하고 있습니다. 그리고 방금 전 디아 논문에서는 유저 비에이비오 피처를 사용했지만 여기서는 비에이비오의 피처의 시퀀스까지 더 정확하게 모델링해서 어떤 순서로 이 유저가 행동을 했을 때 다음 에 노출된 아이템의 CTR이 얼마일지를 더 정확하게 구하고 있습니다. 그렇다면 CTR 예측에도 어떻게 트랜스포머가 효과적으로 작용할 수 있을까요? 이 CTR 예측 데이터와 NLP 번역 데이터 간의 공통점이 있습니다. 이 엔엘피 데이터는 이미 트랜스포머에서 아주 좋은 성능을 보인다고 알려져 있는데요. 일단 씨티r 예측 데이터의 인풋 피처들이 대부분 스파스한 피처인데요. NLP 또한 대부분이 단어로 이루어져 있거나 혹은 서 월드로 이루어져 있기 때문에 둘 다 아주 스프레시티가 높은 피처로 이루어져 있습니다. 또한 이 로우와 하이오더 피처 인터랙션이 각각 모두 존재하기 때문에 비선형적인 관계를 모델이 캡처해야 하고요. 또한 문장의 순서가 중요하듯이 사용자의 행동 순서도 굉장히 중요합니다. 즉 핸드폰을 구매한 이후에 핸드폰 케이스 상품을 추천해 줘야 한다는 식의 순서라든지 바지를 구매하고 나서 이젠 바지에 맞는 신발을 찾아보려 한다는 그런 시퀀스가 있는데요. 이제 이런 시퀀스는 이미 자연어 처리에서는 굉장히 중요한 데이터죠. 따라서 CTR 예측 데이터와 NLP 번역 데이터 간에 공통점이 있다는 것을 언급하였고요. 그래서 NLP 분야에 전반적으로 강력한 성능을 보이는 이 트랜스포머 구조를 CTR 예측에도 적용해 보면 좋지 않을까라는 점에서 이 논문이 등장하게 되었습니다. 그럼 제안 모델인 BST bar 시퀀스 트랜스포머 를 다루기 전에 간단하게 트랜스포머를 리뷰하고 넘어가겠습니다. 이미 너무나도 유명한 어텐션 어유니드라는 논문을 통해서 트랜스포머가 공개되었습니다. 트랜스포머에서 제일 중요한 개념은 바로 이 어텐션이라는 메커니즘입니다. 입력값에 대해서 어떤 부분에 주의, 즉 어텐션을 기울일지를 찾는 원리입니다. 어떤 키 밸류 쌍들이 주어지고 우리가 알고자 하는 쿼리가 있을 때 이 쿼리와 키의 연관성을 가중치로 사용해 이 밸류에 곱하여서 최종적으로 이 값을 가중합으로 사용합니다. 간단하게 수식으로 정리하자면 이 QKV가 쿼리 키 밸류인데요. 쿼리와 키의 유사도를 가중치로 사용해서 이 밸류 를 모두 더해준 값입니다. 또한 어텐션 메커니즘을 사용하면은 입력과 출력의 길이를 고려하지 않아도 단어 간의 의존성을 자연스럽게 파악할 수 있습니다. 그래서 이는 번역과 같은 자연어 처리에서 직관적으로 표현이 되는데요. 이 다음 예시가 자연어 처리에서 어떻게 어터션 메커니즘이 작동하는지를 간단하게 설명합니다. 그래서 이 주어진 단어가 이 이이라는 단어가 되겠고요. 이 전체 데이터는 키가 됩니다. 그래서 주어진 단어에 대해서 전체 단어와 얼마나 관계가 있는지를 가중치로 사용하여서 가중치가 높을수록 색깔이 더 진한 것을 알 수 있는데요. 그 가중치가 높을수록 이 키가 가지고 있는 밸류를 더 많이 참고해서 최종적으로 이 쿼리에 대한 표현을 어텐션을 통해서 계산할 수 있게 됩니다. 보시면 이 이이라는 명사가 어떤 단어와 가장 관련이 있을지를 봤을 때 이 스트릿이랑 애니멀이랑 스트릿이라는 단어의 유사도가 제일 높고 그래서 이 쿼리와 이 두 개의 키 간에 계산되는 가중치가 가장 높게 계산되고 그래서 이 애니멀과 스트릿에 해당하는 밸류를 가장 많이 참고하게 됩니다. 트랜스포머의 어텐션 연산은 스케일드 닷 프로덕트 어텐션을 사용하는데요. 이 수식은 다음과 같습니다. 아마 많이 보셨을 텐데요. 쿼리와 키 벡터를 내적한 값을 이제 이 키의 차원인 디케로 나눠서 스케일링 해주고 이를 소프트맥스 펑션에 통과시킵니다. 이 소프트맥스 펑션은 각각의 쿼리 쿼리와 키의 유사도 즉 가중치가 되고요. 이 값을 밸류에 곱해서 전체 밸류의 가중합으로 표현해 주게 됩니다. 또한 스케일드 닷 프로덕트 어텐션 같은 경우에는 셀프 어텐션에 해당되는데요. 이 셀프 어텐션이랑 퀄이나 키와 밸류 그 모든 것이 같은 도메인을 공유한다는 것입니다. 똑같은 입력 값에 대해서 서로 다른 파라미터가 곱해져서 쿼리 키 밸류를 구성하고 있습니다. 다음은 방금 전에 배웠던 스케일 닷 프로덕트 어텐션을 병렬적으로 확장시킨 멀티헤드 어텐션입니다. 차원이 큰 하나의 어텐션을 수행하는 것보다는 여러 개의 스케일 더 프로덕트 어텐션을 병렬적으로 처리하는 것이 더 효과적이라는 것인데요. 이 하나하나의 스케일 더 프로덕트 어텐션이 하나의 헤드가 됩니다. 그래서 이 하나의 헤드가 병렬로 처리되면서 각각의 헤드가 서로 다른 이 데이터의 특징을 잘 찾아내기를 잘 표현하기를 기대하는 것입니다. 네 그래서 트랜스포머 전체 구조를 살펴보면 인코더 구조와 디코더 구조로 이루어져 있고요. 각각의 인코더와 디코더는 6개의 동일한 레이어를 쌓아서 사용하고 있습니다. 이 어텐션 레이어 외에도 인코더와 디코더에 입력하기 전에 포지셔널 인코딩이라는 기법을 사용하는데요. 이 순서에 대한 정보를 주기 위해서 사인 함수와 코사인 함수를 사용하여서 기존의 RNN을 사용하지 않더라도 각각의 시퀀스에 대한 정보를 이 포지셔널 인코딩을 사용해서 표현하고 있습니다. 이제 그 외에도 이 모델을 살펴보면 여기 에드앤 롬이라는 부분이 있는데요. 이 멀티헤드 어텐션이 일어난 이후에 레지듀얼 커넥션과 레이어 노멀라이제이션을 사용하는 그런 테크닉도 추가되어 있습니다. 뭐 그 외에도 다양한 중요한 부분들이 트랜스포머에 포함되어 있지만 이제 우리는 트랜스포머를 배우려고 하는 것이 아니라 결국에는 이 트랜스포머를 CTR 예측에 어떻게 사용해야 했느냐 때문에 간단히 이 부분을 리뷰했는데요. 이제 다시 돌아와서 이 비스티 모델에서 사용한 구조를 살펴봅시다. 네 다음은 비스티의 전체 구조입니다. 이 마지막 예측을 하는 것은 똑같이 클릭 여부가 될 텐데요. 이제 여기서 그동안의 CTR 모델과 가장 큰 차이점은 바로 이 입력값 부분입니다. 유저 BA뷰 시퀀스를 그대로 CTR 예측 모델의 입력 값으로 넣어주었다는 것인데요. 과거에 유저가 소비했던 아이템들의 집합이 아닌 그 시퀀스까지 이 모델이 표현하여서 최종적으로 현재 타겟 아이템에 대한 CTR을 더 정확하게 구하겠다는 것이죠. 그래서 여기 트랜스포머 레이어가 있고요. 그 외에 아더 피처 같은 경우에는 시퀀스 피처가 아닌 그냥 기존에 기존에 CTR 예측 모델에서 많이 사용되던 유저 피처나 컨텍스트 피처가 있고요. 이것들은 그냥 인베딩 이후에 바로 반영이 되고요. 이제 이 시퀀스 피처 거기다가 우리가 예측해야 되는 아이템까지 한 번에 묶어서 이 전체 리스트가 트랜스포머 레이어의 인풋으로 들어가게 됩니다. 그리고 이제 이 부분을 보시면은 트랜스포머 레이어라고 했지만 트랜스포머의 인코더 부분만을 사용했습니다. 그래서 디코더 부분을 제외하고 이 인코더 부분만 이 안에 넣어서 전체 시퀀스를 적절하게 레프레젠테이션 하고 있습니다. 다음 부분은 비스티 모델에서 사용하는 트랜스포머 인코더 레이어를 수식으로 나타내는 것입니다. 사실 기존의 트랜스포머와 완전 동일하고요. 먼저 트랜스포머의 입력 값 즉 아까 유저 BA뷰 시퀀스 전체 플러스 현재 예측하려고 하는 타겟 아이템 전체가 입력 값이 되고요. 그 입력 값은 이 인베딩 2 매트릭스로 표현이 됩니다. 이제 여기에 쿼리와 키와 밸류에 해당하는 각각의 웨이트 매트릭스를 곱해서 셀프 어텐션 즉 스케일 닷 프로덕트 어텐션을 거치고요. 이제 이 셀프 어텐션 부분이 각각의 하나하나 헤드가 되어서 최종적으로 멀티헤드 어텐션 연산을 수행합니다. 이 멀티헤드 어텐션 이후에는 피드 포워드 뉴널 네트워크 을 통과하는데요. 이 피드 포워드 뉴럴 네트워크 앞 뒤로 에드앤 놈 즉 레이어 노말라이제이션과 스킵 커넥션이 추가가 되어 있습니다. 이 s가 멀티 애드 어텐션 이 거친 결과고요. 이 FFN이라는 것은 여기에 있는 에드앤 롬, 피드 포워드 뉴럴 네트워크 다시 에드앤 롬을 설명하고 있습니다. 이제 여기서 기존 트랜스포머와 조금 다른 차이점은 드롭 아웃을 사용하였고 그리고 액티베이션 펑션을 사용하여서 액티베이션 펑션 즉 피드 포워드 유얼 네트워크의 액티베이션 펑션으로 리키 엘류를 사용했다는 점이 기존 인코더 레이어와는 조금 다른 점입니다. 하지만 사실 이 부분은 크게 중요한 포인트는 아니에요. 네 이렇게 해서 하나의 인코더 레이어가 완성된 이후에 이 하나의 인코딩 레이어 즉 아이 번째 인코딩 레이어를 계속 쌓아서 아이 플러스 1번째 인코더 이렇게 블록으로 쌓을 수가 있습니다. 아까 트랜스포머는 총 6개의 블록을 사용했다고 했는데요. 이 비스티 모델도 트랜스포머 인코더 레이어를 n개 쌓아서 모델의 예측 정확도를 높이려고 시도하였습니다. 이 비스티 모델의 구조를 트랜스포머 인코더 레이어를 중심으로 살펴보았는데요. 이 비스티와 바로 이전 파트에서 배운 디아이엔 모델은 비교했을 때 어떠한 차이점이 있는지 간단하게 살펴보겠습니다. 먼저 din에서는 로컬 액티베이션 레이어를 통하여서 유저가 과거에 소비했던 아이템과 현재 아이템의 관련성을 구했는데요. 이 과정에서 단순하게 선플링으로 과거에 소비했던 아이템들을 더하는 방식을 사용했습니다. 하지만 BST 모델에서는 과거에 어떤 아이템들을 소비했는지 뿐만이 아니라 어떤 순서로 소비했는지 그 시퀀스까지 모델의 피처로 사용하여서 현재 아이템과의 관련성을 모델링하였습니다. 그래서 그 모델은 그 관련성은 트랜스포머 인코더 레이어를 사용하니 그리고 트랜스포머 레이어를 해당 모델에 응용한 것이기 때문에 본래 트랜스포머 모델과 어떻게 다르게 변형했는지 또 간단하게 살펴봅시다. 먼저 앞서 인코더 레이어 부분을 언급했듯이 이 비스티의 트랜스포머 인코더는 주로 아웃과 리키 렐루를 사용했다는 점이 다르고요. 그리고 인코더 블록을 6개까지 쌓지 않고 하나에서 4개만 쌓았는데요. 뒤에 언급하겠지만 한계를 사용했을 때 가장 좋은 예측 성능을 보였습니다. 또한 트랜스포머는 사인 코사인을 사용한 포지셔널 인코딩을 사용했는데요. 이 모델에서는 사인 코사인이 아니라 직접 다른 방식으로 포지셔널 인코딩을 사용하였습니다. 말 그대로 아이템을 소비한 시간 그 물리적인 시간을 사용했는데요. 현재 아이템을 예측하려고 하는 현재 시간과 과거에 그 아이템을 소비했던 시간의 차이를 포지셔널 인코딩을 사용했고 이렇게 사용했을 때 더 좋은 성능을 낸다고 말하고 있습니다. 참고로 트랜스포머 모델은 요즘 많은 테스크에서 소타에 준하는 성능을 보이고 있는데요. 각각의 다양한 테스크별로 이 트랜스포머의 핵심적인 구조는 유지하되 이 BST 모델이 응용한 것처럼 각각의 데이터셋에 맞는 약간의 변형과 응용이 이루어진다는 점을 중심으로 기억하시면 좋겠습니다. 그래서 마지막으로 모델의 성능을 비교한 결과입니다. 트랜스포머 레이어는 씨티 프리딕션 테스크에서도 소타의 성능을 보인다고 이야기하고 있고요. 그리고 트랜스포머 블록을 기존 원래 논문에서 6개나 쌓았는데요. 여기서 보시면은 하나 쌓았을 때보다 2개 3개를 쌓았을 때 오히려 성능이 감소함을 알 수 있습니다. 그 이유는 CTR 예측 테스크에서의 시퀀스는 우리가 보통 알고 있는 NLP 머신 트랜슬레이션 같은 태스크보다는 훨씬 더 덜 복잡한 시퀀스를 가지고 있기 때문으로 보입니다. 그래서 기존에 우리가 언급했던 와이드 앤 딥러닝 그리고 와이드 앤 딥러닝의 시퀀스 정보를 추가한 것 그리고 우리가 바로 전 파트에서 배웠던 dim 모델 들보다 이 BST 모델이 더 좋은 예측 성능 그리고 실제 온라인 테스트에서 CTR 개인이 이만큼 상승했다는 것을 볼 수 있습니다. 네 이상 bab어 시퀀스 트랜스포머 모델에 대한 내용이었고요. 이렇게 아홉 번째 강의가 모두 끝났습니다. 이번 강의를 통해서 다양한 딥씨티r 모델과 그 발전 과정을 학습하였습니다. 모두 수고하셨습니다."
}