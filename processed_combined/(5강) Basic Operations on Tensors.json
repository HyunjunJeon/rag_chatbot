{
  "lecture_name": "(5강) Basic Operations on Tensors",
  "source_file": "(5강) Basic Operations on Tensors_32.mp4_2025-12-04-103336581.json",
  "text": "안녕하세요. 부스트캠프 AI 테크 마스터 오영석입니다. 이번 시간은 파이토치 다섯 번째 시간으로서 베이직 오퍼레이션스 온 텐서스에 대해서 함께 배워보도록 하겠습니다. 먼저 목차입니다. 첫 번째 챕터에서는 지난 시간에 이어서 텐서의 모양 변경에 대해서 함께 살펴보도록 하겠습니다. 그리고 두 번째 챕터에서는 텐서의 여러 가지 기초 연산에 대해서 살펴보도록 하겠습니다. 네 그러면 첫 번째 챕터부터 함께 살펴보도록 하겠습니다. 먼저 캣 함수를 활용해서 텐서들을 연결시키는 방법에 대해 살펴보겠습니다. 여기서 캣은 컴캐트 네이트의 약자를 이야기합니다. 지난 강의에서 우리는 스택 함수를 통해 새로운 차원을 생성해서 텐서들을 결합해 보았습니다. 지금 배울 캣 함수 또한 텐서들을 연결시킨다는 점에서 스텝 함수와 유사한 면이 있는데요. 하지만 캣 함수는 스텝 함수와는 다르게 새로운 차원을 생성하지 않고 이미 존재하는 차원을 유지하면서 텐서들을 연결한다는 점에서 차이가 있다고 보시면 되겠습니다. 그러면 캣 함수를 활용해서 텐서들 간의 연결에 대한 표현을 살펴보겠습니다. 먼저 텐서 함수를 사용해서 아규먼트가 2행 2열인 2차원 텐서 비와 아규먼트가 1행 2열인 2차원 텐서 씨를 생성해 줍니다. 여기서 텐서 씨의 아규먼트를 살펴보면 스퀘어 블라켓이 2개인 것이 보이실 겁니다. 바로 텐서 씨는 1차원 텐서가 아니라 2차원 텐서를 가리키는 것입니다. 이와 같이 설정한 이유는 캣 함수에서 연결하고자 하는 텐서들은 같은 차원을 가져야 하기 때문입니다. 그러면 이제 두 텐서를 연결해 보도록 하겠습니다. 우선 두 텐서를 디맨전 제로 방향을 기준으로 연결하는 표현들을 살펴보겠습니다. 우선 공간에서의 표현을 살펴보면 2차원 텐서에서 디멘전 제로 방향은 이와 같이 행 방향을 가리키게 되겠죠 네 그랬을 때 두 텐서를 제로 방향을 기준으로 연결하게 되면 2행 2열의 행렬과 일행 2열의 행렬이 연결되는 것이니까 이행 3열의 크기를 가진 텐서로 연결이 될 것입니다. 이와 같이 두 텐서를 디멘전 제로 방향을 기준으로 연결하는 코드 표현은 캣 함수를 사용하면 되며 아규먼트로 연결하고자 하는 텐서들을 플로 묶어서 변수 뒤에 할당해 주면 되겠습니다. 그러면 캣 함수를 활용한 텐서들 간의 연결에 대한 첫 번째 코드 표현을 실습해 보도록 하겠습니다. 지난 시간에 스텝 함수를 활용해서 텐서들을 결합했던 실습을 기억하실 겁니다. 예를 들어 레드 채널, 그린 채널, 블루 채널의 이행 2열에 2차원 텐서들이 있을 때 스테이크 함수는 보시는 바와 같이 0 차원 축을 생성하여 3개 2차원 텐서를 결합하거나 그렇죠 혹은 1차원 축을 생성해서 3개의 텐서를 결합하거나 또는 2차원 축을 생성해서 이제 3개 2차원 텐서들을 결합하는 방식이었습니다. 이번에는 캣 함수를 활용해서 두 텐서를 결합해 보도록 하겠습니다. 먼저 01 2, 3의 요소를 가지는 이행 2열의 2차원 텐서 b와 4와 5의 요소를 가지는 일행 2열의 2차원 텐서 씨를 생성하도록 하겠습니다. 그리고 나서 이제 캣 함수를 이제 사용해서 그때 이제 아규먼트로 이 비와 씨를 투플로 묶어서 입력해 주고 디라는 변수에 할당하면 출력했을 때 이제 디는 0 1, 2, 3, 4, 5 의 요소를 가지는 상행 2열의 2차원 텐서로 b와 c가 디멘전 제로 방향으로 결합되는 것을 확인할 수가 있겠습니다. 그런데 텐서들 간의 연결을 꼭 디멘전 제로 방향으로 해야 한다는 법은 없겠죠 디멘전 원 방향으로도 두 텐서들을 연결할 수도 있는데요. 캣 함수의 매개 변수로 1을 주면 디멘전 1을 전달하여 디맨전 원 방향으로 연결을 하게 됩니다. 그런데 두 텐서를 연결하게 되면 오류가 발생하는 것을 볼 수가 있는데요. 왜냐하면 두 텐서의 크기가 다르기 때문입니다. 좀 더 자세히 말씀드리면 디맨전 원 방향으로 연결하게 되면 텐서 비의 열과 텐서 씨의 행이 연결되어야 하는데 텐서 비의 열의 개수는 두 개가 되고 텐서 씨의 행위 개수는 하나이기 때문에 개수가 달라서 연결이 될 수 없는 것입니다. 그러면 텐서 비의 열의 개수와 텐서 씨의 행위 개수를 맞춰주면 되겠죠. 그래서 리쉐인 메서드를 사용해서 텐서 씨를 이행 일렬로 만들어 주고 다시 디멘전 원방향으로 연결을 하면 에러 없이 연결을 할 수가 있게 됩니다. 그러면 캣 함수를 활용해서 텐서 간의 연결에 대한 두 번째 코드 표현을 실습해 보도록 하겠습니다. 이번에는 두 텐서 b와 c를 디멘전 원 방향으로 결합을 하기 위해서 캣 함수의 매개 변수로 1을 주면 되는데요. 하지만 실행을 시켜보면 두 텐서가 결합이 잘 되지 않는 것을 보실 수가 있겠습니다. 왜냐하면 텐서 b는 행위 개수가 2개인데 반해 텐서 씨는 행위 개수가 1개이다 보니 디멘전 원방향으로 결합을 할 수가 없는 것입니다. 따라서 이 두 텐서를 결합하기 위해서는 텐서 씨에 뷰를 바꿔주거나 리쉐입을 바꿔주시는 것이 필요한데요. 여기서는 리쉐입 메서드를 통해 일행 2열의 텐서 씨를 2행 1열에 텐서 씨로 바꾸어 실행해 줘보도록 하겠습니다. 그러면 이제 두 텐서가 디멘전 원 방향으로 잘 결합이 됨을 알 수가 있겠습니다. 이제 익스펜드 메서드를 활용해서 텐서의 크기를 확장하는 표현을 살펴보겠습니다. 차원의 크기가 1인 텐서가 주어졌을 때 해당 차원의 크기를 확장하기 위해서 익스펜드 메서드를 사용할 수가 있습니다. 예를 들어 크기가 일행 3열인 2차원 텐서 프를 생성했다고 하겠습니다. 그런데 이 텐서를 4행 3열로 확장하고 싶다면 익스펜드 메서드의 아규먼트로 4 콤마 3을 입력해 주시면 텐서 플을 4행 3열에 텐서 지로 확장을 할 수가 있겠습니다. 익스펜드 메서드를 활용한 텐서의 크기를 확장하는 코드 표현 또한 실습해 보도록 하겠습니다. 익스펜드 메서드를 활용하기 위해서는 우선 텐서의 행 또는 열 중의 하나가 1이어야 합니다. 여기서는 행을 1로 하는 일행 3열에 2차원 텐서 애플을 생성해 주도록 하겠습니다. 그리고 나서 해당 텐서를 4행 3열에 또 2차원 텐서로 확장하고자 익스펜드 메서드의 아규먼트로 4와 3을 입력하도록 하겠습니다. 그리고 나서 실행을 해주면요. 그러면 텐서 프가 이제 행 방향으로 4번 반복되는 것을 확인하실 수가 있겠습니다. 이번에는 리핀 메서드를 살펴보겠습니다. 앞에서 살펴본 익스펜드 메서드의 경우 주어진 텐서의 차원 중 일부의 크기가 1이어야 한다는 제한점이 있었습니다. 하지만 리핀 메서드는 이러한 제약이 없습니다. 다만 리핀 메서드는 텐서의 각 차원을 반복하여 실제 데이터를 복사해서 새로운 텐서를 생성하기 때문에 이 과정에서 새로운 메모리 공간이 할당되고 원본 텐서의 데이터가 이 메모리에 복사되므로 익스펜드 메서드보다 메모리의 효율성이 떨어진다는 단점이 있습니다. 그러면 리핀 메서드를 활용하여 텐서의 크기를 확장하는 코드 표현을 살펴보겠습니다. 예를 들어 텐서의 아규먼트가 이행 2열인 2차원 텐서 치를 생성했을 때 해당 텐서를 디멘전 제로 방향으로 두 번 반복하고 디멘전 원 방향으로 세 번 반복해서 텐서의 크기를 확장하고자 한다면 리핀 메서드의 아규먼트로 이 콤마 3을 입력하여 텐서를 생성하면 텐서의 크기를 확장하여 출력할 수가 있겠습니다. 이를 공간에서 살펴보면 아래의 그림과 같이 되겠습니다. 여기 그림을 살펴보면 텐서 h가 여기에 있죠? 네 이 텐서 치가 디맨전 제로 방향으로 두 번 반복했고 디멘전 원 방향으로 한 번 두 번 세 번 반복해서 텐서 아이가 만들어졌음을 확인할 수가 있겠습니다. 그러면 리핀 메서드를 활용해서 텐서의 크기를 확장하는 코드 표현을 실습해 보도록 하겠습니다. 리핀 메서드를 활용하기 위해서 먼저 텐서 함수를 사용해서 1, 2 3 4의 요소를 가지는 이행 2열의 2차원 텐서 치를 생성해 주고요. 이제 이를 행 방향으로 2배 열 방향으로 3배 확장하고자 한다면 리핀 메서드의 아규먼트로 이 콤마 3을 입력해 주시면 되고 실제로 이를 출력해 보면 1 2 3 4의 요소를 가지는 이행 2열의 2차원 텐서 h가 행방향으로 2배 그리고 열 방향으로 3배 확장됨을 확인할 수가 있겠습니다. 네 챕터 1에서 배운 내용을 정리해 보고자 하는데요. 첫째 절에서는 우리가 캣 함수를 활용하면 차원의 축 방향에 따라 텐서들을 연결할 수 있음을 배웠습니다. 그리고 두 번째 절에서는 익스펜드 메서드를 활용해서 주어진 텐서의 차원 중 일부의 크기가 1일 때 해당 차원의 크기를 확장할 수 있음을 배웠습니다. 그리고 세 번째 절에서는 리핀 메서드를 활용해서 텐서의 요소들을 반복하는 방식으로 크기를 확장하는 방법에 대해서 배워보았습니다. 두 번째 챕터는 텐서의 기초 연산인데요. 이번 챕터에서는 텐서의 산술 연산 비교 연산, 논리 연산에 대해서 살펴보도록 하겠습니다. 텐서의 산술 연산 중 더하기 연산부터 살펴보겠습니다. 크기가 동일한 두 텐서 에와 비가 있을 때 두 텐서 에와 비의 더하기 연산은 두 텐서의 각 요소들을 더한 값으로 출력이 됩니다. 아래의 공간에서의 표현을 보시면 네 각각의 요소들이 더해서 결괏값이 나오는 것을 알 수가 있겠죠? 네 이때 각 요소들을 더한 값으로 출력하기 위해서 에드 함수를 사용하시면 되겠고요. 이 에드 연산을 수행하면 더하기 연산을 수행할 수가 있겠습니다. 그러면 더하기 현상 코드의 표현을 실습해 보고 오도록 하겠습니다. 1, 2, 3, 4의 요소를 가지는 이행 2열의 2차원 텐서 a와 그리고 13 57의 요소를 가지는 이행 2열의 2차원 텐서 비를 더하기 위해서는 에드 함수를 사용하시면 되고 출력 값을 한번 살펴보면은 각 요소들이 더해진 이행 2열이 출력됨을 알 수가 있겠습니다. 그리고 객체의 메모리 주소를 살펴보기 위해서 고유 식별자 함수를 사용해 보면은 이제 각각이 다 다르다는 것을 이제 확인할 수가 있겠습니다. 이번에는 인플레이스 방식을 활용한 더하기 연산을 살펴보겠습니다. 인플레이스 방식은 메모리를 절약하며 텐서의 값을 업데이트할 수 있는 연산이기 때문에 자주 사용되는 방식 중 하나이기도 합니다. 텐서 a에 텐서 비를 인플레이스 방식으로 더해서 a의 값을 수정하고자 할 때 애드 언더스코어 메서드를 사용하시면 되겠습니다. 다만 인플레이스 방식의 연산은 추가적인 메모리 할당이 필요 없기 때문에 메모리 사용량을 줄일 수 있다는 장점이 있지만 이후에 배울 오토그래드와의 호환성 측면에서 문제를 일으킬 수가 있습니다. 따라서 인플레이스 연산은 자주 사용되지만 신중하게 사용할 필요가 있습니다. 그러면 인플레이스 방식을 활용하여 더하기 연산을 수행하는 코드 표현을 실습해 보도록 하겠습니다. 인플레이스 방식의 더하기는 텐서 a에 텐서 b를 더해주고자 한다면 에 닷 애드 언더스코어 b를 입력해 주시면 되고 이를 출력해보면은 네 두 텐서가 더해졌음을 알 수가 있겠습니다. 그리고 아이디 함수를 통해 고유 식별자를 한번 확인해 보면은 해당 고유 식별자와 그리고 텐서 에의 고유 식별자가 동일하다는 것을 확인할 수가 있겠습니다. 따라서 더하기를 하더라도 인플레이스 방식은 추가적인 메모리 할당을 하지 않는다는 것을 확인할 수가 있겠습니다. 이번에는 크기가 다른 두 텐서의 더하기 연산을 살펴보겠습니다. 이행 2열의 2차원 텐서 씨와 요소가 두 개로 이루어진 1차원 텐서 디가 있을 때 크기가 다른 두 텐서를 더하면 어떻게 될까요? 에러가 뜰 것 같지만 그렇지 않습니다. 아래의 공간에서 표현과 같이 크기가 작은 1차원 텐서 d가 텐서 씨와 같은 크기의 이행 2열로 확장이 되어서 요소들을 연산하게 됩니다. 코드 표현 또한 더하기 연산 코드 표현과 동일하게 사용할 수 있다는 것을 여러분들께서 알아두시면 좋겠습니다. 그러면 크기가 다른 텐서의 더하기 현상 코드 표현을 실습해 보도록 하겠습니다. 1, 2, 4, 5의 요소를 가지는 이행 2열의 2차원 텐서 씨와 또 1과 3의 요소를 가지는 일행 2열의 1차원 텐서 d를 더하고자 할 때 사실 수학적으로는 가능하지 않은 이야기지만 프로그래밍 상에서는 가능합니다. 즉 이는 수학적 담론과 프로그래밍적 담론이 다르다는 것을 이야기해 주는 것이기도 합니다. 프로그래밍 상에서는 브로드 캐스팅 규칙에 따라 자동으로 텐서 뒤에 행차원이 확장이 되어 1313의 요소를 가지는 이행 2열의 2차원 텐서로 확장이 되게 됩니다. 그리고 이 둘을 더한 값을 또 이제 실행을 해주면 다음과 같은 결과가 나오게 되겠습니다. 이번에는 빼기 연산을 살펴보도록 하겠습니다. 크기가 동일한 두 텐서 이와 f를 빼는 연산은 앞에서 두 텐서의 더하기 연산에서 살펴보았듯이 두 가지 방식이 있습니다. 첫 번째는 텐서 프에서 텐서 1을 빼고자 할 때 서브 스트랙션 함수를 사용하는 것인데 서브 스트랙션을 줄여서 서브라고 표현하고 있습니다. 그리고 두 번째는 텐서 프에서 텐서 1을 인플레이스 방식으로 빼주는 방법입니다. 이때 사용하는 메서드는 서브 언더스코어 메서드가 되겠습니다. 이전 슬라이드에서 살펴본 더하기 연산에서와 같이 서브 스트랙션 함수와 메서드를 사용해서 두 텐서의 요소들의 차에 대한 결과를 쉽게 출력할 수가 있겠습니다. 이번에는 크기가 다른 텐서의 빼기 연산을 살펴보도록 하겠습니다. 크기가 다른 텐서의 빼기 연산도 마찬가지입니다. 이전 슬라이드에서 크기가 다른 텐서의 더하기 연산에서 살펴보았듯이 두 텐서의 크기가 다른 경우에 두 텐서의 차를 구하게 되면 크기가 작은 텐서가 크기가 더 큰 텐서에 맞춰서 크기가 확장이 이루어진 후 빼기 연산이 이루어지겠습니다. 크기가 다른 두 텐서를 빼는 코드 표현은 서브스트랙션 함수를 사용하시면 되겠고요. 공간에서 표현을 보시면은 더 직관적으로 우리가 볼 수가 있겠죠 네 확장이 된 후에 그리고 연산이 이루어져서 이와 같이 빼기 연산의 결과값들이 나오겠습니다. 그러면 빼기 연산 코드 표현을 실습해 보도록 하겠습니다. 빼기 연산도 더하기 연산과 마찬가지입니다. 2 3, 4 5의 요소를 가지는 이행 2열의 2차원, 텐서 2와 2 4, 6, 8의 요소를 가지는 이행 2열의 2차원 텐서 프가 있을 때 프 댄스에서 이 텐스를 빼고자 할 때는 서브 함수의 아규먼트로 텐서 프와 텐서 2를 차례로 입력해 주시면 되겠습니다. 한번 실행을 시켜 보겠습니다. 네 뺄셈 연산이 가능한 것이 보이시죠? 인플레이스 방식에서도 마찬가지입니다. 프 닷 서브 언더 스코어 1을 해주시면은 프와 2가 빼지는 연산이 실행되겠습니다. 한번 코드를 실행해 보겠습니다. 네 같은 결과가 나오는 거 보이시죠? 그리고 또 이제 만약에 텐서 g와 텐서 h와 같이 크기가 다르더라도 텐서 h의 열 차원이 또 확장이 돼서 연산이 가능하겠습니다. 그래서 이와 같이 연산 결과가 나오는 것도 알 수가 있겠습니다. 이번에는 스칼라곱 연산에 대해 살펴보겠습니다. 스칼라곱 연산은 텐서의 각 요소의 동일한 스칼라 값 즉 실수를 곱하는 연산을 의미합니다. 예를 들어서 스칼라가 2인 아이와 텐서 함수의 아규먼트가 1행은 1 콤마 2, 2행은 3 콤마 4의 요소를 가진 2행 2열의 2차원 텐서 제를 생성했을 때 스칼라곱 연산을 하게 되면 공간에서의 표현과 같이 텐서 제의 각 요소의 스칼라 값 2를 곱한 요소들이 나타나게 됩니다. 그리고 이러한 스칼라와 텐서의 스칼라 곱 연산을 하는 코드 표현은 몰 함수를 사용해서 연산을 수행할 수가 있겠습니다. 여기서 멀은 멀티플레이의 약자를 의미합니다. 그러면 스칼라곱 연산 코드 표현을 실습해 보도록 하겠습니다. 스칼라 값으로 1을 가지는 스칼라 아이와 그리고 1 2, 3 4를 요소로 가지는 2차원 텐서 제를 스칼라 곱하는 함수는 멀 함수이고 실제로 우리가 출력을 해보면 스칼라 곱이 이루어졌음을 확인할 수가 있겠습니다. 요소별 곱하기 연산 또한 월 함수를 사용하시면 되겠고요. 그리고 크기와 같은 두 텐서를 각 요소별로 이렇게 이제 곱해서 출력을 할 수가 있겠고요. 뿐만 아니라 인플레이스 방식으로도 요소별 곱하기 연산이 가능합니다. 그래서 이와 같은 방식으로 출력해도 네 같은 결괏값이 나온다는 거 보실 수가 있겠고요. 그리고 또 크기가 다르더라도 텐서 엔이 텐서 엠과 같은 크기로 확장해서 요소별 곱하기 연산이 가능하겠습니다. 네 그래서 이와 같은 결과가 나오는 것을 알 수가 있겠습니다. 요소별 나누기 연산은 디브 함수를 사용하게 되며 크기가 같은 두 텐서 5와 피에 대하여 5의 각 요소를 피의 각 요소로 나누고자 할 때는 우리가 그 아규먼트를 차례대로 오와 피 이와 같이 작성을 해 주시면 되겠습니다. 실제로 실행을 해보면 네 5의 각 요소들이 피의 각 요소들로 나누어진다는 것을 확인하실 수가 있겠습니다. 인플레이스 방식으로도 요소별 나누기 연산이 가능한데요. 그런데 이제 실행을 해보면 네 이와 같이 에러가 뜨는 것을 확인할 수가 있습니다. 이것은 이제 데이터 타입을 부동 소수점수 타입으로 맞춰주시지 않아서 그러신 건데요. 데이터 타입을 부동소수점수 타입으로 맞춰준 후에 실행을 하게 되면은 정상적으로 동작한다는 것을 확인하실 수가 있겠습니다. 그리고 크기가 다른 이제 텐서에 대해서도 텐서 알이 텐서 큐의 크기만큼 이제 확장을 해서 네 요소별 나누기 연산이 가능하다는 것을 확인하실 수가 있겠습니다. 이러한 모습은 교육 쪽에서 이들이 소득 재산 감축을 두 가지가 있는데 우선 이전 슬라이드에서 높은 사회 감축이나 사용률은 지금 보면 제3세 등 기능 감축이 있지만 1 2 3 4를 요소로 가지는 2차원 텐서 s에 대해서 각 요소를 재곱하고자 할 때 파워 함수를 사용하게 됩니다. 그때 이제 파워 함수에 s와 2를 넘겨주면 텐서 s의 요소별 제곱을 구할 수가 있습니다. 만약에 각 요소를 세제곱 하고자 한다면 아규먼트를 2에서 3으로 변경하여 입력해 주시면 되겠습니다. 그럼 한번 출력해 보도록 하겠습니다. 출력을 했을 때 각 요소들을 살펴보면은 s 제곱 같은 경우에는 각 요소들이 제곱됐다는 것을 확인하실 수가 있겠고요. s 세제곱 같은 경우에는 각 요소들이 이제 세 제곱 되었다는 것을 확인하실 수가 있겠습니다. 이번에는 5 4 3 1을 이제 요소로 가지는 2차원 텐서 t와 1 2 3 4를 요소로 가지는 2차원 텐서 율을 각각 대응하는 요소들만큼 거듭 재곱하기 위해서도 파워 함수를 사용한다는 것을 우리가 확인할 수가 있습니다. 그럼 실제로 한번 출력을 해보도록 하겠습니다. 실제로 출력을 했을 때 그 결과를 살펴보면은 이제 영행 영렬의 값부터 살펴보면 5가 나와 있는데 이것은 네 5와 1 각각 대응에서 제곱을 했을 때 5의 1 제곱의 결괏값인 것을 알 수가 있겠습니다. 영행 1열의 값은 4의 제곱이죠. 네 4와 2가 대응하니깐요. 실제로 16이 나오는 것도 확인할 수가 있겠습니다. 일행 역렬의 값은 3의 세제곱 그래서 27이 나오는 거 확인할 수가 있겠고요. 1행 1열의 값은 2의 네제곱 그래서 16이 되는 것도 확인할 수가 있겠습니다. 그리고 또한 인플레이스 방식으로도 출력이 가능합니다. 그래서 인플레이스 방식으로 출력을 했을 때 결괏값 또한 같다는 것을 우리가 확인할 수가 있겠습니다. 1 2 3 4를 요소로 가지는 2차원 텐서 s에 대해서 각 요소의 제곱근을 구하고자 할 때에도 파워 함수를 사용하게 됩니다. 그때 이제 파워함수의 매개 변수로 스 아규먼트로 2분의 1을 넣어주시면 우리가 제곱근을 구할 수가 있겠습니다. 마찬가지로 세 제곱근을 구하고자 한다면 아규먼트의 표현만 2분의 1에서 3분의 1로 변경을 해 주시면 되겠습니다. 그럼 실제로 한번 출력을 해보도록 하겠습니다. 그러면 그 결괏값들이 나오는 것을 확인할 수가 있겠습니다. 두 텐서의 요소 값이 같은지를 비교하기 위해서 1행 사열에 1차원 텐서 브와 w를 생성해 주었고 이제 이큐 함수를 써서 이제 비교해 보고자 합니다. 여기서 eq는 이제 이 꼴을 의미하는 것입니다. 그래서 실제로 실행을 해보면 같은 요소는 이제 트루를 출력하는 것을 알 수가 있겠고요. 그리고 다른 요소 같은 경우에는 이제 퍼스를 출력하는 것을 확인하실 수가 있겠습니다. 이차 같은 13태를 비교해 보면 전반에서의 팀 3대 2중 첫 번째 요소는 906은 20 있습니다. 반대로 두 텐서의 요소 값이 다른지를 비교하기 위해서는 에이 함수 즉 낫 이퀄 함수를 써서 비교해 보면 다른 요소의 경우에는 트루 그리고 같은 요소 같은 경우에는 이제 펄스를 출력하는 것을 확인하실 수가 있겠습니다. 네 그래서 실제로 실행을 해보시고요. 또한 이제 텐서 v의 요소들이 텐서 w의 요소보다 큰지를 비교하기 위해서는 gt 함수 즉 그레이트로 된 함수를 써서 이제 우리가 비교할 수가 있겠고요. 그리고 또 함수를 크거나 같은 지를 비교하기 위해서는 g2 함수 즉 그레이트로 된 or 이퀄 함수를 사용해 보시면 되겠습니다. 네 다 실행해 보시길 바랍니다. 또 이제 반대로 이제 작은지를 비교하기 위해서는 LES dan 함수를 실행해 보시면 되겠고요. 그리고 마지막으로 작거나 같은지를 비교하기 위해서는 le 함수 즉 LES dan or e콜 함수를 사용하시면 되겠습니다. 그래서 실행해 보시길 바라겠습니다. 롤리곱 연산을 위한 함수는 로지컬 언더스코어 앤드 함수를 사용하게 됩니다. 그리고 그 아규먼트로 비교하고자 하는 텐서 x와 텐서 y를 입력해 주시면 되겠습니다. 실제로 이제 출력을 해보면 두 요소가 모두 투루일 때만 그 출력 값이 투루임을 알 수가 있겠습니다. 논리합 연산을 위한 함수는 로지컬 언더스코어 우월 함수를 사용하게 되겠으며 그리고 그 아규먼트로는 비교하고자 하는 텐서 스와 텐서 y를 입력해 주시면 되겠습니다. 실제로 이제 출력을 해보면 우리는 두 요소 중 하나 이상이 트루일 때 그 결과값으로 트루를 출력한다는 것을 알 수가 있겠습니다. 배타적 논리합 연산을 위한 함수는 로지컬 언더스컬 스오어를 사용하시면 되겠습니다. 그리고 그 아규먼트로는 비교하고자 하는 텐서 x와 텐서 y를 입력해 주시면 되겠고요. 실제로 이제 출력을 해보면 두 요소 중 하나만 트루일 때 트루로 출력함을 우리가 알 수가 있겠습니다."
}