{
  "lecture_name": "GenAI CV part1",
  "source_file": "GenAI CV part1_74.mp4_2025-12-04-104031353.json",
  "text": "안녕하세요. 이번 시간에는 디퓨저스를 활용해서 저희가 앞서 이제 배웠던 이 디퓨전 모델들을 한번 활용해보는 그런 실습 시간을 가져보려고 합니다. 제 소개를 드리자면 저는 이제 고려대학교 산업경영공학과 강필성 교수님의 연구실인 DSB의 에 의해서 석박 통합 과정으로 있는 허재혁이라고 하고요. 저는 주로 이미지 데이터를 활용해서 다양한 연구를 수행하고 있습니다. 그래서 오늘은 이제 앞서 말씀드린 것처럼 이 디퓨전이라는 모델을 쉽게 다루기 위해서 제공된 그런 모듈이 있습니다. 그래서 디퓨저스라는 것이 있는데 이 디퓨저스에 있는 어 스테이블 디피전 엑셀 모델을 활용해서 여러 가지 앞서 배웠었던 다양한 테스크들 그리고 어 파인튜닝 방법들을 같이 활용해 보려고 합니다. 그래서 우선은 여기 나타나 있는 내용처럼 좀 필요한 패키지들이 많이 있는데요. 저희가 제공 드리는 이 서버에 도커 이미지 내에 이미 설치가 되어 있기 때문에 혹시나 안 깔려 있다라는 메시지가 나오면은 여기 있는 세팅에 맞춰서 설치를 해 주시면 되고요. 그리고 만약에 문제가 없다라고 하시면은 그대로 진행을 해서 사용을 해 주시면 될 것 같습니다. 어 일단 필요한 패키지 인폴트를 해 와야 되는데요. 여기서도 마찬가지로 혹시나 인폴트를 수행하는 와중에 이러한 에러가 발생한다고 한다면 어 여기에 있는 내용들을 실행해서 어 해결을 해 주시면 좋을 것 같습니다. 다음으로는 이제 기본적인 라이브러리들 인폴트를 하고 그리고 이제 엑셀러레이트라는 걸 또 인폴트를 해서 사용을 할 텐데요. 중간중간 코드에 엑셀러레이트라는 코드가 많이 등장을 할 겁니다. 이 액셀러레이트는 저희가 아무래도 제공받은 이제 GPU 환경이 v10이라는 GPU를 사용하고 그 GPU에 대한 메모리가 32기가 차지하고 있는데 이 생각보다 스테이블 디퓨전의 모델이 굉장히 메모리를 많이 차지하게 됩니다. 그래서 이 메모리를 좀 효율적이고 어 연산을 좀 더 빠르게 수행할 수 있도록 도와주는 그런 역할을 하는 것 중에 하나다라고 보시면 될 것 같고요. 그리고 이미지를 다루기 때문에 터치 비전의 트랜스폼을 활용해서 이미지 처리를 해주고 그리고 이 peft 또 이제 앞선 이제 이론 실습 LLM 쪽에서도 들으셨죠? 그래서 이 peft는 이제 파라미터 에피션트 파인튜닝을 위해서 제공되는 그런 모듈 중에 하나입니다. 이 방법을 통해서 로라라는 어댑터를 사용하여 파인튜닝도 한번 진행을 해 볼 예정입니다. 그리고 오늘 이제 대망의 이제 메인인 디퓨저스라는 것이 있는데 디퓨저스에서 여러 가지 클래스들을 많이 불러오게 될 겁니다. VA를 위한 어떤 클래스라든지 스케줄러 파이프라인 그리고 유닛 등등 다양하게 이제 사용을 하게 될 거고요. 그 외에는 하나씩 코드를 실행하면서 같이 살펴보면 좋을 것 같습니다. 우선은 먼저 모델을 선언하고 그리고 저희가 먼저 해볼 것은 텍스트를 입력으로 넣어서 이미지를 생성해 내는 그런 인퍼런스 과정을 한번 실습을 해보려고 합니다. 그래서 파이프라인이라는 걸 이용해서 스테이블 디퓨전을 불러올 텐데요. 이 파이프라인이라는 거는 이 스테이블 디퓨전 구조 안에 여러 가지 모델들이 많이 포함되어 있습니다. 그래서 어 이 유닛 모델이나 브에 그리고 또는 노이즈 스케줄러 그리고 프로세서 등등 다양한 구성 요소들이 존재하게 되는데 이 구성 요소들을 이제 하나의 종단 간 클래스로 묶어서 확산 모델을 이제 추론을 할 때 디퓨전 모델을 추론을 할 때 간단하게 실행할 수 있는 방법을 제공하는 그런 클래스라고 보시면 될 것 같아요. 그래서 이 파이프라인 안에서는 뭐 하나의 스케줄러만 딱 지정돼서 그것만 사용되는 것이 아니라 또 여러 가지 스케줄러를 같이 호환 가능하게끔 구성이 되어 있기 때문에 원하시는 걸 선택해서 또 적용해 볼 수가 있습니다. 그래서 이 파이프라인은 어 여기 있는 스테이블 디퓨전 엑셀 파이프라인이라는 것을 사용을 할 거예요. 그래서 이 스테이블 디퓨전 엑셀 파이프라인이라는 거는 이 디퓨전 파이프라인 클래스를 상속받아서 정의가 되게 됩니다. 그리고 이 사전에 학습된 어떤 모델들을 불러오기 위해서는 이 파이프라인 점 프롬 프리트레인이라는 메서드를 함께 활용해서 프리트레인 된 모델이 있는 그 위치 이 주소를 같이 또는 아이디를 입력으로 받아서 불러올 수 있게 됩니다. 그리고 여기 두 번째로 보시면 이 리파이너라는 게 또 존재하게 됩니다. 리파이너는 한 번 디퓨전 프로세스를 거쳐서 이미지를 생성하고 그거를 좀 더 고퀄리티로 만들기 위해 추가적인 디퓨전 프로세스를 또 거쳐준다. 리노이징 프로세스를 거쳐준다라고 보시면 될 것 같습니다. 그래서 우선은 기본적인 스테이블 디퓨전 파이프라인 이 파이프라는 이름으로 객체를 하나 지정을 하고요. 그리고 더 나은 퀄리티의 이미지를 생성하기 위해서 리파이너라는 거를 추가적으로 또 생성을 해줬다라고 보시면 될 것 같습니다. 우선 실행을 한번 해볼까요? 그러면 인폴트를 하고 그다음에 실행을 해 주시면 됩니다. 아마 여기서 이제 저 같은 경우는 미리 다 모델 캐시들을 다 다운 받아놨기 때문에 조금 시간이 여러분보다 덜 걸릴 수도 있긴 하지만 다운이 안 되셨던 분들은 그냥 실행하셔서 또 금방 됩니다. 오래 걸리지 않으니까 같이 실행하시면서 따라와 주시면 좋을 것 같습니다. 다음으로는 저희가 불러온 이 파이프라인의 구성 요소가 어떻게 되어 있는지를 함께 확인해 볼 수가 있는데요. 이 파이프 안에 컴피그라는 어트리뷰션이 있습니다. 이 컴피그라는 것을 지정해서 불러오게 되면은 이 안에 어떤 구성 요소들이 존재하는지 확인할 수가 있습니다. 그래서 브에 같은 경우는 뭘로 구성이 되어 있는지 뭐 텍스트 인코더 트랜스 포머스 뭐 이렇게 트랜스 포머스로 돼 있죠 그다음에 토크 나이저 유닛 스케줄러 뭐 등등 다양하게 존재하게 됩니다. 그리고 이 스테이블 디퓨전 파이프라인에는 총 7가지 중요한 요소들로 구성이 되어 있는데 어 하나씩 살펴보면은 피처 익스트랙터 세이프티 체커 세이프티 체커 같은 경우는 좀 한풀한 콘텐츠들을 생성하는 걸 방지하기 위해서 구성되는 컴포넌트 중 하나고요. 그리고 스케줄러라는 텍스트 인코더 토크나이저 유닛 VA 또 이렇게 있습니다. 그리고 이렇게 각 구성 요소마다 컨피규레이션들이 제이슨 파일로 지정되어 있기 때문에 또 따로 한번 궁금하신 분들은 살펴보실 수가 있고요. 그다음에 이 파이프라인 안에서 스케줄러를 하나로 지정된 것만 사용되는 것이 아니라 여러 가지 호환 가능한 것들을 이제 바꿔가면서 사용할 수 있다라고 말씀을 드렸었는데요. 그 호환 가능한 스케줄러가 무엇이 있는지 보기 위해서는 이 파이프 안에 스케줄러 안에 이 컴퓨터 버스라는 것이 있습니다. 이걸 실행해 보시면은 어 이 파이프라인에서 사용할 수 있는 여러 가지 스케줄러들이 이렇게 나타나 있는 것을 볼 수가 있습니다. 그래서 저희는 어 이 디피엠 솔버 멀티스텝 스케줄러라는 것을 이제 사용하려고 하고요. 그래서 이렇게 기존 파이프에 있는 스케줄러를 이걸로 바꿔서 사용을 해보도록 하겠습니다. 그럼 이제 첫 번째로 한번 이미지를 생성을 해볼까요? 그러면 프롬프트로는 어스트로넛 이너 정구 콜드 컬러 팔렛 뮤트 컬러스 디테일 8k 이렇게 있습니다. 그래서 정글 안에 있는 어떤 우주 비행사 그리고 좀 차가운 색상과 이런 좀 디테일한 면들 그리고 고해상도 이런 것들을 이제 텍스트로 입력으로 넣어서 이 파이프라인 안에 바로 이 프롬프트를 첫 번째 인자 값으로 돼 있기 때문에 바로 프롬프트를 넣으면 됩니다. 넣고 나서 이미지를 불러올 때는 이 점 이미지 하시고 그다음에 어 안에 있는 원소 값을 불러와서 이렇게 시각화를 해 볼 수가 있습니다. 이 불러올 때는 시간이 조금 걸리게 돼요. 그래서 이 디노이징 프로세스에 필요한 어떤 스텝이나 이런 것들이 있기 때문에 어 대략 지금 제가 나오는 환경에서는 한 13초 정도 아마 여러분도 동일 환경에서 돌리실 테니까 13초 정도 소요될 것 같습니다. 보시면은 저희가 요청한 프롬프트대로 얼추 생성이 되었죠 정글 안에 있는 우주 비행사 그래서 지금 굉장히 고퀄리티의 이미지가 잘 나타나는 것을 볼 수가 있습니다. 지금 보시면은 어 이 스테이블 디피전 엑셀에서 생성되는 이미지 크기가 어 디폴트로는 1024바이 1024 이렇게 생성이 됩니다. 근데 이 크기를 무조건 정해진 걸로 생성을 해야만 하는 것은 아니고 사용자가 원하는 이제 크기로 바꿔서 생성을 할 수가 있어요. 그래서 이 안에 이 파라미터 값을 미스트 그리고 화이트 이렇게 두 개에 대해서 원하는 값으로 조정해서 그 크기에 맞게 이미지를 또 생성을 해 볼 수가 있습니다. 그러면 저희는 아까 전에 기본으로 이제 설정되어 있던 거는 1024바이 1024로 생성이 되었기 때문에 이번에는 가로 넓이 1024 그리고 세로 넓이 512 이렇게 한번 또 생성을 해보도록 하겠습니다. 네 보시면은 아까랑 다르게 세로 넓이가 절반으로 줄었죠 근데 조금 결과가 살짝 다르게 나오는 것을 볼 수가 있어요. 이거는 당연히 디노이징 프로세스 동안 이제 랜덤성이 또 들어가 있기 때문에 매번 실행할 때마다 약간은 좀 다른 그런 이미지들이 생성되게 됩니다. 한 번 다시 실행을 해볼까요? 그리고 이미지 해상도의 크기가 바뀌었기 때문에 이전보다 더 작아졌죠. 그래서 이 생성하는 데 걸리는 시간이 조금 더 줄어들었다라고 볼 수가 있습니다. 그러니까 결국에는 약간의 트레이드 오프가 있는 거겠죠. 이미지를 생성할 때 사용하는 해상도가 크면 클수록 추론하는 데 시간이 더 오래 걸리지만 좀 더 크고 고해상도 이미지를 얻을 수 있다. 반면에 이 고해상도를 약간 포기하되 추론 속도를 좀 더 빠르게 더 많은 이미지를 생성해 볼 수 있다. 이러한 트레이드오프가 존재하는 것을 알 수가 있습니다. 그리고 지금 보시면 프롬프트를 넣을 때 무조건 한 장의 이미지만 생성을 하게 되어 있잖아요. 근데 이것도 사용자가 지정을 해서 원하는 개수만큼 이미지를 또 생성해 볼 수가 있습니다. 그때는 여기에 있는 넘 언더바 이미지스 언더바 퍼 언더바 프롬프트 이거를 사용해서 여기에 내가 이 프롬프트를 통해서 생성하고자 하는 이미지의 개수를 입력해 주시면 됩니다. 그럼 여기서 4라고 입력했기 때문에 이 프롬프트에 대한 4개의 이미지가 이제 생성되게 됩니다. 대신에 4개를 생성하는 만큼 시간이 조금 더 늘어나겠죠. 그리고 여기에는 그러면 4개의 이미지가 생성이 될 테고 이 4개의 생성된 이미지를 메이크 이미지 그리드라는 이제 함수를 위에서 인폴트할 때 불러왔었어요. 그래서 디퓨저스의 유틸스 안에 들어있는 함수인데 이거를 통해서 가로세로에 대한 행렬 개수를 정해서 이렇게 이미지들을 붙여줄 수가 있습니다. 한 번에 이렇게 이미지들이 생성되는 것을 볼 수가 있고요. 아 그리고 제가 추가적으로 또 그 말씀을 드리자면은 이 파이프라인을 통해서 생성되는 이미지는 넘파이 어레이 형태로 이제 반환되는 것이 아니라 flow로 이제 반환이 됩니다. 파이썬 이미지 라이브러리라는 pil 그 형태의 포맷이 있는데 그 형태로 바로 불러와 지기 때문에 이 이미지를 프린트 하게 되면 바로 그 이미지 자체가 이렇게 나타나게 됩니다. 그리고 또 이 추론 속도를 조금 조절하기 위해서는 인퍼런스 할 때 필요한 스텝스를 또 바꿀 수가 있어요. 보시면은 nm 인퍼런스 스텝스라는 파라미터에다가 30만큼 주면은 기존보다 조금 더 빠른 속도로 생성을 할 수가 있습니다. 왜냐하면 앞에서 안 적었을 때도 사실 내부에서는 이 값에 대한 어떤 밸류가 들어가 있거든요. 그 디폴트로 기본값으로 들어가 있는 값이 50입니다. 그래서 50보다 작은 값을 주게 되면은 좀 더 빠르게 이미지를 생성할 수가 있겠죠. 대신에 퀄리티는 조금 안 좋을 수도 있어요. 그런 또 트레이드오프가 있습니다. 보면은 위에서는 지금 총 21초가 걸렸죠. 4개를 생성하는데 여기서 보시면은 한 12초 정도 소요되는 것을 볼 수가 있습니다. 하지만 이게 또 디노이징 프로세스의 스텝 수를 줄였다고 해서 엄청 이렇게 또 결과가 안 좋게 나오거나 또 그런 건 아니고요. 그리고 사실 또 이 그림이라는 영역이 사실 각자의 어떤 취향도 있고 스타일이 또 있기 때문에 뭐 거기에 맞게끔 목적과 취향에 맞게 적절하게 조정해서 나중에 무언가를 또 프로젝트를 하시거나 연구를 하실 때 활용을 하시면 좋을 것 같습니다. 그리고 다음으로는 저희가 그 기존 이미지 파이프라인 디퓨전 파이프라인만 쓰는 것이 아니라 그 뒤에 리파이너라는 거를 또 추가로 같이 사용을 한다라고 말씀을 드렸잖아요. 그러면 이번 시간에는 리 파이널을 한번 또 같이 이어서 써볼 겁니다. 그래서 위에 있는 코드를 보시면은 앞에서 이제 했었던 것과 동일한 파이프라인으로 프롬프트를 넣어서 이미지를 생성하게 됩니다. 네 여기 또 처음 보는 이 파라미터가 존재하게 됐는데 디노이징 엔드라는 거는 디노이징 프로세스의 어떤 진행 그 단계를 말합니다. 0.8이라는 거는 전체 중의 80%까지만 디노이징을 해라 이런 뜻이라고 볼 수가 있습니다. 그래서 0부터 1 사이의 값이 이 디노이징 엔드의 값으로 들어가게 되고요. 그럼 여기는 0.8까지 생성을 했고 그러면 0.8까지 생성된 이미지가 이제 이미지 베이스에 담겨 있는 거죠. 그러면 이 이미지 베이스를 어떻게 또 활용을 하느냐 이 리파이너라고 아까 전에 정의했었던 또 파이프라인에다가 입력을 해 줍니다. 그리고 이때는 또 디노이징 스타트라는 이제 파라미터가 존재하게 되는데 아까 전에 엔드를 0.8에서 끝냈기 때문에 여기서는 0.8에서 시작하게끔 해줄 수가 있습니다. 그래서 이미지 베이스를 반환하고 그 이미지 베이스를 기준으로 리파이너에다가 입력으로 사용한다 그러면 이미지 리파인이라고 또 정제된 좀 더 퀄리티를 향상시키고자 했던 이미지가 여기 담겨 있는 거죠. 그럼 실행을 해서 확인을 해보시면 어 지금 이미지 베이스와 이미지 리파인 두 가지를 같이 붙여서 한번 비교를 해볼 거예요. 그럼 어떤 결과가 나오냐면은 첫 번째에서는 디노이징 프로세스를 전부 다 끝내지 않았잖아요. 그렇기 때문에 약간의 노이즈가 완벽하게 제거되지 않는 그런 모습을 볼 수가 있습니다. 반면에 이거를 리파이널을 통해서 계산했을 때 굉장히 좀 많은 정보들이 추가가 되었죠. 좀 디테일한 요소들이라든지 헬멧에 비춰진 어떤 반사된 내용이라든지 위에 있는 이 그림들과 비교하면은 이 그림과 비교하면은 또 굉장한 또 차이가 있죠. 근데 이것도 어디까지나 각자의 취향에 따라 좀 다른 것 같습니다. 이게 또 리 파이널을 썼다고 그래서 고퀄리티는 맞지만 뭐 각자 입장에서 고퀄리티가 따로 있는 거기 때문에 어 이것도 또 하나의 이미지를 변환할 수 있는 정지할 수 있는 방법으로써 또 알고 넘어가시면 좋을 것 같습니다. 그리고 이 리파이널을 사용할 때 꼭 반드시 이전 파이프라인에서 생성된 이미지가 디노이징 프로세스를 다 거치지 않을 필요는 없어요. 그래서 여기서는 디노이징 엔드를 아예 빼고 그냥 전부 다 거쳐진 이미지를 그대로 리파인에다가 입력으로 사용해서 또 정제를 할 수가 있습니다. 그래서 반드시 꼭 그래야 되는 건 아니라는 거를 알고 넘어가시면 좋을 것 같아요. 그럼 여기서는 이 전부 다 디노이징 프로세스가 끝났기 때문에 이미지 베이스는 이렇게 노이즈가 낀 상태가 아니라 기존 이미지 상태로 나오겠죠 이거를 리파이너에다 이렇게 적용을 하면은 또 이런 결과가 나옵니다. 근데 지금 보시면은 사실 또 엄청나게 큰 차이가 또 있어 보이진 않죠. 근데 또 이게 상황과 때 그리고 또 어떤 프롬프트를 사용하느냐 어떤 목적을 가지고 사용하느냐 이런 거에 따라서 어 굉장히 다양한 결과를 또 얻을 수가 있습니다. 그리고 이제까지는 텍스트를 넣어서 이미지를 생성하는 그런 시간을 가졌었는데요. 이번에는 이미지를 입력으로 넣어서 이미지를 아웃풋으로 내뱉는 이미지 투 이미지 과정을 한번 거쳐보려고 합니다. 어 이미지 투 이미지는 주로 내가 입력으로 넣는 이미지에 어떠한 이 스타일을 입히거나 그리고 레퍼런스로 주어지는 이미지에 대해서 이걸 좀 스타일을 반영하거나 어떤 특징들을 반영하는 그런 목적을 가지고 하는 것이 보통의 이미지 2 이미지 테스크죠 그래서 이 스테이블 디퓨전 엑셀셀도 그 이미지 2 이미지를 지원을 합니다. 주로 이미지 크기가 이제 768 바이 768 또는 이제 1024바이 1024 일 때 이제 좀 좋은 퀄리티의 이미지를 많이 반환을 해 주고요. 이때 사용되는 또 이전에 볼 수 없었던 파라미터 두 가지가 있는데 하나는 스트렝스라는 것이 있고 하나는 가이던스 스케일이라는 게 있습니다. 이 스트렝스라는 것은 원본 이미지에 대한 새 이미지의 의존도를 조절하는 값이라고 볼 수가 있어요. 그래서 값이 낮으면 원본 이미지에 좀 더 가까운 결과가 생성되게 되고 값이 높으면 사용자의 텍스트 프롬프트에 더 많은 더 많이 의존하는 그런 결과가 생성되게 됩니다. 그래서 이 스트렝스가 만약에 0.5이고 인퍼런스 스텝이 50이라고 한다면 실제 인퍼런스 스텝은 한 25 이렇게 진행이 된다라고 생각을 하시면 될 것 같아요. 왜냐하면 스트렝스가 낮으면 낮을수록 인플런서 스텝이 줄어든다는 것은 원본 이미지에 대한 새 이미지의 의존도를 줄인다 라는 또 그런 의미이기 때문에 그렇게 적용된다라고 보시면 될 것 같고요. 가이던스 스케일 같은 경우는 이 텍스트 프롬프트의 영향력을 조절하는 파라미터입니다. 그래서 이 값이 클수록 텍스트 프롬프트가 생성하는 이미지에 더 큰 영향을 미치게 되어요. 일반적으로는 뭐 7.5 정도의 값을 사용한다라고 하는데 어 꼭 정해지고 반드시 필수인 건 아니니까 어 이거를 좀 이렇게 사용자가 여러분이 직접 해보시면서 조절하시는 또 방향으로 진행을 해 보셔도 좋을 것 같습니다. 가이던스 스케일 같은 경우는 뭐 저희 앞선 그 내용에서도 가이던스에 대한 내용을 배웠었잖아요 그거에 대한 이제 팩터 스케일 값 이다라고 보면 될 것 같습니다. 그래서 이미지 2 이미지 파이프라인을 이제 적용하기 위해서는 앞선 파이프라인을 그대로 사용하면 안 되고요. 여기에 있는 오토 파이프라인 폴 이미지 2 이미지 를 활용해서 앞서 생성했던 파이프라인을 그대로 이렇게 받아올 수가 있어요. 이렇게 아트와 파이프라인이라고 새로운 객체를 하나 지정을 해줍니다. 그리고 나서 위에서 이제 그 우주 비행사 만들었었던 그 이미지를 이제 인퍼런스 이미지로 이제 사용을 하게 되고요. 어 이 새롭게 생성한 픽셀 이미지 2 이미지에 대한 파이프라인에다가 이 프롬프트를 넣어 줄 겁니다. 그럼 프롬프트에 대한 내용은 어판다 슬리핑 인더 정글 이렇게 있고 인퍼런스 이미지는 정글 안에 있는 우주 비행사였기 때문에 어 여기서 하고자 하는 방향은 정글 안에 있는 우주 비행사를 정글 안에서 잠을 자고 있는 판다로 바꾸겠다 이런 의미인 거죠. 한번 그럼 실행을 해서 비교를 해보도록 하겠습니다. 왼쪽은 인퍼런스 이미지였기 때문에 여기에는 정글에 있는 우주 비행사가 나올 거고 오른쪽에는 정글에서 잠을 자는 이제 판다가 나오겠죠. 보시면 왼쪽에 아까 위에서 생성했던 이미지 가 있고 오른쪽에는 뭐 같은 정글이긴 하고 판다가 있죠 뭐 잠을 자고 있는 건지는 정확히 모르겠습니다. 근데 뭐 잘 준비를 하는 거일 수도 있겠죠 그래서 이거를 또 다시 생성해 보면 결과가 또 바뀌고 이 파라미터 값들을 조정하면 또 좋은 결과를 얻을 수 있으니까 여러분도 한번 해 보시면서 이렇게 수정을 해 보시면 좋을 것 같고요. 그다음에 또 해볼 테스크는 인페인팅이라는 테스크입니다. 앞선 그 설명에서 이론 설명에서도 인페인팅에 대한 테스크를 잠깐 소개했었었는데요. 그때 인페인팅이라는 거는 이미지 내에 특정 부분에 대해서 일부분을 이제 지우고 그 지워진 부분을 다시 채우는 그런 작업을 말합니다. 그래서 예를 들면 인퍼런스 이미지랑 그 이미지에 대한 어떤 특정 부분에 대해서 지워줄 수 있는 마스크를 입력으로 넣어주면은 그 마스크 이미지에 해당하는 부분을 다른 자연스럽게 원본이 그 이미지와 어울릴 수 있도록 대체해서 새로운 이미지를 생성해 주는 그런 방향이다라고 보시면 될 것 같아요. 그래서 이 인페인팅 또한 스테이블 디퓨전 엑셀에서 지원을 해줍니다. 마찬가지로 이미지 2 이미지와 마찬가지로 인페인팅을 위한 파이프라인을 위해서 오토 파이프라인 풀 인페인팅을 이제 사용해서 기존 파이프라인을 덮어서 이제 적용을 해 줄 겁니다. 그래서 인페인트 파이프라고 객체를 지정을 해 줄 거고요. 어 여기서 사용하는 이미지랑 마스크는 허깅페이스에 올라와 있는 데이터를 일단 임시로 같이 바로 예시로 사용을 해보려고 합니다. 그래서 URL을 통해서 이미지들을 이제 불러오게 되고요. 그래서 이미지와 이미지에서 지울 부분 마스크에 해당되겠죠. 이것도 이제 이따가 결과에 함께 이 표현을 해 줄 겁니다. 우리 인페인팅에 대한 그 프롬프트는 딥 씨 다이블 플로팅이라고 이렇게 해줄 거예요. 그러면 이 마스크에 대한 영역에 요 다이버가 이제 나오게 되겠죠. 그리고 여기서 스트렝스와 가이던스 스케일을 같이 지정을 해주게 되고요. 한번 이제 실행을 해서 보게 되면 한 10초 정도 소요가 됩니다. 그래서 왼쪽에는 어 원본 이미지 두 번째는 마스크가 칠해진 영역 세 번째는 인페인팅 된 결과 이렇게 나오겠죠 보시면은 지금 마스크가 칠해진 영역이 이 하얀색에 대한 부분입니다. 하얀색에 대해서 이렇게 새롭게 내용이 채워진 거예요. 정글이긴 정글인데 저희가 프롬프트로 깊은 바다에 있는 다이버라고 이렇게 표현을 했기 때문에 좀 정확하게 다이버에 대한 이미지가 이렇게 또 생성이 되었죠 물고기들도 이렇게 생성이 되었잖아요. 그래서 서로 다른 공간에 대한 이질적인 면이 좀 있지만 그래도 이 이러한 그림을 또 만들어낼 수 있다 라는 걸 또 볼 수가 있습니다. 그리고 어 다음으로는 추가 텍스트 프롬프트를 이용한 이미지 생성입니다. 보시면은 기존에 저희가 프롬프트를 하나만 써서 입력으로 넣었었잖아요. 근데 이 스테이블 디퓨전 엑셀은 텍스트 인코더를 두 가지를 또 쓰게 됩니다. 그러면은 프롬프트를 하나 더 적용해서 각각의 두 개의 프롬프트를 두 개의 텍스트 인코더에 태워서 서로 다른 텍스트에 대한 영향을 이미지 생성 시에 줄 수 있습니다. 그래서 조금 더 이것도 마찬가지로 리파이너랑 비슷하게 이미지 생성의 퀄리티를 좀 더 향상시키고자 하는 그런 방법 중의 하나다라고 볼 수가 있고요. 그 첫 번째는 아까 전에 사용했었던 프롬프트랑 동일한 걸 사용을 하고 이 두 번째 프롬프트에는 반고 스타일의 어떤 페인팅 반고 스타일의 이미지를 생성하도록 이렇게 적용을 해보도록 하겠습니다. 그러면은 뭐 이상적으로 나온다면은 이 정글 안에 있는 우주 비행사 그림이긴 하지만 반 고흐 스타일의 어떤 이미지로 좀 약간 생성이 돼야겠죠 보시면은 그냥 반 고흐 그림이 나왔습니다. 사실 근데 이게 또 프롬프트의 영향이 굉장히 강했기 때문에 또 그런 차이가 보일 수 있을 것 같아요. 또 뭐 다시 생성을 해보면은 그에 맞는 결과를 또 다시 확인해 볼 수가 있습니다. 기다렸다가 보시면 뭐 이것도 정글이라고 할 수 있는지는 잘 모르겠지만 약간의 정보가 많이 섞였죠 그래서 이렇게 또 여러 가지 파라미터들을 한번 조절해 보시면서 진행을 해보시면 좋을 것 같고요. 이제 다음으로는 저희가 이제 지금까지 텍스트 투 이미지 이미지 2 이미지 인페인팅 이렇게 여러 가지 태스크들을 한번 인퍼런스를 해보면서 체험을 해봤는데 이번에는 단순히 이제 프리트레인 된 모델을 인퍼런스에만 사용하는 것이 아니라 저희가 한번 이 프리 트레인 된 웨이트를 가져와서 추가 학습시키는 그런 과정을 한번 진행을 해보려고 합니다. 그래서 로라라는 방식을 사용해서 학습을 할 텐데요. 이 로라라는 것은 로 랭크 어댑테이션이라는 약자이고요. 이 방법은 모델을 조금 더 효율적으로 학습시키기 위한 그런 제한된 방법입니다. 일반적으로 이제 딥러닝 모델을 학습을 할 때는 어 많은 데이터도 필요하지만 모델이 클수록 그만큼 더 많은 자원이 필요하게 됩니다. 그런데 이 로라를 사용하게 되면은 기존 모델의 모든 부분들을 다 활용해서 모든 파라미터를 업데이트하며 학습하는 것이 아니라 어 굉장히 일부분만 구조를 추가해서 그 부분에 대해서만 학습을 하는데도 불구하고 전체를 학습시킨 것만큼 비슷한 또는 유사한 성능을 얻을 수 있게 해주는 그런 방법으로 제안된 내용이에요. 그래서 그에 대한 장점으로는 일부분 추가된 내용에 대해서만 학습을 하면 되기 때문에 연산을 위한 자원이 굉장히 줄어들겠죠. 그래서 그 비용을 또 아낄 수가 있고 그리고 학습에 있어서도 뭐 시간은 조금 더 오래 걸릴 수 있지만 어 좀 더 효율적으로 더 많은 데이터를 학습하는데 이제 또 사용을 할 수가 있습니다. 그래서 여기서 이제 앞서서 사용했었던 파이프라인들은 일단 다 메모리를 위해서 제거를 해 주시고요. 이거 제거 안 하시면은 뒤쪽에 실행하실 때 아마 메모리가 부족하다는 에러가 나올 겁니다. 그래서 반드시 이 부분 잘 지워주시고요. 다음으로는 이제 학습을 하기 위해서는 이미지와 텍스트 두 가지를 같이 페어로 해서 학습을 시킬 겁니다. 데이터를 사용해서 그럼 텍스트를 입력으로 받아 올 때 텍스트를 처리해 줄 수 있는 토크나이저가 또 필요하겠죠 그럼 텍스트를 이제 모델의 입력으로 넣기 위한 토큰으로 변환해 주는 토크나이저를 사용하고 그 토크나이저를 통해서 텍스트 인코더에 입력해서 인베딩을 뽑아오는 그런 과정이 이 함수들 안에 포함되어 있다라고 보시면 될 것 같습니다. 토크나이즈 프롬프트가 바로 이 프롬프트 텍스트로 작성되어 있는 프롬프트를 토크나이저를 통해서 모델의 입력으로 사용하기 위한 토큰화를 시켜준다 이렇게 볼 수가 있고요. 그리고 그 토큰화된 값을 텍스트 인코더에 넣어서 어 그 프롬프트에 대한 인베딩을 추출하는 것이 바로 이 인코드 프롬프트라는 함수에 대한 내용입니다. 그래서 이 함수에서 어 프롬프트에 대한 인비딩들을 이렇게 추출하게 될 거고요. 그리고 여기는 이제 모델 클래스에 대한 이제 인폴트를 해주는 과정입니다. 그래서 텍스트 인코더에 대한 종류를 확인하고 그 텍스트 인코더를 반환해 주는 그런 함수라고 볼 수가 있습니다. 그다음으로는 이 스테이블 디퓨전 엑셀을 구성하는 세부 모델들을 이제 선언을 해 주게 될 거예요. 어 스테이블 디피전 스엘에는 위에서 처음에 컨피규레이션에서 설명드렸다시피 굉장히 많은 구성 요소들로 이루어져 있습니다. 그래서 프리트레인 모델 웨이트를 불러와서 파인튜닝을 할 것이기 때문에 먼저 어떤 프리트레인 모델을 불러올지 이제 정의를 해줄 거고요. 그리고 브에를 무엇을 사용할지도 일단 정리를 해주고 저희는 이 플로팅 포인트 16을 사용을 할 겁니다. 기본은 이 fp 32 플루팅 포인트 32인데 이 저희가 지금 사용할 수 있는 GPU 메모리가 32기가잖아요. 그래서 32기가 내에서 적용하기 위해서는 이 플로팅 포인트 16으로 변환한 후에 실행을 해야지 좀 더 메모리를 효율적으로 아낄 수가 있습니다. 그래서 맨 처음 인폴트를 할 때 설명드렸었던 그 엑셀러레이터 가 이 플로팅 포인트를 변환해 주는 그런 과정을 쉽게 적용해 줄 수 있게 도와주는 역할을 합니다. 그래서 먼저 이 모델 네임과 브이에이 네임 그리고 플로팅 포인트에 대한 내용을 선언을 해 주고요. 어 토크나이저와 텍스트 인코더를 불러올 겁니다. 토크나이저 같은 경우는 오토 토크나이저를 통해서 이 모델 네임을 여기서 정의했던 거를 이 프리 트레인 모델 네이몰 패스 여기다 여기다 입력을 해 주게 되면은 이 아이디에 맞는 어 컨피규레이션에 맞춰서 토크나이저를 불러와 주게 됩니다. 그리고 이제 1 2 두 개를 각각 불러오게 되고 텍스트 인 코더도 위에서 정의했던 함수를 사용해서 이제 실행을 하면 불러와지게 됩니다. 함수를 먼저 정의를 해야죠. 그다음에 불러주시고 중간중간에 이제 저는 미리 모델들을 다운받아서 캐시가 남겨져 있기 때문에 이렇게 막 시간이 오래 걸리지는 않는데 아니 여러분들은 중간중간에 그런 과정이 존재할 수 있으니까 저랑 다르다고 해서 좀 이상하다 생각하지 마시고 모델 다운로드하는 과정이 필요했다라고 판단을 해 주시면 좋을 것 같습니다. 그리고 이제 다음으로는 텍스트 인코더랑 토크나이저를 불러왔으니까 이제 디퓨전의 핵심 과정인 노이지 스케줄러와 vae 그리고 유닛을 또 선언을 해 줘야겠죠. 어 스케줄러는 이제 디디피엠 스케줄러 그리고 VA 같은 경우는 오토 인코더 k엘이라는 거를 통해서 불러오게 되고 유닛은 유닛 2디 컨디션 모델 이거를 활용해서 이렇게 불러올 수가 있습니다. 이렇게 모델들을 구성 요소들을 일단 다 불러왔으면 어 저희는 로라를 활용한다라고 말씀을 드렸잖아요. 그래서 기존의 구성 요소들은 다 학습을 할 때 업데이트가 되지 않도록 이 그레디언트 펄스를 해줄 겁니다. 그러면은 이렇게 펄스를 해주게 되면은 다 프로즌 상태로 모델 옵티마이저를 통해서 업데이트를 해도 웨이트가 변환되지 않습니다. 그리고 학습을 위해서 사용되는 이제 파라미터들을 일단 지정을 해 줄 텐데요. 뭐 시드도 일단 지정을 해 주시고 학습할 때 배치 사이즈는 메모리 좀 한계가 있어서 e로만 사용을 하도록 하겠습니다. 그리고 이미지에 대한 해상도는 1024 그리고 최대 학습 스텝은 1만으로 할 거고요. 그다음으로 이제 체크 포인팅 스텝이라는 거는 저희가 학습할 때 중간중간에 모델 웨이트들을 저장을 해줄 거예요. 그 저장해 주는 시점을 말합니다. 그래서 5천 스텝일 때 한 번 만 스텝일 때 한 번 이렇게 저장을 해주고요. 그리고 옵티마이저에 대한 러닝 레이트를 이렇게 지정해 주고 모델이 저장될 디렉토리를 STXL 로라라는 폴더에다가 저장을 해 줄 겁니다. 그래서 저장하기 위해서 폴더가 존재해야 되기 때문에 이 OS에 있는 메이크 dir 이거를 활용해서 만약에 이 폴더가 존재하지 않다면 존재하도록 만들어 줄 거고요. 저는 뭐 이미 사실 좀 실행을 한 번 했기 때문에 생성이 되어 있습니다. 다음으로는 이제 트레이닝 펑션에 대한 설명을 이제 해 드릴 거예요. 이 단계에 대해서 설명을 해드릴 건데 여기가 조금 코드가 길어서 약간 정신이 좀 없을 수도 있지만 하나씩 또 따라오시고 이거를 세세하게 보는 것도 중요하지만 이게 크게 어떻게 구성이 되어 있는가 위주로 먼저 설명을 드릴 테니까 거기에 맞춰서 이해하시면 될 것 같습니다. 트레이닝 펑션의 이제 입력 값으로는 데이터 셋이랑 유닛 브에 텍스트 인코더 이렇게 원 투 이렇게 있죠 위에서 이미 다 불러왔던 것들이죠. 그리고 엑셀러레이터 이제 저희가 아 제가 말씀드렸잖아요. 이 플로팅 포인트를 이제 바꾸기 위한 어떤 장치로서 사용되는 역할을 한다. 그래서 이 엑셀러레이터를 지정을 하고요. 그러면 이제 앞서 불러왔었던 여러 가지 구성 요소 모듈들 모델들에다가 엑셀러레이터에서 지금 정의되어 있는 지피 디바이스를 설정해 주고 그리고 지금 플로팅 포인트 16으로 했기 때문에 그 가중치에 대한 타입을 이렇게 바꿔줍니다. 그리고 로라를 활용해서 중간에 모델이 다 프레이지 되어 있지만 학습을 위한 어떤 추가적인 파라미터들을 또 올린다라고 말씀을 드렸잖아요. 그 파라미터들을 추가한다. 그래서 그걸 위한 컨피규레이션을 지정을 해줍니다. 랭크 수는 이제 4로 하게 되고요. 그리고 알파 값은 4 초기 이제 가중치는 이제 가우시안 디스트리뷰션으로부터 이렇게 생성하고 그리고 어 이 로라를 적용할 부분을 이제 쿼리키 밸류에다가 하나씩 적용하고 그리고 아웃풋 쪽에다가도 적용을 해서 컨피규어레이션을 구성을 해줍니다. 그리고 이 로라를 적용하는 건 또 굉장히 간단합니다. 이 디퓨저스에서 굉장히 잘 해놨기 때문에 적용하고자 하는 모델 안에 점 에드 어댑터 이렇게 하시고 위에서 정의했던 컴피그를 입력으로 사용하게 되면은 로라에 대한 부분을 적용할 수가 있습니다. 그리고 여기서 로라 웨이트만을 fp 32로 이렇게 바꿔줄 거예요. 플로팅 포인트 16이 더 적은 메모리를 가지고 있기 때문에 빠른 연산을 할 수 있고 웬만하면 뭐 어느 정도 플로팅 포인트 32로 했을 때랑 316으로 했을 때가 32로 했을 때랑 좀 비슷한 결과를 나타내려고 하긴 하지만 그래도 정보가 많을수록 좀 더 정확하고 어 많은 정보를 이제 가지고 학습하기 때문에 더 높은 성능이 나타나서 뭐 플로팅 만약에 메모리와 이제 시간적 자원이 많다라고 하시면은 플로팅 32로 하는 게 또 가장 좋은 방법이 될 수가 있죠. 그리고 여기는 이제 엑셀러레이터의 모델들을 이제 랩핑을 할 텐데 그거를 다시 복원해 주는 함수라고 볼 수가 있고요. 여기 있는 세이브 모델 f 같은 경우는 모델을 이제 저장하기 위한 메서드입니다. 그래서 보시면은 유닛 텍스트 인코드 1 2에 대한 부분들이 유닛 모델들을 UN랩 하면서 랩핑 했던 거를 변환해 주고 그것들을 이렇게 저장해 주는 과정이죠. 그리고 로라를 적용했을 때 또 좋은 방법 중에 하나는 결국에 프리트렌드 모델을 가져와서 로라를 적용한 뒤에 학습이 되는 것은 로라를 적용한 부분만 학습이 되기 때문에 전체 모델을 저장할 필요가 없습니다. 그래서 로라가 적용된 그 웨이트만 따로 저장을 해 놔도 된다라는 것이 어떻게 보면 또 메모리 관점에서도 비용을 줄일 수 있는 좋은 장점 중에 하나죠. 그리고 로드 모델 북은 거꾸로 모델을 저장하는 것이 아니라 모델을 불러오는 과정이다라고 볼 수가 있습니다. 그래서 로라 스테이트 니트를 통해서 이렇게 저장했던 거를 불러올 수 있게 또 두 개의 메서드를 살펴봤고요. 그래서 엑셀러레이터에다가 레지스터 세이브 스테이트 프리 그리고 로드 스테이트 프리 후 두 가지를 이렇게 지정을 해주면 알아서 이렇게 반영을 잘 해 줍니다. 그다음으로는 이제 최적화를 위해서 옵티마이저로는 이제 adw를 사용을 할 거고요. 그리고 이 p 리콰이어 그레드 트로인 경우에만 이제 학습이 되겠죠 나머지는 다 아까 위에서 펄스로 이제 주었었잖아요. 근데 로라가 적용된 부분은 트루로 되어 있겠죠. 그래서 그 부분에 대해서만 옵티마이저가 업데이트를 해주게 됩니다. 그리고 러닝레이트랑 여러 가지 이제 파라미터들은 이렇게 설정이 되어 있고요. 그다음에 이제 데이터셋에서 이제 컬럼 네임스 불러오고 그럼 데이터셋에는 이미지와 이미지의 짝이 맞는 이 캡션으로 이렇게 구성이 되어 있습니다. 그래서 이미지와 캡션 이렇게 두 가지가 정의되어 있는 거를 볼 수가 있고요. 이 토크나이즈 캡션 같은 경우는 캡션은 텍스트로 되어 있으니까 이거를 토크나이저로 변환을 해줘야겠죠. 그래서 변환하는 과정이고 만약에 이제 학습 과정이라고 한다면 하나의 이미지에 여러 가지 캡션이 존재하는 경우가 있어요. 이미지 하나를 여러 말로 표현할 수 있듯이 그래서 학습하는 도중이면 그중에 하나를 선택하고 학습하는 도중이 아니라면 그중에 첫 번째 거를 선택한다 이런 식으로 캡션들을 쭉 모아서 위에서 정의했었던 토크 아이즈 프롬프트 함수를 사용해서 이 토큰화시켜줍니다. 이미지 같은 경우는 리사이즈와 센터 크롭 허리젠더플립 이렇게 여러 가지 트랜스폼들을 정의를 해 주고요. 이 프리 프로세스 과정을 통해서 이미지를 처리를 해주게 됩니다. 그리고 이 프리 프로세스 트레인 같은 경우는 데이터셋이라는 클래스 안에 w 트랜스폼에다가 이렇게 입력으로 사용을 해 줄 거예요. 그러면은 학습 시에 포문을 통해서 이 이미지를 계속 불러올 때 이 프리 프로세싱이 수행이 되게 됩니다. 그다음으로 콜라이트 펑션 같은 경우는 데이터 로더에서 어 데이터 셋들로부터 이제 배치 사이즈만큼 데이터를 받아왔을 때 처리해 주는 그런 과정입니다. 그래서 이거를 이제 통해서 데이터 로더를 생성할 때 데이터 셋을 입력으로 넣고 콜라이트 펑션 지정했던 것을 또 여기다가 입력으로 넣고 그렇게 해서 트레인 데이터 로더를 생성해 주게 되었고요. 그리고 러닝 네이트 스케줄러 같은 경우는 코사인 어닐링 스케줄러에다가 웜업 스텝을 좀 줄 겁니다. 웜업 스텝 같은 경우는 러닝 레이트를 향상을 시키는 거죠. 거꾸로 조금 향상을 시키다가 이만큼 지났을 때 다시 코사인 링 어널링 방식으로 줄어들게 만드는 그런 스케줄러라고 보시면 될 것 같고요. 그리고 이제 웬만큼 다 준비가 끝났습니다. 엑셀러레이터를 통해서 유닛 옵티마이저 데이터 로더 스케줄러를 이제 랩핑을 시켜주게 됩니다. 이 프리페어를 통해서 랩핑을 시켜주게 되고 어 여기는 간단한 시작 전 기본 세팅들이에요. 이게 실행을 하게 되면은 어 이런 터미널들이 터미널에서 실행할 때는 뭐 보이는데 여기서는 안 보이더라고요. 그래서 로고가 아니라 프린트로 또 바꿔서 실행을 해 주셔도 좋습니다. 글로벌 스텝이랑 퍼스트 에포크 초기 글로벌 스텝 이런 거 다 영어로 지정을 해 놓고요. 그리고 티 티큐디엠을 통해서 이제 프로그레스 바를 이제 살펴볼 겁니다. 그래서 이제 위에서 다 정했기 때문에 이제는 애폭을 반복하며 데이터 로더로부터 데이터를 불러서 이제 모델을 학습하는 과정만 존재하죠. 보시면은 이제 데이터 로더에서 배치를 받아오고 이 픽셀 밸류가 이미지 값입니다. 이미지에 대한 밸류 값이라서 브에이에 있는 인코더에다가 입력 값으로 주게 되죠. 그러면은 이 스테이블 디퓨전 학습 방식이 엘디엠 기반이잖아요. 그래서 레이턴트 스페이스 자체를 디퓨전 프로세스를 거치는 것이기 때문에 입력 이미지를 레이턴트 스페이스로 보내기 위해 이러한 브에의 인코더를 거쳐 준다라고 볼 수가 있습니다. 그래서 모델 인풋이 이렇게 나왔고 모델 인풋과 동일한 노이즈를 이제 또 만들어 주게 됩니다. 그리고 이 노이즈가 어디에 활용되냐면 보시면 이 노이즈 스케줄러에 노이즈가 생성 추가 에드 노이즈를 적용하게 되죠. 그래서 모델 인풋과 노이즈 타임 스텝만큼 이 스케줄러를 통해서 노이즈 모델 인풋이라는 변수로 이제 정의를 해 줍니다. 그 다음으로는 어 인코드 프롬프트를 통해서 또 텍스트를 입력으로 넣은 다음에 텍스트 인코더를 통한 인베딩을 추출해 주는 과정이 있고요. 그러면 이 텍스트 인코더는 이제 컨디션으로 들어가겠죠. 유닛을 통해서 위에서 정의했던 노이지 모델 인풋 이 스케줄러를 통해 반영된 이 결과물과 타인 스텝과 그리고 프롬프트에 대한 인베딩 값 그리고 이런 컨디션들 같이 넣어서 유닛에 대한 또 유닛을 사용한 모델의 예측 값을 반환해 주게 됩니다. 그러면 이제 로스 펑션을 계산을 해야 되는데 유닛으로 예측한 노이즈와 실제 노이즈 이 두 가지에 대해서 엠에스이 로스를 가지고 로스를 정의해 주게 됩니다. 그 뒤로는 이제 엑셀러레이터의 백워드 과정을 통해 옵티마이저를 업데이트해 주는 거죠. 그러면 한 번에 이 스텝이 거쳐지게 되고 이거를 이제 계속 반복하고 에폭 단위로 또 반복하고 이런 식으로 학습을 쭉 진행을 해 주시면 됩니다. 그래서 저희가 만 스텝 학습한다라고 말씀을 드렸잖아요. 이런 부분들은 뭐 이 중간중간에 모델 학습에 어떤 싱크를 맞춰주고 또는 이 모델을 저장해 주고 어 그런 내용들입니다. 프로그레스 바에 대한 내용을 업데이트해 주고 그래서 이거를 일단은 함수를 이제 실행을 해서 함수를 정의를 해 주고요. 그다음으로 데이터셋을 불러올 건데 포켓몬 데이터셋을 불러올 거예요. 그래서 이미지는 포켓몬이고 그 포켓몬에 대한 캡션이 달려 있는 이 블립이라는 모델을 사용해서 생성한 캡션이 달려 있는 어 패드 이미지 텍스트 이거를 데이터를 불러올 겁니다. 그다음에 데이터랑 위에서 정의했었던 모델들을 기준으로 이제 트레이닝을 시킬 거예요. 그래서 이거를 실행하시면은 이제 학습이 시작하게 됩니다. 여기서부터는 시간이 꽤 오래 걸립니다. 만 스텝을 하는 거기 때문에 이 티큐디엠을 통해서 예상 시간을 좀 살펴볼 수가 있긴 한데 대략 한 3시간 반에서 4시간 정도 시간이 걸립니다. 그래서 이 시간 동안은 아 여러분이 하셔야 될 일은 이 서버의 접속이 끊기지 않도록 잘 확인해 주시고 뭐 중간에 좀 쉬시거나 다른 작업을 또 같이 노트북을 통해서 또는 컴퓨터를 통해서 하시면 좋을 것 같고요. 어 이렇게 저는 이 실습 과정을 통해서 이미 미리 학습을 해 놓은 상태고요. 그래서 이거를 중지하고 최종적으로 학습이 다 끝난 뒤에 결과를 보시면은 이 에디스의 로라라는 폴더를 위해서 만들었잖아요. 그래서 그 안에 이렇게 폴더가 모델 웨이트가 저장된 채로 생성이 되어 있을 겁니다. 그래서 이 파일을 이제 불러올 거예요. 불러오시기 전에 일단 한번 GPU 메모리를 비워주시고 이 스테이블 디퓨전 엑셀 파이프라인을 다시 한 번 정의를 해 주시고 저장되어 있는 저희가 포켓몬에 대해서 학습한 이 파일을 불러올 겁니다. 그러면 이미 불러와진 거예요. 굉장히 간단하죠. 그러면 저희는 포켓몬 이미지랑 포켓몬 이미지에 대해서 캡셔닝 되어 있는 두 이미지 텍스트 데이터를 학습했기 때문에 어 이러한 이제 프롬프트를 넣어 주면은 여기에 맞는 포켓몬이 또 생성되는 걸 기대해 볼 수가 있죠. 그래서 보시면은 어 포켓몬 w 블루아이스 그러니까 파란 눈을 가지고 있는 포켓몬 이미지를 생성해라 라고 볼 수가 있습니다. 그래서 기다렸다가 한번 또 보시면은 이제 세 장 정도 이제 뽑아볼 텐데 시간이 좀 걸리네요. 1024b 1024 이미지로 했기 때문에 아무래도 시간이 좀 걸리겠죠 아까 전에 한 장 했을 때 한 13초 정도 걸렸으니까 지금 3장을 하면은 어 이제 이제 슬슬 결과가 나옵니다. 38초 보시면 파란 눈을 가진 포켓몬을 생성해라라고 했는데 사실 파란 눈을 가진 건 이 두 가지 정도인 것 같고요. 뭐 어떤 포켓몬인지는 잘은 모르겠습니다. 저도 포켓몬 세대가 굉장히 옛날 포켓몬 세대라서 요즘 포켓몬은 잘 모르겠지만 이런 포켓몬 좀 비슷한 이미지들이 생성이 된 것 같습니다. 뭐 여러분이 또 좀 더 학습을 오래 시키거나 또 이 프롬프트와 여러 가지 파라미터를 통해서 여기에 대한 생성 퀄리티를 또 바꿔 볼 수가 있기 때문에 한번 이렇게 조절하면 좋을 것 같고요. 그래서 파인튜닝 하는 방식에 대해서 알아봤기 때문에 어떻게 파인튜닝을 하고 어떤 데이터에 학습을 하면 좋을지 이런 것들을 이제 배워가셔서 이미지 생성 쪽으로 뭔가를 해보고 싶다 하신다면은 어 이 자료들을 참고해서 또 해보시면 좋을 것 같습니다. 그래서 이번 실습 내용은 이제 디퓨저스에 대한 여러 가지 테스크와 로라를 활용해서 이렇게 파인튜닝을 해볼 수 있다라는 내용을 말씀드린 거고요. 그럼 다음 실습 시간에는 커스텀 데이터셋 예를 들어서 여러분이 직접 데이터를 수집을 해서 그거를 가지고 학습을 해본다라는 상황을 가정해서 같이 데이터 수집부터 어 이 방금 전에 했었던 파인튜닝 과정 그리고 여러 가지 또 프롬프트를 위한 프롬프트 엔지니어링이라고 요즘 막 얘기를 많이 하잖아요. 엔지니어링 과정에서 어떤 부분들이 중요한지 어떤 부분들을 신경 써서 하는지 뭐 이런 내용들을 함께 또 살펴보려고 합니다."
}