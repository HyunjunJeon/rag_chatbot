{
  "lecture_name": "(8강) 더 좋은 성능을 위한 기법 (2)-Hyperparameter Tune",
  "source_file": "(8강) 더 좋은 성능을 위한 기법 (2)-Hyperparameter Tune_52.mp4_2025-12-04-103530780.json",
  "text": "안녕하세요. 도메인 공통 프로젝트 8강 더 좋은 성능을 위한 기법 두 번째 하이퍼 파라미터 튜닝 시작하겠습니다. 이번 강의에서는 모델에 설정해야 하는 각 하이퍼 파라미터들을 튜닝하는 방법인 하이퍼 파라미터 튜닝에 대해서 이해해 보겠습니다. 두 번째로는 실제 하이퍼 파라미터를 튜닝하기 위해 여러분들이 사용할 수 있는 하이퍼 파라미터 옵티마이제이션 툴에 대해서 소개하도록 하겠습니다. 먼저 하이퍼 파라미터 튜닝 이해하기입니다. 하이퍼 파라미터란 모델 학습 과정의 디자인에 반영되는 값입니다. 학습 시작 전에 미리 설정하게 되는 값입니다. 예시로는 러닝 레이트, 손실 함수, 배치, 사이즈, 신경망의 레이어 수가 있습니다. 여러분들이 직접 조정 가능한 값들의 형태입니다. 다음으로는 파라미터가 있습니다. 파라미터는 모델 내부에서 결정되는 변수로 데이터로부터 학습 또는 조정되는 값들입니다. 예시로는 선형 회귀 모델의 개수, 신경망의 가중치 혹은 편향 등을 말합니다. 이러한 값들은 학습 과정에서 자연스럽게 조정되는 값이기 때문에 개발자가 직접 조정하지 않습니다. 정리해 보면 하이퍼 파라미터는 학습 과정이 시작되기 전에 설정되는 구성 변수라고도 이야기할 수 있습니다. 다음은 모델 파라미터와 하이퍼 파라미터에 대한 예시 그림입니다. 모델 파라미터의 경우 보시는 것과 같이 웨이트와 같은 값들이 존재합니다. w0, w1, w2 그리고 wm 이러한 값들은 모델이 가지고 있는 가중치 값들이며 모델을 학습시키는 과정에서 로스를 최적화하는 동안 조정되는 값입니다. 오른쪽에 있는 하이퍼 파라미터들을 보겠습니다. an it 테스트 사이즈 랜덤 스테이트 알파 시 이러한 값들은 모델을 학습할 때 얼마나 여러 번 학습할 것인지, 테스트 사이즈는 어떻게 되는지, 랜덤 시드 값은 어떻게 되는지, 우리가 모델의 오버피팅을 방지하기 위해 정교화를 적용할 때 얼마나 그 정교화의 강도를 강하게 설정할지 이러한 값들을 하이퍼 파라미터라고 부릅니다. 각 모델마다 가지고 있는 하이퍼 파라미터는 다르지만 하이퍼 파라미터가 많을수록 모델 학습에 고려할 디자인 요소가 많다는 의미입니다. 하이퍼 파라미터 옵티마이제이션이 필요한 이유에 대해서 살펴보겠습니다. 예시를 하나하나 확인해 보면서 따라가겠습니다. 첫 번째 예시를 보면 레이어는 3개 그리고 각 레이어에 할당되는 뉴런의 수는 512개, 러닝 웨이트는 0.1입니다. 이 하이퍼 파라미터를 가지고 모델을 학습한 결과는 85%의 스코어를 가지게 됩니다. 두 번째 예시를 보겠습니다. 동일하게 3개의 레이어를 가지고 있고 뉴런의 수는 2배 늘어난 숫자인 1024를 가지고 있습니다. 러닝 레이트는 0.01로 설정되었고 동일하게 스코어는 85%를 보여주고 있습니다. 마지막 예시를 보겠습니다. 마지막 예시는 3개의 레이어를 가지고 있고 각 레이어별로 256개의 뉴런을 가지고 있습니다. 러닝 레이트는 첫 번째 예시와 동일한 0.1입니다. 세 번째 예시의 스코어는 92%를 보여주고 있습니다. 사실 이 예시는 매우 단순한 예시일 뿐입니다. 실제로 여러분들이 하이퍼 파라미터를 설정할 때는 이것보다 훨씬 더 많고 훨씬 더 넓은 영역의 하이퍼 파라미터를 탐색을 해야 되는데요. 예시에서 볼 수 있듯이 어떤 하이퍼파라미터를 설정하느냐에 따라 스코어가 달라질 수 있습니다. 하이퍼파라미터 옵티마이제이션의 장점에 대해서 이야기해 보겠습니다. 먼저 모델 성능입니다. 하이퍼파라미터 선택은 모델 성능에 큰 영향을 미치며 적절히 조정된 하이퍼 파라미터는 모델의 정확도 일반화 능력 효율성을 향상시킬 수 있습니다. 다음은 학습 시간입니다. 효율적인 하이퍼 파라미터 조정은 학습 시간과 계산 자원을 감소시킬 수 있습니다. 마지막으로는 모델 일반화입니다. 잘 최적화된 하이퍼 파라미터는 모델이 실제 데이터에 대해 더 잘 일반화되도록 도와 과적합과 과소적합을 줄일 수 있습니다. 하지만 하이퍼파라미터 옵티마이제이션에 큰 단점이 있는데요. 이러한 하이퍼 파라미터를 찾기 위해 조정 비용이 많이 발생할 수 있습니다. 어떤 하이퍼 파라미터가 최적인지는 직접 학습을 시키고 그 모델의 성능을 어느 정도 확인할 수 있을 정도로 학습을 시켜야 하기 때문에 그만큼 시간과 계산 비용, 인프라 비용이 발생할 수 있습니다. 다음은 허깅페이스 사전 학습 모델에서 볼 수 있는 하이퍼 파라미터들입니다. nom 레이어스 트랜스포머의 인코더 층 수를 나타냅니다. 벌트 베이스의 경우 12개, BT 미니의 경우 4개를 가지고 있습니다. 다음은 히든 사이즈입니다. 히든 상태 벡터 차원입니다. 벌트 베이스는 768, 펄, 미니는 256을 가지고 있습니다. 다음은 어텐션, 헤드, 셀프 어텐션의 머리 수입니다. 12개 4개를 가지고 있습니다. 인터미디어트 사이즈, 로켓 사이즈, 맥스, 포지션, 임베링스, 액티베이션, 펑션, 드롭아웃 등 여러분들이 어떤 하이퍼 파라미터를 설정하냐에 따라 가장 아래에서 보여지는 전체 모델의 파라미터 개수가 5배까지 혹은 그 이상까지 차이 날 수 있습니다. 다음은 훈련 파라미터입니다. 이는 훈련을 진행하는 동안 여러분들이 설정할 수 있는 하이퍼 파라미터를 뜻합니다. 첫 번째로 넘 에폭스입니다. 여러분들이 모델에게 데이터셋 전체를 얼마나 많이 보여줄지 결정하는 수치입니다. 예시에서는 50회로 설정되어 있습니다. 그다음은 얼리스타핑 페이션스입니다. 이 값은 여러분들이 설정한 검증 데이터에 대한 검증 스코어가 해당 횟수만큼 개선되지 않으면 얼리스탑 모델 학습을 일찍 멈추게 도와주는 하이퍼 파라미터입니다. 예시의 경우 5로 설정되어 있고 5회 이상 에폭에 대해 검증 스코어가 개선되지 않으면 학습을 중단합니다. 다음은 배치 사이즈입니다. 배치 사이즈는 딥러닝 모델을 학습할 때 미니 배치 사이즈의 크기를 결정합니다. 현재 예시의 경우 16개로 되어 있고 그렇다라는 거는 16개의 샘플이 모델에 한 번에 학습된다라는 의미입니다. 오른쪽에서는 로스를 볼 수 있습니다. 우리가 일반적으로 우리가 일반적으로 분류에서는 바이너리 크로스, 엔트로피 회귀에서는 엠스 혹은 엠에이와 같은 로스를 사용을 하는데요. 여러분들이 푸는 테스크에 따라 사용할 수 있는 로스가 여러 개일 수 있습니다. 이런 경우일 땐 여러분들이 사용하는 로스 그 자체도 하이퍼 파라미터로 간주할 수 있습니다. 이어서 옵티마이저입니다. 예시에서는 아담블를 예시로 들었고요. 아담더블유가 아닌 다른 옵티마이저를 고려하고 싶다면 이 또한 하이퍼 파라미터로 쓸 수 있습니다. 러닝 레이트, 맥스, 시퀀스 랭스 등 학습 단계에서 고려할 수 있는 다른 하이퍼 파라미터들도 많이 있습니다. 그래서 여러분들이 모델의 디자인을 결정한 뒤에 훈련하는 파이프라인에 대한 하이퍼 파라미터도 반드시 고려해야 합니다. 하이퍼 파라미터 튜닝이란 사실은 하이퍼 파라미터를 찾는 하이퍼 파라미터 설치라고 할 수 있습니다. 여러분들이 가지고 있는 주어진 데이터에 대해 어떤 하이퍼 파라미터 조합에서 내가 가진 모델이 가장 성능이 좋은지는 직접 실험을 통해 찾아내어야 합니다. 그림은 학습률 러닝레이트를 조정했을 때 모델 성능 양상을 보여주는 그래프입니다. 매우 극단적인 예시일 수는 있지만 다음과 같이 학습률이 올라감에 따라 모델의 성능이 올라갈 수도 혹은 내려갈 수도 있습니다. 그렇기 때문에 어느 지점에서 최적인지는 실험을 통해 알아낼 수밖에 없습니다. 대표적인 하이퍼 파라미터 튜닝 방법으로는 그리드 서치가 있습니다. 그리드 서치는 말 그대로 내가 최적화하고 싶은 하이퍼 파라미터들의 값을 그리드로 설정을 하고 가능한 모든 경우의 수를 탐색하는 방법입니다. 그리 서치는 하이퍼 파라미터의 수 그리고 각 하이퍼 파라미터에 설정한 그리드의 수만큼으로 실험 횟수가 정해집니다. 하지만 여기에 생길 수 있는 단점은 실제 우리가 사용하는 하이퍼 파라미터 중 정수인 경우에도 문제가 있겠지만 실수인 경우에서는 훨씬 더 큰 문제가 발생합니다. 왜냐하면 여러분들이 손쉽게 볼 수 있는 하이퍼 파라미터들 혹은 다른 경진대회 혹은 현업에서 볼 수 있는 하이퍼 파라미터들을 보시면 인간이 추론할 수 있는 어떤 수치의 값이 아닙니다. 실제로 어떤 실수 값으로 매우 낮은 소수점까지 튜닝을 하게 됩니다. 그렇기 때문에 그리스 워치는 가장 쉬우면서도 직관적인 방법이지만 실제로는 최적의 점을 찾기는 사실상 어렵습니다. 다음은 랜덤 서치입니다. 그리 설치에서 그리드를 만들어서 정해진 구간을 탐색하는 거였다면 랜덤 서치는 튜닝할 하이퍼 파라미터와 그리고 탐색할 하이퍼 파라미터의 값의 범위를 지정합니다. 이 과정에서 랜덤하게 하이퍼 파라미터의 실제 값들을 설정을 하고 학습을 진행한 뒤에 탐색을 진행합니다. 사실 탐색이라고 설명을 했지만 탐색이라고 말하기는 약간 어렵습니다. 왜냐하면 모든 하이퍼 파라미터는 랜덤하게 임의로 선택되기 때문입니다. 그래서 그리드 서치에서 있었던 실수 혹은 인간이 인지하기 어려운 실수 범위 혹은 인간이 먼저 그리드를 설정해야 된다라는 단점은 해결할 수 있지만 여전히 비효율적일 수 있습니다. 다음 하이퍼 파라미터 튜닝 방법론은 베이지안 서치입니다. 베이지안 서치는 선택된 하이퍼 파라미터와 모델 성능 사이의 관계성이 있을 것을 고려하여 최적의 하이퍼 파라미터 조합을 찾는 것입니다. 예시를 보겠습니다. 가장 왼쪽에 있는 랜덤 서치의 경우 약 10번의 시도에 걸쳐 글로벌 미니멈 최적점에 도달한 것을 확인하실 수 있습니다. 다음은 그리 설치입니다. 그릴 서치는 개발자가 설정한 각 하이퍼 파라미터들의 그리드를 기반으로 가능한 모든 경우의 수를 탐색합니다. 결과에서 보시면 아시겠지만 그리 서치는 글로벌 미니멈에 도달하지 못했습니다. 다음은 베이지안 서치입니다. 베이지안 서치는 약 다섯 번 만의 시도 끝에 글로벌 미니멈에 가까이 도달한 것을 확인할 수 있습니다. 그래서 여러분들이 현업에서 하이퍼 파라미터 튜닝을 수행하신다면 일반적으로 처음 수행하는 것은 베이지안 옵티마이션 설치일 것입니다. 이외에도 데이터의 특성 혹은 도메인의 특성에 따라 베이지안 옵티마이제이션을 기반으로 한 다른 튜닝 방법론을 사용하실 수도 있습니다. 베이지안 서치를 조금 더 쉽게 이해해 보도록 하겠습니다. 먼저 우리가 풀고자 하는 문제를 정리해 보겠습니다. 여러분들이 낚시를 하러 갔다고 생각해 보겠습니다. 가장 큰 물고기를 낚을 수 있는 하이퍼 파라미터 여기에서는 배의 위치 그리고 낚싯대의 깊이를 찾는다고 가정해 보겠습니다. 첫 번째는 초기 탐색입니다. 무작위로 몇 군데 낚시를 시도합니다. 랜덤 하이퍼 파라미터 조합을 가지고 일단 모델 학습을 몇 개 정도 수행해 봅니다. 여기에서 얻은 정보는 낚시를 했던 위치, 낚싯대의 깊이와 같은 세팅, 그리고 실제로 내가 잡은 물고기의 크기 이런 것들입니다. 다음으로는 얻은 정보를 기반으로 물고기 지도를 만들겠습니다. 우리가 방금 이전 페이지에서 봤던 어떤 그래프 같은 걸 만든다 정도로 이해하시면 되겠습니다. 지금까지의 결과로 물고기 밀도 지도를 생성합니다. 이는 가우시안 프로세스를 통해 등고선을 그린다 정도로 이해하시면 되겠습니다. 지도로부터 알 수 있는 정보는 예상된 물고기의 크기 그리고 정보가 부족한 불확실성이 있는 지역들이 나타납니다. 다음 단계에서는 다음 낚시 지점을 선정합니다. 물고기가 잡힐 것 같은 곳 이는 모델 성능이 높을 것으로 예상되는 지점을 이야기합니다. 다음은 아직 탐색이 많이 되지 않은 곳을 선정합니다. 이는 우리가 작성한 물고기 지도에서 불확실성이 높은 곳을 의미합니다. 두 요소를 조합하여 점수를 매겨서 우선순위를 설정합니다. 그다음 다시 한 번 더 실제 낚시를 진행합니다. 우선순위가 높은 지점에서 낚시를 한다는 것은 새로운 하이퍼 파라미터 조합으로 실험을 진행한다는 것입니다. 실험을 진행했으면 실제 성능을 확인합니다. 잡힌 물고기의 크기를 확인해 보는 것이죠. 이를 통해 우리가 가진 물고기 지도를 다시 한 번 더 갱신합니다. 그런 다음 이를 반복합니다. 보시는 예시와 같이 이터레이션을 돌면서 하이퍼 파라미터에 따른 모델 성능에 대한 함수를 추정하여 최적의 하이퍼 파라미터를 탐색하는 것이 베이지안 옵티마이제이션 방법론입니다. 그림에서 보시면 아실 수 있듯이 인터레이션이 진행됨에 따라 최적화된 그 스코어에 탐색 범위가 가까워지는 것을 볼 수 있습니다. 하이퍼 파라미터 튜닝 방법론에 대해 정리를 한번 해보겠습니다. 하이퍼 파라미터 튜닝은 여러 가지 방법을 사용할 수 있고 정답이 정해져 있는 것은 아닙니다. 하이퍼 파라미터 옵티마이션을 통해 모델의 성능을 최적화할 수는 있지만 항상 주어진 계산 자원과 시간이 무한하지 않기 때문에 사용자가 적절한 선에서 하이퍼 파라미터 서치를 진행해야 됩니다. 예를 들어 48시간 동안 그리 설치를 진행해서 나온 결과에서 가장 좋은 하이퍼 파라미터를 쓰겠다. 또는 우리 팀에서 서비스하는 모델의 재학습 주기가 엔 시간인데 그 엔 시간 동안 가장 최대한으로 최적화된 하이퍼 파라미터를 찾고 싶다 라고 한다면 그 n 시간 안에 끝날 수 있는 하이퍼 파라미터 설치 횟수가 최대한 상한이라고 생각하시면 됩니다. 혹은 우리 팀은 이런 하이퍼 파라미터를 튜닝하는 혹은 모델을 학습하는 비용이 매우 민감하기 때문에 최소한으로 해야 한다라는 제약 조건이 있다면 그 최소한의 제약 조건에 맞춰 횟수를 결정하시면 됩니다. 또한 모델끼리 성능을 비교할 때는 각 모델별로 하이퍼 파라미터 최적화를 진행시켜 주셔야 됩니다. 다음은 하이퍼 파라미터 최적화 툴에 대해서 다뤄보겠습니다. 첫 번째로는 우리가 6강에서 다루었던 웨이렌 바이어스입니다. 웨이렌 바이어스의 스윕이라는 기능을 통해 하이퍼 파라미터를 튜닝하고 다음과 같이 결과를 시각화할 수 있습니다. 예시에서 보면 알 수 있듯이 하이퍼 파라미터의 중요도를 플롯 형태로 시각화할 수도 있고요. 오른쪽에서의 예시와 같이 내가 각 실험에서 선택한 하이퍼 파라미터의 조합에 따라 로스 혹은 매트릭이 어느 양상으로 학습되는지를 볼 수 있는 시각화도 제공합니다. 하이퍼 파라미터 스윕을 준비하는 예시를 보겠습니다. 스윗 컨피그라고 하는 어떤 딕셔너리를 준비해 주시면 됩니다. 여기에서 메소드라고 하는 항목에는 베이즈라고 작성이 되어 있는데요. 베이즈는 베이지 안 설치를 뜻합니다. 이 부분에 여러분들이 랜덤을 넣게 되면 VR 설치나 랜덤 서치가 진행되게 됩니다. 다음은 하이퍼 파라미터였습니다. 이곳에는 여러분들이 탐색하고 싶은 하이퍼 파라미터들을 정의하고 그 하이퍼 파라미터들에 넣을 어떤 값들 이런 필드들을 정의합니다. 예시에서는 러닝 레이트 배치 사이즈, 드롭바웃 레이트 디 모델이 존재합니다. 러닝 레이트 배치 사이즈 디 모델의 경우 그리드 설치 형태의 값들을 전달을 했고요. 드롭아웃의 경우 최소 최댓값과 함께 어떤 분포에서 추출할지에 대한 값을 설정했습니다. 이렇게 되면 드라바웃 레이트의 설정을 기준으로 설명을 드리면 0.1부터 0.5까지 균등 분포에서 값을 추출하게 됩니다. 마지막은 매트입니다. 여기에 설정된 매트릭의 네임은 우리가 추후 기록할 로스의 이름을 동일하게 넣어주시면 됩니다. 여기에서 골은 맥시마이즈로 되어 있는데요. 우리가 전달한 매트릭의 수치가 높을수록 좋다면 맥시마이즈 로스와 같이 낮을수록 좋다면 미니마이즈라고 전달하시면 됩니다. 다음은 1db 로그인 및 수입 아이디 생성입니다. 이전 예시에서는 커맨드 라인에서 완디비 로그인이라고 하는 어떤 명령어를 사용했었는데요. 이번 예시에서는 코드 혹은 노트북에서 1db 수입이라는 명령어를 호출했을 때 자동으로 로그인 및 수입 아이디가 생성되는 예시를 보여줍니다. 완디비 데모라고 하는 프로젝트에 스윕이 생성이 되었고 생성된 스윗 아이디가 보여집니다. 뿐만 아니라 스윕 URL이 같이 출력이 되는데요. 해당 URL을 클릭하여 오른쪽 예시와 같이 하이퍼 파라미터 튜닝 기록이 저장될 대시보드로 이동할 수 있습니다. 이 대시보드에서 튜닝이 되는 과정을 실시간으로 확인할 수 있습니다. 이제 실제로 하이퍼 파라미터 튜닝을 해보도록 하겠습니다. 위드 문으로 구성된 1디비 이닛이 실행되면 이후 실행되는 실험이 완디비 웹상에서 로깅되기 시작합니다. 두 번째 줄에서 실행되는 완디비 컨피그에서 반환받은 파람즈가 우리가 앞서 설정한 스윗 컨피그에 정의되어 있는 하이퍼 파라미터들 중 선택된 하이퍼 파라미터들의 값들을 반환받게 됩니다. 해당 값은 딕셔너리 형태로 반환이 됩니다. 밑에 부분에서 보시면 알 수 있듯이 파람스에서 맥스트랭스 배치 사이즈와 같은 선택된 값들을 꺼내어서 학습 단계에서 사용할 수 있습니다. 다음은 이전 단계에서 전달받은 모델의 이름을 기반으로 허깅페이스로부터 사전 학습 모델을 불러오는 코드입니다. 이를 통해 사전 학습 모델을 불러와서 우리의 태스크에 맞도록 파인튜닝을 진행하게 됩니다. 일반적으로 사전 학습 모델들은 모델의 인베딩 크기, 레이어 수 등이 미리 정해져 있습니다. 그렇기 때문에 우리 예제에서는 드라바웃 레이트 정도만 조정해 봅니다. 다음은 모델 네임이 존재하지 않는 경우 랜덤하게 모델 파라미터가 초기화된 트랜스포머를 학습하게 됩니다. 이때는 디 모델을 조정하여 모델의 인베딩 사이즈를 다양하게 바꿔가며 성능 변화를 확인해 봅니다. 모델을 초기부터 스크래치로 학습하는 경우와 사전 학습 모델을 불러와 파인 튜닝으로 학습하는 경우를 비교할 수 있는 예제입니다. 다음은 미리 정의해 둔 트레인 모델 함수를 통해서 모델을 학습하도록 합니다. 이때 학습 하이퍼 파라미터로 최대 에폭스와 러닝 레이트를 사용합니다. 학습이 완료되었다면 모델 성능을 추적할 수 있도록 매트릭으로 AU PRC를 계산을 하고요. 마지막으로 1db 로그 라고 하는 메소드를 통해서 1db 상에 필요한 매트릭 그리고 추가적인 어떤 값들을 기록을 합니다. 예시에서는 베스트 auprc 스코어 파이널 트레인, auprc 파이널 밸리데이션, 에유피알3 토탈 파람즈를 기록했습니다. 이렇게 설정을 해 둔 상태로 실제로 완디비 에이전트에게 해당 펑션과 그리고 해당 컨피그를 기반으로 수행하도록 명령을 보내 보겠습니다. 이때는 완디비 에이전트라고 하는 메서드에 앞서 전달받은 수입 아이디, 그리고 우리가 학습에 사용할 원디비 트레이닝 펑션을 전달합니다. 몇 번 최적화를 진행할지에 대한 값은 카운트라고 하는 값으로 설정합니다. 만약 내가 가진 서버가 혹은 GPU가 여러 개라면 여러 서버에서 같은 수입 아이디를 연동하여 여러 에이전트로 동시에 수입을 진행할 수도 있습니다. 이후 출력되는 결과에서 이번 이터레이션에서 어떤 하이퍼 파라미터를 사용하는지 결과를 보실 수가 있습니다. 뿐만 아니라 완디비 학습 함수 안에서 프린트 문을 통해 하이퍼 파라미터 서치 중에 학습이 잘 되는지를 로깅할 수도 있습니다. 에이전트에게 전달한 실험이 완료가 되면 최종 성능을 완디비에서 자동으로 웹 서버에 기록을 하게 됩니다. 수입이 실행되고 있는 상황을 웹에서 확인할 수 있다라는 뜻입니다. 웹상에서 각 하이퍼 파라미터 튜닝이 끝날 때마다 다음과 같이 어떤 하이퍼 파라미터가 중요한지, 그리고 우리가 최적화하고자 하는 매트릭 혹은 로스와 어떤 코릴레이션이 있는지를 보여줍니다. 오른쪽에서는 각 실험에 대해 출력된 매트릭 스코어를 확인하실 수 있습니다. 앞서 설명드렸던 것처럼 어떤 하이퍼 파라미터에 어떤 값을 설정했느냐에 따라 다음과 같이 가장 오른쪽에 있는 우리가 타겟하는 로스 혹은 어떤 매트릭이 어떤 양상을 보이는지 한눈으로 볼 수 있도록 시각화를 해주는 기능도 존재합니다. 이를 통해 우리가 직관적으로 어떤 하이퍼 파라미터에 어느 정도의 값을 설정했을 때 최적의 값에 가까워지는구나를 직관적으로 이해할 수 있게 됩니다. 다음은 옵튜나입니다. 옵튜나는 머신 러닝 모델의 하이퍼 파라미터 최적화를 위해 만들어진 오픈소스 프레임워크입니다. 웨이레인 바이어스의 기능 중 하나인 수입과 거의 같은 기능을 제공하고요. 옵튜나의 경우 웹보다는 노트북 상에서 비주얼라이제이션 하는 데 초점이 맞춰져 있습니다. 옵튜나의 경우 하이퍼 파라미터뿐만 아니라 모델도 같이 옵티마이제이션 대상으로 설정할 수 있습니다. 예를 들어서 랜덤 포레스트, 에브엠, 엑스지부스트 케엔에서 각 모델별 하이퍼 파라미터 셋으로 최적화를 진행할 수 있습니다. 옵튜나에서 하이퍼 파라미터 컨피그를 준비하는 세팅입니다. 우리가 이전 웨이앤 바이어스에서는 스윗 컨피그라고 하는 딕셔너리를 설정을 했었는데요. 옵튜나에서는 다음과 같이 트라이얼 닷 서제스트 카테고리 컬 혹은 서제스트 플러 혹은 서제스트 인트와 같은 인터페이스를 사용을 해서 하이퍼 파라미터의 이름 그리고 하이퍼 파라미터를 탐색할 범위 등을 설정할 수 있습니다. 이를 동일하게 트레이닝 펑션에 전달을 하여 실행하게 됩니다. 다시 정리를 해보면 완디비에서는 스윗 컨픽으로 하이퍼 파라미터를 설치할 범위를 지정하고 트레이닝 펑션에 한 실험이 돌아갈 때 작동하는 모델 학습과 평가에 대한 코드를 담았었습니다. 옵튜나에서는 실험 함수 안에 최적화할 컨피그와 트레이닝 펑션을 모두 넣어 줍니다. 각 트라이얼에 최적화할 해퍼 파라미터들을 카테고리별 플롯별로 나누어서 지정을 해주고요. 다음 트라이얼 함수 안에서 완디비와 마찬가지로 데이터 셋, 데이터 로더, 트레인 모델 함수들을 차례로 넣어 학습 코드를 완성합니다. 앞서 우리가 최적화할 하이퍼 파라미터의 학습 함수를 이미 설정했다면 먼저 크리에이트 스터디라고 하는 인터페이스를 통해서 우리가 최적화할 실험을 생성해 냅니다. 디렉션에서 볼 수 있듯이 맥시마이즈 이 의미는 우리가 최적화할 매트릭을 최대화하는 방향으로 학습하라는 의미입니다. 다음에는 해당 스터디 객체에 우리가 최적화할 실험 함수를 전달합니다. 이때 앤 트라이얼즈 20회로 설정을 했고요. 이는 최대 20번 실험으로 하이퍼 파라미터 설치를 하라는 의미입니다. 결과를 보겠습니다. 결과에서는 스터디 닷 베스트 트라이얼이라고 하는 어트리뷰트에 저장되어 있는 트라이얼 값을 가져옵니다. 해당 트라이얼의 밸류를 확인을 해보면 가장 높은 스코어를 확인할 수 있습니다. 맨 마지막으로는 트라이얼 닷 파람스라고 하는 딕셔너리에 저장되어 있는 베스트 트라이얼에서 사용했었던 하이퍼 파라미터의 종류와 값들을 확인할 수 있습니다. 옵튜나의 결과를 시각화하는 이런 기능도 제공합니다. 옵티나 비주얼라이제이션 플롯, 옵티마이션 히스토리 함수에 스터디 객체를 전달하시면 됩니다. 그럼 다음과 같이 플롯이 생성되게 됩니다. 또 다른 시각화 방법도 있습니다. 플랫 슬라이스라고 하는 함수에 스터디를 전달하면 각 하이퍼 파라미터의 값에 따라 우리가 최적화하고자 했었던 오브젝티브 밸류의 수치가 어떻게 분포되는지를 보여줍니다. 마지막으로는 대시보드입니다. 옵튜나의 대시보드를 통해 다음과 같이 다양한 정보를 한눈에 확인할 수 있습니다. 마지막으로 요약하겠습니다. 이번 강의에서는 하이퍼 파라미터 튜닝에 대해 배웠습니다. 하이퍼 파라미터란 모델 학습의 디자인적인 요소로 학습 과정 전에 개발자가 미리 설정하는 값을 뜻합니다. 또한 세 가지 정도의 하이퍼 파라미터 튜닝 방법론에 대해서 배웠는데요. 첫 번째 그리 서치는 정해진 그리드의 모든 하이퍼 파라미터의 조합을 시도합니다. 두 번째는 랜덤 서치입니다. 무작위로 정해진 범위 내에서 하이퍼 파라미터를 탐색합니다. 마지막으로 베이지안 서치입니다. 이전 결과를 토대로 하이퍼 파라미터를 탐색하게 됩니다. 다음으로는 웨이렌 바이어스의 스윗 옵튜나에 대해서 다루었습니다. 웨이렌 바이어스의 스윕은 하이퍼 파라미터 튜닝을 자동화하는 툴로 원디비 웹사이트와 연동하여 사용할 수 있었습니다. s 컨피그라고 하는 값을 통해 튜닝한 해퍼 파라미터의 범위와 방법을 미리 설정했었고요. 옵튜나에서도 동일한 방법으로 튜닝할 하이퍼 파라미터의 종류, 범위, 방법들을 설정을 하고 트레이닝 펑션을 정의하여 수행하는 방식으로 하이퍼 파라미터를 최적화했습니다. 옵튜나의 경우 별도 웹사이트가 존재하지 않기 때문에 옵티나 비주얼라이제이션 패키지를 통해 튜닝 결과를 시각화하여 어떤 하이퍼 파라미터가 중요한지 분석하는 부분도 배웠습니다. 이번 강의는 여기까지입니다. 고생 많으셨습니다."
}