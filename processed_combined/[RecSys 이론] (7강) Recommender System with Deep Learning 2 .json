{
  "lecture_name": "[RecSys 이론] (7강) Recommender System with Deep Learning 2 ",
  "source_file": "[RecSys 이론] (7강) Recommender System with Deep Learning 2 _135.mp4_2025-12-04-110032156.json",
  "text": "안녕하세요. 이번 시간 일곱 번째 강의 지난 시간에 이어서 딥러닝 기반 추천 모델에 대해 살펴보겠습니다. 지난 시간에는 뉴럴넷의 가장 기본적인 구조인 MLP 멀티레이어 퍼셉트론 기반 추천 모델과 오토 인코더를 사용한 추천 모델에 대해서 다루었습니다. 오늘은 그보다 조금 더 복잡한 두 가지 딥러닝 기법, 두 가지 딥러닝 모델 아키텍처를 사용한 추천 모델에 대해서 학습하겠습니다. 바로 그래프 뉴얼 네트워크라고 불리는 지엔엔과 시퀀스 모델 등에 주로 사용되는 알앤엔 기반 추천 모델입니다. 먼저 그래프 뉴얼 네트워크라는 다소 생소할 수도 있는 모델에 대해서 학습하겠습니다. 그래프가 무엇이고 어떤 식의 데이터를 표현할 때 이 그래프가 적합한지, 또 그래프 자료 구조를 어떻게 뉴럴넷 추천 모델에 적용하였는지, 뉴럴 그래프 컬래버티 필터링 NGCF라는 모델과 이보다 조금 더 가벼운 라이트 GCN 이 두 가지 모델을 살펴보겠습니다. 그 이후에 RNN 계열의 모델을 간단히 리캡하고 GRU 레이어를 활용한 시퀀스 모델링 추천 기법인 gr 4 r을 살펴보겠습니다. 먼저 그래프 뉴널 네트워크를 활용한 추천 모델입니다. 그래프 신경망 그리고 그래프 컨볼루션 뉴럴 네트워크의 개념을 이해하고 이를 적용한 추천 시스템 모델에 대해서 살펴보겠습니다. 네 먼저 그래프 뉴얼 네트워크를 이야기하기 전에 이 그래프가 무엇인지에 대해서 정의해 봐야겠죠. 그래프의 정의는 굉장히 간단합니다. 이 꼭짓점인 노드와 노드와 노드 사이를 잇는 엣지 로 이루어진 자료 구조를 의미합니다. 따라서 데이터들이 서로 연결되어 있을 때 이러한 데이터를 표현하기에 적합한 자료 구조입니다. 아래에 보이는 제일 기본적인 그래프는 노드의 집합과 엣지들의 집합으로 이루어져 있습니다. 일반적으로 그래프는 노드들의 집합, 엣지들의 집합인 abcd라는 4개의 노드가 존재하고요. 이 abcd 서로서로 연결되어 있는 엣지가 총 4개가 존재하고 이 4개는 다음과 같은 그림으로 나타낼 수 있습니다. 그렇다면 그래프를 왜 사용할까요? 방금 언급했듯이 그래프는 연결되어 있는 데이터를 표현하기에 적합합니다. 따라서 어떤 객체 사이의 관계나 상호 작용 같은 다소 추상적인 개념을 표현할 수 있습니다. 이러한 상호 작용을 테이블 형태의 정형화된 데이터를 표현하면 오히려 표현형이 복잡해지는데요. 그래프를 사용하면 오히려 간단하게 표현할 수 있고 또 다른 관점으로도 표현할 수 있습니다. 아래와 같이 친구 관계, 소셜 네트워크라든지 그 팔로워 팔로잉 관계가 있는 데이터겠죠. 그리고 현재 코로나 바이러스 상황과 같이 바이러스의 확산 같은 상태도 이 그래프를 통해서 표현할 수 있습니다. 그 외에 추천 시스템에서 가장 많이 사용하는 유저가 아이템을 소비했다는 데이터도 그래프로 표현할 수 있는데요. 유저와 아이템을 각각의 노드로 두고 유저가 아이템을 소비했다는 데이터를 엣지로 한다면 이 데이터를 표현할 수 있습니다. 네 그래프를 사용하는 이유는 흔히 우리가 자주 다루는 이미지나 텍스트 혹은 엑셀 시트로 표현할 수 있는 정형화된 데이터와는 조금 다른 형태의 데이터를 사용하기 때문이다. 이제 이러한 이미지, 텍스트, 정형 데이터 같은 데이터들은 격자 형태로 표현할 수 있다고 얘기하고 이 데이터를 좀 더 일반화된 표현으로는 유클리디언 스페이스에 표현할 수 있다고 합니다. 이 유클리디언 스페이스를 간단하게 설명하자면 우리가 익숙하게 다루는 2차원 평면이나 3차원 공간을 일반화시킨 공간이고요. 즉 유한한 실수로 표현할 수 있는 공간이라고 볼 수 있습니다. 그래서 대표적으로 아래 그림과 같이 2차원 평면에 있는 이러한 이미지 데이터는 유클리드 스페이스로 표현할 수 있는 데이터입니다. 그러나 이런 소셜 네트워크 데이터와 같은 유저가 서로 연결되어 있는 데이터라든지 혹은 분자 구조와 같은 모양의 데이터는 유클리드 스페이스 즉 어떤 실수형의 형태로 표현할 수는 없는 데이터입니다. 오히려 이런 데이터를 그래프를 사용하지 않고 표현한다면 오히려 표현형이 굉장히 복잡해집니다. 그래서 그래프를 사용하여서 데이터의 표현을 단순하게 만드는 것이죠. 그래서 우리가 사용하는 논 유클리디언 스페이스의 데이터들을 그래프로 사용할 수 있다는 것을 언급하였습니다. 네 그렇다면 이 그래프를 신경망에 적용해야 하는데요. 이것을 그래프 신경망 그래프 뉴얼 네트워크라고 합니다. 그렇다면 어떻게 이 그래프로 나타낸 데이터를 뉴럴 네트워크에 적용할 수 있을까요? 먼저 왼쪽 아래와 같은 5개의 노드로 된 그래프가 있습니다. 이제 그래프에서 데이터를 설명할 때 제일 중요한 것이 노드 와 노드 사이에 이어져 있는 엣지들이죠. 그럼 이제 해당 노드에 연결된 이웃 정보들의 이웃 노드들의 정보를 뉴럴 네트워크 모델이 표현할 수 있어야만 그래프에서 제일 중요한 패턴을 학습할 수 있는 것입니다. 그래서 가장 나이브한 방법은 이 그림과 같이 그래프를 표현할 수 있는 인접 행렬을 만들어서 그 인접 행렬을 그대로 뉴럴 네트워크 모델의 인풋으로 사용하는 것입니다. 보시면 a와 b가 연결되어 있기 때문에 a와 b의 매트릭스의 원소 1 그리고 또 b와 a의 매트릭스 원소의 1 이렇게 표현되어 있죠. 그래서 이 인접 행렬을 말 그대로 뉴럴 네트워크 인풋 레이어에 데이터 하나를 뽑아서 그대로 넣어주게 됩니다. 그래서 이 데이터는 아마 이 비에 대한 표현형이겠죠. 그래서 인접 행렬 더하기 다른 기존에 우리가 뉴럴 테크 모델에서 사용하고 있는 다른 피처형을 이렇게 넣어 줄 수 있습니다. 하지만 이제 이런 기법의 문제는 무엇일까요? 일단 노드가 계속 증가하게 되면 인접 행렬의 차원은 계속 증가하고 이 행렬의 행을 그대로 인풋 레이어에 사용하게 되면 차원은 계속 증가하게 될 것입니다. 그런 모델의 복잡도는 계속해서 증가하고 연산량은 많아지면서 동시에 입력 데이터는 아주 스파r스해지겠죠. 그렇기 때문에 이 모델이 좋지 않습니다. 또한 여기서 인접 행렬은 a b c d e 순서 대로 구성되어 있는데요. 사실 이 순서는 그래프 자체에서는 아무런 의미가 없습니다. 이 그래프를 살펴보면 abcde의 연결 관계를 모델링 한 것인데 이것을 매트릭스를 표현하기 위해서 우리가 임의로 순서를 준 것이죠. 근데 이 나이브 어프러치 즉 인접 행렬을 그대로 인플레이어에 사용하는 방법은 노드의 순서가 그대로 입력 값으로 사용되기 때문에 만약에 이 순서가 바뀌면 또 의미가 달라질 수도 있습니다. 네 그래서 방금 설명한 대로 이 나이브 어프로치 나이브하게 그래프의 인접 행렬을 만들어서 그 인접 행렬을 그대로 뉴럴넷 모델의 입력 값으로 사용하는 방법은 좋지 않습니다. 노드가 많아질수록 연산량은 기하급수적으로 많아지고 또 노드의 순서의 의미가 이상하게 반영될 수 있기 때문이죠. 따라서 이런 나이브한 방법으로는 보통 그래프 데이터를 뉴럴넷 모델링을 하지 않습니다. 대신에 이 그래프 컨볼루션 뉴럴 네트워크라는 개념이 등장하죠. 이 컨볼루션이라는 개념 이 단어는 이미지 데이터를 다루는 CNN 계열의 모델에서 아마 자주 들어보셨을 것입니다. 먼저 이 우측에 있는 그림을 보십시다. 아래와 같은 왼쪽의 이미지 데이터 즉 2차원 공간으로 표현되어 있는 이미지 데이터에서 컨볼루션 레이어를 사용하는 방법은 이 2차원 유클리드 공간에 주어진 빨간색 데이터 포인트 를 포함하여 이 주변에 있는 즉 로컬 커넥티비티가 연결되어 있는 데이터를 모아서 컨볼루션을 진행합니다. 그래서 왼쪽에 있는 것이 2디 컨볼루션의 컨볼루션 레이어를 사용하는 방법이고요. 이제 이것을 논 뉴클리디언 공간으로 확장시킨 것이 바로 그래프 뉴럴 네트워크의 그래프 컨볼루션입니다. 그래서 이미 이미지에서 다루는 컨볼루션과 굉장히 유사한데요. 이제 이미지 데이터는 방금 설명했듯이 주어진 데이터와 물리적으로 가까이 있는 데이터들을 가지고 컨볼루션을 수행했습니다. 그럼 그래프 컨볼루션 같은 경우에도 주어진 데이터와 가장 가까이 있다는 의미는 바로 하나의 엣지로 연결되어 있는 이 그래프를 기준으로 다른 이웃들을 의미하죠. 그래서 이 해당 노드를 포함하여서 연결되어 있는 이웃들, 연결되어 있는 노드들을 한꺼번에 모아서 컨볼루션 연산을 수행합니다. 그래서 이런 점이 로컬 커넥티비티 측면에서 이미지의 컨볼루션과 그래프의 컨볼루션이 같은 원리를 사용한다는 것을 알 수 있고요. 또한 둘 다 쉐어드 웨이츠를 사용합니다. 우리가 CNN에서 컨볼루션 연산을 배울 때 이거 하나를 필터라고 했는데요. 여기서는 보면 3 바이 3의 필터를 사용한 것이죠. 그런데 이 필터가 가진 파라미터는 동일하고 여기서 사용하는 파라미터와 이 옆에 있는 파라미터는 모두 같은 웨이트를 공유합니다. 마찬가지로 그래프 컨볼루션에서도 이 데이터를 기준으로 만든 이 웨이트와 혹은 다른 데이터를 기준으로 만든 컨볼루션 에서도 같은 파라미터 같은 웨이트를 셰어하게 됩니다. 네 마지막으로 컨볼루션 레이어를 2개 이상 3개 이상 쌓게 되면은 바로 옆에 있는 데이터 포인트 외에 더 멀리 있는 한 칸 더 멀리 있는 정보까지 많이 참고하여서 이 데이터의 레프레젠테이션을 학습할 수 있는데요. 이 지씨앤 그래프 콤블루션도 마찬가지로 바로 옆에 연결되어 있는 다른 이웃 노드가 아니라 하나 더 연결되어 있는 이웃 노드까지 확장시켜서 레이어를 2개 이상 사용할 수 있습니다. 그래서 이렇게 세 가지 측면 바로 옆에 있는 연결되어 있는 데이터를 의 정보를 활용한다. 그리고 그 필터와 같은 웨이트를 셰어한다. 그리고 레이어를 2개 이상 쌓을 수 있다라는 측면에서 이 컴플루션 네트워크라고 볼 수 있고요. 그래서 연산량을 줄이면서 노드끼리 연결된 관계를 표현할 수 있고 또 그보다 더 멀리 있는 간접 관계를 특징으로 추출할 수 있습니다. 그래서 앞으로 우리가 보통 GNN 계열의 추천 모델이다라고 하면은 보통 이 그래프 컨볼루션 뉴럴 네트워크를 사용한 모델임을 기억하시길 바랍니다. 그래서 이번 모델은 GNN을 기반으로 유저 아이템의 상호작용 즉 이 상호 작용을 콜라베이티브 시그널이라고 본 논문에서 표현하고 있는데요. 이 콜라베이트 시그널을 추출하는 모델인데요. 그래프가 가진 장점을 사용해서 유저와 아이템 간의 콜라베이트 시그널을 인베딩 단 즉 인베딩 레이어에서 직접 추출한 접근법을 제시한 논문입니다. 이 논문이 발표된 이후 이 뉴럴 글래스 컬라버레이트 필터링이 발표된 이후에 물론 이보다 더 가볍고 좋은 성능을 가진 GNN 기반 추천 모델이 많이 발표되었지만 이 논문을 통해서 처음 그래프 컨볼루션 뉴럴 네트워크가 추천 시스템을 풀기에 좋은 모델이라는 것을 밝혔기 때문에 그런 점에서 이 논문은 굉장히 연구적으로 의미가 있습니다. 논문의 등장 배경은 다음과 같습니다. 그동안 우리가 배웠던 뉴럴 그래프 컬라버레이트 필터링이 아닌 3강부터 배웠던 컬래버레이트 필터링, 제일 기본적인 매트리스 팩토라이제이션 같은 모델을 살펴보면 크게 두 가지 특징을 모델이 잘 학습해야 한다는 것을 알 수입니다. 이 추천 시스템 모델이라고 하면은 이 아래 있는 두 가지 첫 번째는 유저 아이템의 인베딩을 잘 학습해야 합니다. 유저 아이템은 계속해서 원핫 인코딩으로 처음에 표현된다고 했고, 그것을 우리가 어떤 댄스 한 인베딩으로 학습한다고 했는데요. 엠에프부터 시작하여서 유저와 아이템을 어떤 레이턴트 팩터 즉 인베딩으로 표현하는 기법은 딥러닝 모델로 넘어와서도 동일하게 인베딩 레이어를 사용해서 이어져 오고 있습니다. 두 번째로는 유저와 아이템의 상호 작용입니다. 대표적으로 메트릭스 펙토라이제이션에서는 유저 아이템을 임베딩한 이후에 그 유저 아이템을 내적 닷 프로덕트 하여서 그 유저와 아이템의 상호 작용을 리니어하게 표현했습니다. 문제는 엠프를 포함하여서 기존의 뉴럴넷 기반의 CF 모델 즉 이런 뉴럴 컬라버리티 필터링 계열의 모델들은 유저와 아이템의 상호 작용을 인베딩 단계에서 접근하지 못했습니다. 방금 설명했듯이 매트리스 팩터라이제이션에서도 pu 유저의 인베딩과 qi 아이템의 인베딩을 각각 구한 다음에 그 둘의 내적을 통해서 상호 작용을 표현하기 때문에 인베딩과 상호 작용이 분리되어 있습니다. 마찬가지로 뉴럴 컬라버티 필터링 모델도 인베딩이 일어난 이후에 그 인베딩을 컨케이트네이트 하기 때문에 인베딩과 상호 작용이 분리되어 있는 것이죠. 그래서 각각의 인베딩이 상호 작용의 서브 옵티멀하게 학습되기 때문에 그 결과 모델이 더 정확한 표현형을 가지지 못하고 추천의 능력이 조금 떨어지게 되는 것입니다. 그래서 이 GNN 추천 모델은 유저와 아이템의 상호 작용이 유저 아이템을 임베딩 시킬 때부터 반영될 수 있도록 모델을 설계하였습니다. 먼저 아래 그림과 같이 유저가 아이템을 소비했다는 데이터 를 다음과 같은 그래프 유저 아이템 인터랙션 그래프라고 표현했습니다. 그래서 왼쪽에 유저 3명이 있고요. 오른쪽에 아이템 5개가 있죠. 그래서 이 edg는 유저 1이 아이템 1을 소비했다. 유저 3이 아이템 4를 소비했다라는 데이터입니다. 단순히 이렇게 유저 1이 아이템 1 2 3를 소비했다. 유저 2가 아이템 2 4 5를 소비했다는 데이터만을 가지고는 이 모든 유저와 아이템 간의 상호작용을 표현할 수 없습니다. 예를 들면 유저 1은 유저 1 2 3랑 연결되어 있긴 하지만 i 유저 4 아이템 4 아이템 파랑 연결되어 있지 않기 때문에 이 유저 아이템의 개수가 점점 더 많아질수록 유저와 아이템 페어의 컬라버레이트 시그널 즉 어떤 상호작용을 놓치는 경우가 생기게 되죠. 그래서 이러한 문제를 지엔엔이 가진 특성을 사용하여서 경로가 1보다 큰 하이워드 커넥티비티를 임베딩하여서 모델에 사용하였습니다. 그래서 이 부분을 이 그림을 통해 좀 자세히 설명해 보겠습니다. 먼저 이 유저 1이 소비한 아이템은 총 3개가 되겠죠. 아이템 1 아이템 2 아이템 3입니다. 그래서 패스가 1이라는 뜻은 바로 다이렉트로 연결되어 있는 엣지가 하나라는 것이죠. 그래서 여기서 이제 길이가 2인 패스로 확장하게 되면은 아이템 2에서 아이템 2를 소비한 다른 유저인 유저 2로 확장될 수 있고요. 아이템 쓰는 아이템 3를 소비한 다른 유저인 유저 3로 확장될 수 있습니다. 또 이렇게 해서 랭스 3까지 확장될 수 있겠죠. 그래서 이 그래프를 통해 세 가지를 알 수 있는데요. 먼저 유저 1과 유저 e는 아이템 2를 가지고 서로 상호작용하기 때문에 이 둘이 유사하다라는 정보 이 그래프에서 볼 수 있습니다. 두 번째는 유저 2가 이미 소비한 아이템 4 아이템 5가 시그널이 전달되어서 다음과 같이 유저 원에게 전달될 수 있기 때문에 아이템 4 아이템 5가 유저 원에게 추천될 수 있는 확률이 높다는 것을 또 이 그래프에서 의미합니다. 마지막으로 이 레이어 3에 있는 유저 1에서 아이템 2, 유저 2로 전달되는 이 레이어 3 아이템 4, 아이템 5가 존재하고 마찬가지로 유저 3로 이어지는 레이어에도 아이템 4가 존재합니다. 따라서 아이템 5보다는 아이템 4가 시그널이 두 번 전달되기 때문에 아이템 4가 추천될 확률이 조금 더 높다는 것을 의미합니다. 이렇게 하나의 노드를 기준으로 경로가 1보다 큰 하이 오더 커넥티비티 를 사용하여서 이 유저에 대한 다양한 표현형을 이 그래프 뉴얼 네트워크는 표현하고 있습니다. 그래서 전체 모델은 다음과 같습니다. 오른쪽에 있는 그림인데요. 이 레이어가 총 3가지로 구성되어 있습니다. 첫 번째 레이어는 유저 아이템을 원핫 인코딩하는 가장 기본적인 레이어로서 기존의 씨프 뉴럴 콜라베이트 필터링 모델 계열과도 동일합니다. 가장 처음 입력된 원핫 인코딩을 k 차원의 인베딩으로 바꿔주는 것이지요. 그래서 가장 중요한 부분은 사실 이 두 번째 레이어인 인베딩 전파 레이어입니다. 방금 전에 설명했던 그래프 즉 유저와 아이템의 그래프에서 인베딩이 전파되는 이 하이워드 커넥티비티가 바로 이 레이어 인베딩 전파 레이어 인패딩 프로퍼게이션 레이어에서 학습이 되는 것이죠. 그리고 이 인베딩 전파 레이어를 통해서 출력된 출력 값은 그대로 컨케이트네이트 돼서 마지막 최종 레이어 즉 유저 아이템 선호도 예측 레이어인 프로덕션 레이어에서 최종 예측 값을 구하게 됩니다. 네 그리고 그림을 보시면 이 왼쪽이 유저 노드를 기준으로 인베딩이 전파되는 유저 인베딩 레이어고요. 오른쪽은 아이템 노드를 기준으로 전파되는 아이템 레이어입니다. 방금 전에 하이 오더 커넥티비티 예시를 설명하면서 유저를 기준으로만 그래프의 연결을 설명했지만 동일하게 아이템 노드를 기준으로도 똑같이 인베딩 전파가 이루어질 수 있습니다. 그래서 각각의 유저 노드와 아이템 노드에 대한 인베딩을 각각 구하고 이 인베딩을 최종적으로 합쳐줘서 마지막 레이어에서 내적을 통해서 최종 예측 값 평점과 같은 선호도를 예측하게 되는 것이죠. 먼저 첫 번째 레이어 유저 아이템에 대한 인베딩 레이어입니다. 지난 4강의 매트리스 팩토라이제이션, 그리고 바로 전 6강에서 배웠던 뉴럴 컬라버레이트 필터링 모델에서 원 핫 인코딩 벡터를 인베딩시켰던 그 인베딩이 바로 인터랙션 펑션에 입력되어서 곧바로 선호도를 예측했지만 이 NGCF 즉 GNN을 활용한 추천 모델에서는 이 인베딩이 바로 사용되지 않고 그래프 뉴얼 네트워크 정확히는 그래프 컨볼루션 뉴럴 네트워크 상으로 전파시켜서 이것이 이 GNN 상에서 리파인 되도록 합니다. 그것은 컬래버레이티브 시그널을 명시적으로 인베딩 레이어에 주입하기 위한 과정으로 볼 수 있습니다. 그래서 첫 번째 인베딩 레이어에서는 임베딩을 생성해 준다. 그 이후 두 번째 레이어에서 생성된 인베딩을 가지고 전파시키는 레이어 가장 중요한 부분입니다. 여기서는 유저와 아이템의 컬라버레이트 시그널을 담는 것을 메시지라고 정의하고 이 메시지로 표현을 하였습니다. 일단 여기 아래에 있는 수식들은 아까와 비슷하게 유저 노드를 기준으로 소식이 설명되고 있는데요. 이제 아이템 아에서 유로 전달되는 메시지를 mui라고 표현하고 있습니다. 그래서 mui는 아이템 아이 자체가 가지고 있는 임베딩 플러스 아이템 아이와 아이템 유저의 상호작용을 표현할 수 있는 이 엘레멘트 와이스 프로덕트 이 두 개의 텀의 합으로 표현됩니다. 그리고 유저 율을 기준으로 연결돼 있는 아이템이 점점 많을수록 이 시그널은 점점 커지기 때문에 그 시그널의 크기를 노말라이제이션 해 주기 위해서 개별 메시지의 크기를 이웃한 노드의 개수로 나눠주는 노멀라이제이션 텀도 앞에 붙어 있습니다. 이제 하나의 아이템 노드 아에서 유저로 전달되는 유저 메시지를 계산하고 나면은 이 메시지는 하나가 아니라 유저를 기준으로는 여러 개의 아이템이 존재할 수 있겠죠. 그래서 이 밑에서 최종적으로 유저 인베딩을 구해주는 즉 인베딩 전파 레이어를 통해 최종적으로 새로 생성되는 이 이유1 첫 번째 전파 레이어의 최종 유저 인베딩은 다음과 같은 수식으로 표현할 수 있습니다. 먼저 그 자신으로부터 전달되는 메시지 엠유유와 이 위에서 계산한 엠유아를 주변 인접 노드들에 대해서 모두 더해주게 됩니다. 그래서 이 더한 값을 리키 밸루라는 액티베이션 펑션을 사용하여서 최종적으로 그 전 레이어로부터 전파된 인베딩들이 다음 레이어 이유원으로 표현되게 됩니다. 이제 이렇게 해서 구해진 이유원이라는 애들은 원호 전파 퍼스트 홈까지 전파된 인베딩이라고 말합니다. 이렇게 인베딩이 전파되는 레이어를 그림과 같이 원 호 퍼스트 톱 즉 하나만 쌓은 것이 아니라 패스를 2개, 3개 확장할 수 있겠죠. 그래서 엘개까지 쌓을 수가 있겠죠. 그럼 타겟 유저를 기준으로 총 l차 이웃 즉 패스가 엘만큼 떨어져 있는 이웃까지도 인베딩 전파가 이루어집니다. 그래서 이 3단계의 임베딩을 구하기 위해서는 바로 전 단계인 2단계의 임베딩을 가지고 사용해야겠죠. 그래서 다음과 같은 점화식으로 표현할 수 있겠습니다. 새로운 엘차 인베딩은 기존 바로 전에 엘 마이너스 1차 인베딩 전파의 결괏값들로 이루어져서 이 값이 전파되어서 엘차 인베딩의 값을 구하게 되는 것입니다. 여기에 있는 수식은 바로 전에 1차 인베딩을 설명했던 수식과 같은 수식인데 1이 엘로 바뀌었을 뿐입니다. 그래서 이렇게 인베딩을 하나만 쌓는 것이 아니라 2개 3개 4개 쌓는 것이 하이워더 프로퍼게이션 아까 설명했던 패스 하나짜리가 아니라 2개 3개까지의 정보들을 현재 유저 노드를 기준으로 전달시키는 과정을 표현한 것입니다. 자 그래서 우리가 엘게에 인베딩 프로파게이션 레이어 인베딩 전파 레이어를 사용했다고 하면은 총 20 처음 인베딩 레이어에서 생산된 인베딩부터 마지막 엘 차 인베딩까지 생성된 인베딩까지 총 엘 플러스 1개의 유저 인베딩 그리고 아이템도 지금 전 그림에서 설명하지 않았지만 동일하게 아이템도 생성될 수 있다고 했죠. 아이템도 마찬가지로 엘 플러스 1개의 임베딩 벡터가 생성됩니다. 그럼 요 인베딩 벡터들을 모두 컨택 하게 되고 그러면 이 두 최종 인베딩 이유 스타 이아스타는 차원이 같기 때문에 이 두 값을 내적하여서 최종적으로 우리가 원하는 그 유저가 그 아이템에 갖는 선호도 값을 계산하게 됩니다. 네 제안한 뉴럴 그래프 컬래버이트 필터링 모델의 성능 및 결과를 보시면 이제 먼저 여기에 있는 1 2 3 4는 우리가 인베딩 전파 레이어에서 인베딩 전파를 한 번 했냐 두 번 했냐 세 번 했냐 이것을 비교한 결과인데요. 인베딩 전파 레이어가 점점 많아질수록 모델의 추천 성능 이 총 3개의 데이터셋을 사용했는데요. 많아지면 많아질수록 점점 좋아지는데 다만 레이어가 너무 많이 쌓일 경우에는 오버피팅이 발생할 수 있습니다. 따라서 실험 결과 레이어가 한 3개 정도에서 4개 정도일 때 가장 좋은 성능을 보인다고 밝히고 있습니다. 네 그리고 제안한 모델을 매트리스 팩토라이제이션 모델과 비교한 부분이 있습니다. 아까 이 매트리스 팩토라이제이션 모델은 유저 아이템을 학습시킬 때 그 인베딩 학습과 상호 작용이 분리되어 있다고 말씀드렸는데요. 이 NGCF는 그렇지 않기 때문에 이 인베딩을 더 잘 표현한다는 것을 다음 다음 실험을 통해서 입증하고 싶었습니다. 먼저 어떤 데이터셋을 사용해도 매트리스 팩토라이제이션보다 이 NGCF가 더 모델 성능이 빠르게 수렴하고 추천 성능인 리콜도 더 높음을 알 수 있습니다. NGCF가 모델의 캐패시티 즉 모델의 표현력과 갖고 있는 파라미터의 개수가 훨씬 크고 또 제일 중요한 이 인베딩 전파를 통해서 유저와 아이템에 대한 레프리젠테이션 파워가 더 좋기 때문입니다. 이 레프레젠테이션 파워가 좋다. 즉 유저와 아이템을 더 잘 표현한다라는 것은 시각화를 했을 때도 정성적으로 확인해 볼 수 있습니다. 이제 오른쪽에 있는 그림을 보시면 왼쪽이 MF의 인베딩이고요. 오른쪽이 NGCF 세 번째 레이어의 인베딩입니다. 그래서 이것을 보기 좋게 표현한 것인데요. 여기서 이 별표들은 유저 그리고 아이템은 동그라미를 의미합니다. 그리고 같은 색을 가지는 유저는 그 유저가 해당 아이템을 과거에 소비하였음을 의미합니다. 그 시각화된 결과를 통해서 보시면 오른쪽에 있는 NGCF는 이 유저를 기준으로 그 유저가 과거에 소비한 아이템들이 비슷한 공간에 인베딩이 되어 있죠. 마찬가지로 이 노란색 유저가 과거에 이 아이템들을 소비했고 그래서 그 인베딩 유저와 아이템의 인베딩이 비슷한 공간에 임베딩이 되어 있습니다. 근데 매트리스 팩토라이제이션 같은 경우에는 그 유저가 소비한 아이템 노란색을 봤을 때 이 유저의 인베딩과 아이템의 인베딩이 다소 떨어져 있는 것을 볼 수 있죠. 그 이유는 이 유저 아이템 인베딩을 학습할 때 우리가 유저 아이템의 상호 작용을 직접적으로 그 인베딩에 주입했다. 따라서 그 상호작용이 더 인베딩에 잘 표현된다 라고 볼 수 있습니다. 그리고 이 레이어가 점점 많아질수록 더 명확하게 구분되고 있습니다. 여기까지가 neural graf 컬래버이트 필터링에 대한 전반적인 내용이었고요. 이 GNN 기반 추천 시스템에서 제일 중요한 개념 즉 인베딩 전파되는 레이어 어떻게 인베딩이 계속해서 학습이 되고 그 상호작용이 어떻게 인베딩 단에서 주입되는지를 담고 있는 제일 중요한 개념을 담고 있는 모델이기 때문에 자세하게 설명을 했습니다. 이어서는 NGCF보다는 조금 더 간단한 GCN 즉 그래프 컨볼루션 네트워크의 가장 핵심적인 부분만 사용하여서 더 정확하면서도 파라미터 수 모델 캐파시티는 좀 작은 라이트 지시엔이라는 논문 그 모델을 살펴보도록 하겠습니다. 라이트 GCN의 아이디어는 먼저 가벼운 모델입니다. 기존의 NGCF 모델은 인베딩 전파 레이어에서 컨볼루션을 할 때 매번 학습 파라미터를 인베딩에 곱하고 거기에 노리어 트랜스포메이션 리키렐로를 사용했는데요. 라이트 지시에는 그 인베딩 노드의 파라미터를 곱하지도 않고 단순하게 인베딩을 가중합하는 것이 전부입니다. 그래서 학습 파라미터와 연산량이 NGCF에 비해서 훨씬 감소하게 됩니다. 또한 이 레이어의 깊이 즉 인베딩 전파 레이어의 깊이가 계속 깊어질수록 그 강도가 약해질 것이라는 아이디어를 사용하여서 그 라이트 GC에는 인베딩을 합칠 때도 굉장히 단순한 방법을 사용하였습니다. 다음 그림을 통해 조금 더 두 모델의 차이점을 비교해 보겠습니다. 크게 두 가지 부분이 다릅니다. 처음에 인베딩 원핫 인코딩이 인베딩 되는 것은 동일하고요. 먼저 이 가운데 있는 인베딩 전파 레이어 라이트 지센 같은 경우는 이 부분인데요. 이 부분이 라이트 지센이 좀 더 간단하게 이루어져 있고요. 그리고 이 마지막에 프리딕션 레이어 부분도 기본에 기존에 NGCF는 컴케이트 네이트를 했는데 여기서는 단순하게 가중합으로 더한다고 표현되어 있습니다. 여기 웨이트드 썸이라고 표현되어 있죠 이 각각의 차이를 좀 더 수식을 통해서 자세히 비교해 보도록 하겠습니다. 먼저 인베딩 전파 레이어 부분의 차이점을 봅시다. 이 왼쪽에 있는 수식이 방금 전 슬라이드에서 다뤘던 방금 전 파트에서 다뤘던 NGCF 모델의 수식이었고요. 오른쪽이 현재 이야기하고 있는 라이트 GCN의 인베딩 전파 레이어의 계산 수식입니다. NGCF 같은 경우에는 케차 인베딩 즉 바로 전 전파되기 전에 인베딩에다가 각각의 학습 파라미터를 곱하고 거기에 액티베이션 펑션까지 통과시켜서 결국 케이 플러스 1차 인베딩을 구합니다. 다소 복잡하죠. 그러나 라이트 GCM 같은 경우에는 피처 트랜스포메이션이나 논리뉴 액티베이션 같은 펑션 없이 단순하게 바로 전에 전파된 바로 전에 있는 레이어, 즉 k차 인베딩 레이어에 있는 인베딩 값을 단순히 가중치를 사용해서 합하는 것이 전부입니다. 또한 연결된 이웃 노드 정보만을 사용했기 때문에 NGCF에서는 다음과 같은 셀프 커넥션 즉 유저에서 유저로 가는 표현도 있는데요. 어 라이트 GCM 같은 경우에는 이 유저에 대한 표현을 자기 자신은 빼고 연결되어 있는 아이템의 인베딩만을 가지고 표현합니다. 그래서 최종적으로 보시면은 이 베딩이 NGCF 모델은 인베딩 전파 레이어의 학습 파라미터가 존재하지만 라이트 GC에는 이 인베딩 전파 레이어의 학습 파라미터가 1개도 존재하지 않습니다. 처음에 입력될 때 원핫 인코딩이 이 인베딩으로 표현될 때만 그 0번째 인베딩 레이어에서만 학습 파라미터가 존재하고 그 이후에는 파라미터 학습 파라미터의 추가 학습 없이 단순하게 계속 가중 평균을 활용한 전파만 사용하게 됩니다. 네 마지막은 예측 레이어입니다. 바로 전에 인베딩 전파 레이어에서 구해진 인베딩을 어그리게이트 하여서 최종 예측을 수행하는 레이어입니다. 이제 이 예측 레이어도 라이트 GCN는 NGCF보다 조금 더 가볍게 다르게 구성하였는데요. NGCF 같은 경우에는 0차 인베딩부터 엘차 인베딩까지 모두 가로로 컨케이트네이트에서 유저와 아이템의 임베딩을 구했습니다. 이 라이트 GCM 같은 경우에는 가로로 컨케이트네이트 하지 않고 이 알파 케라는 가중치를 사용하여서 단순하게 더했는데요. 컨케이트네이트를 하면 계속해서 차원이 옆으로 늘어나지만 이렇게 가중합을 할 경우에는 정보를 조금 더 압축해서 표현하는 것입니다. 따라서 이 가중치를 어떻게 사용하면서 압축하느냐가 중요한 부분인데요. 본 논문에서는 이 알파 케 가중치를 학습 파라미터로 사용할 수도 있고 하이퍼 파라미터로 사용할 수도 있다고 했습니다. 하지만 둘의 별 차이가 없기 때문에 굳이 학습 파라미터를 늘리지 않고 하이퍼 파라미터를 사용했습니다. 그래서 이 하이퍼 파라미터는 케 플러스 1 분의 1을 사용했는데요. 즉 레이어 이 케에가 점점 깊어질수록 가중치는 점점 작아지는 것이죠. 이 의미는 아까 얘기한 대로 인베딩이 처음보다 점점 전파될수록 그 인베딩의 시그널이 약해질 것이라는 아이디어를 사용하여서 그 아이디어를 수식적으로 주입한 것입니다. 최종 결과 및 요약입니다. 라이트 GCM 모델을 계속해서 NGCF와 비교했는데요. 실험 결과도 베이스 라인을 NGCF 모델로 삼고 성능을 비교했습니다. 학습을 통한 로스 펑션 손실 함수와 그리고 각 데이터셋 별로 성능인 위코 모두 NGCF보다 뛰어난 성능을 보였습니다. 이는 라이트 GCN이 NGCF보다 제너럴라이제이션 파워 즉 일반화 능력이 더 좋다는 것인데요. NGCF 같은 경우에는 아까 언급했듯이 인베딩 전파 레이어 매번 하나하나마다 학습해야 되는 파라미터가 존재했고 또 모델 구조가 복잡하기 때문에 오버피팅의 위험이 있는 반면에 라이트 GCN은 모델 구조를 단순하게 구성하되 GCN에서 제일 중요한 컨볼루션을 놓치지 않아서 최대한 정보를 잘 압축하였고 더 예측력을 뛰어나게 상승시켰습니다. 자 여기까지가 GNN을 활용한 정확히는 그래프 컨볼루션 뉴럴 네트워크 GCN을 활용한 추천 모델을 살펴보았습니다. NGCF와 lit GCN이었고요. 번외로 이런 GNN 계열의 모델은 실제로 네이버나 왓챠 같은 이런 실제 서비스에서도 유저 아이템을 잘 표현하는 추천 모델로 활발하게 사용되고 있다고 합니다. 다음은 RNN을 활용한 추천 모델입니다. RNN의 개념을 이해하고 이를 적용한 추천 시스템 모델에 대해서 살펴보겠습니다. 먼저 RNN 모델을 간단하게 리캡하고 이 RNN을 사용한 대표적인 추천 모델인 gr 4 LA 모델을 다루겠습니다. 먼저 알앤엔을 사용한 추천 모델을 다루기 전에 알앤엔과 그 계열의 모델들을 간단하게 리뷰만 하겠습니다. 이 RNN 같은 경우에는 시퀀스 데이터의 처리와 이해에 굉장히 좋은 성능을 보이는 모델입니다. 현재의 상태가 그다음 상태 즉 시퀀셜하게 영향을 미치도록 루프 구조를 사용하고 있는데요. 그래서 이 그림을 보시면은 이렇게 루프 형태로 표현할 수 있지만 사실은 시퀀셜한 인풋이 들어왔을 때 계속해서 시퀀셜하게 각각의 셀이 계산돼서 이 정보는 다음으로 넘어가게 되고 또 그다음 정보는 그 다음 스텝으로 넘어가는 이런 시퀀셜한 구조를 사용해서 마지막 최종 예측을 수행하게 됩니다. 자 다음은 알의 대표적인 모델인 엘스티엠입니다. 이 LSTM 같은 경우에는 시퀀스가 점점 길어질수록 그 시퀀스의 학습 능력이 현저하게 저하되는 이런 RNN의 한계를 극복하기 위해서 롱 숏텀 메모리라는 개념을 추가한 모델입니다. 그래서 장기 의존성 의 문제를 해결하기 위해서 셀 스테이트라는 구조를 고안하였고요. 여기 부분 보시면 게이트는 총 폴 겟 인풋 아웃풋 게이트라는 것을 활용하는데요. 이제 이전 셀에서 장기 기억이 전달되었을 때 얼마큼 그 기억을 살릴 것인지가 f g 게이트고요. 그리고 이 t 스텝에서 입력된 입력 변수를 얼마큼 사용할 것인지 인풋 게이트가 되겠고요. 그리고 그 다음 아웃풋 게이트는 얼마큼 출력할 건지에 대한 내용을 정보를 조절합니다. 그리고 요 셀 스테이트 부분은 계속해서 다음 셀로 전달되게 되는데요. 이제 이 부분이 장기 기억을 계속해서 다음 셀로 전달하는 부분이라고 볼 수 있습니다. 자 다음은 GRU 모델인데요. 사실 이 GRU 모델이 이 다음에 배울 추천 모델 gr 4 r에 사용되는 레이어입니다. 그래서 GRU는 방금 언급했던 LSTM의 변형 중의 하나로 LSTM과는 다르게 출력 게이트가 따로 없어서 LSTM보다 파라미터가 적고 연산량도 훨씬 적은 가벼운 모델입니다. 그래서 모델의 구성을 간단하게 보시면은 어 출력 게이트가 있다고 해서 게이트가 총 2개로 구성되어 있는데요. 리셋 게이트와 업데이트 게이트 이 부분이 리셋이고요. 이 부분이 업데이트가 됩니다. 리셋 같은 경우에는 아까 LSTM과 비슷하게 바로 전 셀에서 들어오는 정보를 얼마큼 버리고 얼마큼 기억할지에 대한 부분이고요. 업데이트는 이제 인풋과 그전에 정보를 활용해서 얼마큼 새로 들어오는 입력 정보와 과거 정보를 사용해서 업데이트할지에 대한 부분입니다. 자세한 설명을 다 하진 않겠지만 LSTM과 GRU는 성능 측면에서는 큰 차이가 없고 그래서 GRU가 훨씬 더 가볍기 때문에 어 지알도 많이 사용을 합니다. 그래서 여러분들이 수행하는 각각의 테스크에 맞게 적합한 모델을 선택하면 되는데요. 그렇다면 이러한 RNN 모델이 추천 시스템에 어떻게 적용될 수 있을까요? 이 추천 시스템의 시퀀스를 더한 문제가 바로 이 세션 베이스 레코멘데이션 문제입니다. 고객의 선호가 고정된 것이 아니라 시간에 따라서 혹은 지금 무엇을 계속 소비해 왔느냐에 따라서 달라지게 된다는 것인데요. 따라서 세션 베이스 레코멘데이션이 풀고자 하는 문제는 바로 지금 고객이 좋아할 만한 추천 아이템을 제공해 주는 것입니다. 참고로 유저가 서비스를 이용하는 동안의 행동 데이터를 묶어서 세션 이라고 말하는데요. 예를 들면 브라우저가 종료되기 전까지 그 브라우저 안에서 행동했던 데이터들을 쿠키 형태로 저장하는데 그것을 세션이라고 합니다. 그래서 아래의 그림처럼 사용자가 이런 아이템들을 차례대로 소비했을 때 하나의 세션 안에서 4개의 아이템을 소비했을 때 그다음에 아이템으로 무엇을 소비할지를 예측해서 그 아이템을 추천해 주는 문제가 바로 세션 베이스 레코맨데이 시스템의 문제입니다. 그러면 이 세션 베이스 추천 시스템 이 문제를 해결하기 위한 추천 모델인 GRU 4 LA에 대해 살펴봅시다. 아까 얘기했던 대로 이 모델은 GRU 레이어를 사용하여서 시퀀셜하게 지금 고객이 현재까지 어떤 아이템을 순차적으로 소비해 왔을 때 바로 그다음 아이템이 무엇인지를 추천해 주는 모델입니다. 이 GRF 렉의 모델 구조와 아이디어는 다음과 같습니다. 이 세션이라는 시퀀스 그 세션에서 아이템을 어떤 아이템을 소비해 왔는지라는 시퀀스를 GRU 레이어에 입력하여서 바로 다음에 올 아이템이 무엇인지 가장 확률이 높은 아이템이 무엇인지 를 분류하고 가장 확률이 높은 그 아이템을 추천해 주는 문제입니다. 네 모델 구조를 살펴보겠습니다. 먼저 입력 부분은 원 핫 인코딩 된 아이템으로 이루어진 세션입니다. 여기서 보시면은 인베딩 레이어가 들어가 있는데 점선으로 들어가 있음을 알 수 있습니다. 본 모델에서는 인베딩 레이어를 사용하지 않았을 때 성능이 더 높다고 했는데요. 사실 이 모델 이후에 RNN 계열의 추천 모델들에서는 인베딩 레이어를 사용한 논문도 많아 습니다. 따라서 이 인베딩 레이어를 사용했다 사용하지 않았다는 사실 이 GRU 4 r에서 그렇게 중요한 내용은 아닙니다. 이제 그 이후에 시퀀셜한 아이템들이 GRU 레이어를 통과하게 됩니다. 그래서 이 시퀀스 상에 어떤 아이템들의 순서와 맥락 그 컨텍스트 정보를 학습하게 됩니다. 그리고 이 마지막에는 이 피드 포워드 유뉴럴 네트워크를 통해 최종 마지막 골라질 아이템에 대한 스코어를 예측하게 됩니다. 이 부분 피드 포드 유뉴럴 네트워크 부분도 이 모델에서는 선택적으로 사용하였습니다. 그래서 모델의 구조는 굉장히 간단했고요. 이다음에 모델이 학습될 때 사용되었던 몇 가지 테크닉을 추가적으로 다루겠습니다. 먼저 세션 패럴러 즉 이 세션의 길이들이 각각의 사용자마다 혹은 어떤 데이터마다 긴 것도 존재하고 짧은 것도 존재하고 모두 길이가 다르다는 것입니다. 대부분은 짧지만 굉장히 아이템을 많이 소비한 길이가 긴 세션도 존재할 수 있다는 것이죠. 그래서 아래 그림과 같이 세션별로 그 안에 들어있는 아이템들은 모두 다릅니다. 그래서 이 길이가 짧은 세션을 그대로 학습에 사용했을 때는 학습이 비효율적으로 일어나게 됩니다. 그래서 보시면은 이 세션들 5개를 가지고 미니 배치 학습을 수행할 때 이 세션 4와 세션 5는 세션의 길이가 비교적 짧은 세션 1과 2에 다음과 같이 붙여서 미니 배치를 구성하고 있습니다. 그래서 하나의 세션을 그대로 사용하는 것이 아니라 세션의 길이가 좀 짧은 것들은 다른 세션에 뒤에 붙여서 병렬적으로 구성하여서 미니 배치 학습이 좀 더 효율적으로 이루어질 수 있도록 테크닉을 적용하였습니다. 두 번째는 학습 데이터를 샘플링하는 테크닉입니다. 현실에서는 아이템 수가 굉장히 많기 때문에 이 모든 후보의 아이템에 대한 확률을 다 계산할 수 없습니다. 그래서 아이템을 negative 샘플링을 해서 서셋만으로 로스를 계산해야 합니다. 그래서 아이템을 상호작용하는 것들은 우리가 가지고 있지만 그렇지 않은 그 유저가 그 아이템을 상호 작용하지 않았다는 데이터는 우리가 없죠. 그러면 그 상호작용하지 않은 아이템에 대한 평가는 어떻게 해야 될까요? 그 사용자가 존재를 아예 몰랐을 수도 있고 아니면 반대로 그 아이템을 확인했지만 클릭하지 않았을 수도 있죠. 이제 그러한 어려움이 있는데요. 이제 이 어려움을 극복하기 위해서 아이템의 인기도가 높았는데 상호 작용이 없었다면 인기도가 높을수록 아무래도 사용자가 관심이 없었을 거다라고 가정하고 인기도에 기반한 negative 샘플링을 제시합니다. 그래서 사용자가 인터랙션 하지 않은 아이템들은 굉장히 많고요. 인터랙션 아이템은 별로 없겠죠. 그럼 이것을 다 학습 데이터를 사용하는 것이 아니라 이 데이터 가운데 인기도가 높은 것들은 좀 많이 negative 샘플링으로 뽑고 인기도가 낮은 것은 거의 뽑지 않는 방식으로 이 positive 샘플과 negative 샘플 전체를 구성하게 됩니다. 네 그래서 GRU 4l의 최종 결과 및 요약 부분입니다. 주어진 데이터셋에 대해서 클래식한 추천 모델인 아이템 KNN 모델과 비교를 했는데요. 이 모델 대비 약 20% 정도의 높은 추천 성능 리콜과 엠알알을 보였습니다. 본 논문은 모델은 고정시키고 다양한 로스를 사용하기도 했고, 또 모델 안에서 쥐알유 레이어의 히든 유닛도 서로 다르게 실험을 하여서 비교를 했는데요. 전반적으로는 GRU 레이어의 헤드 유닛이 많아질수록 더 좋은 추천 성능을 보였다고 이야기하고 있습니다. 네 이상 7강 GNN과 RNN을 활용한 추천 모델 에 대한 강의를 모두 마쳤습니다. 모두 수고하셨습니다."
}