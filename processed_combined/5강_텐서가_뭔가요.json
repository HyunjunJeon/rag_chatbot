{
  "lecture_name": "5강_텐서가_뭔가요",
  "source_file": "5강_텐서가_뭔가요_69.mp4_2025-12-04-103840238.json",
  "text": "안녕하세요. 에스메릭스폴 알티퓨셜 인텔리전스 5강 텐서가 뭐예요? 강의를 맡게 된 고려대학교 통계학과 임성빈 교수입니다. 오늘 강의에서는 지난 시간까지 배웠던 선형대수학의 기본적인 개념인 벡터 그리고 행렬을 넘어서 이번엔 텐서의 개념을 알아보고 그다음에 이 텐서를 이용한 계산에서 실제로 어떤 식으로 구현할 수 있는지를 살펴보도록 하겠습니다. 텐서라는 개념이 뭔지를 좀 살펴보면 좋은데요. 어 우리가 딥러닝 프로그래밍에서 가장 많이 사용되고 있는 텐서 플로우나 파이토치 프로그래밍에서 사용하게 되는 데이터 타입을 잘 보시면은 둘 다 텐서란 용어를 사용한다는 거를 보실 수가 있게 됩니다. 어 그래서 이 딥러닝 프로그래밍을 공부하시는 분들께서는 텐서라는 용어에 좀 익숙해지실 필요가 있겠는데요. 텐서란 개념이 무엇인지 이번 시간에 좀 더 배워보도록 하겠습니다. 네 앞서 배웠던 선형대수 시간에 벡터랑 행렬은 벡터의 경우는 우리가 1차원 배열이라고 배웠고 행렬은 2차원 배열이라고 배웠죠. 텐서는 엔차원 텐서를 우리가 어떻게 정의하냐면은 엔 마이너스 1차원 텐서를 원소로 가지는 배열입니다. 만약에 벡터인 경우랑 행렬인 경우를 잘 살펴보시면 벡터는 우리가 숫자로 이루어져 있는 배열이라고 이해하시면 되겠죠 그러니까 벡터는 1차원 텐서로 이해하실 수가 있고 행렬의 경우에는 1차원 텐서인 벡터를 원소로 가지는 2차원 텐서가 되겠습니다. 즉 2차원 배열이 되는 것이죠. 그래서 앞서 배웠던 벡터는 사실 1차원 텐서 행렬은 2차원 텐서로 여러분들께서 기억하시면 되겠습니다. 이거를 좀 더 확장해서 행렬을 원소로 가지는 3차원 텐서도 우리가 얘기해 볼 수가 있겠죠 네 당연히 3차원 텐서가 있으면 4차원 텐서도 있고 5차원 텐서도 있습니다. 이렇게 일반적으로 3차원 이상부터는 우리가 보통 엔차원 텐서라고 이제 부르게 됩니다. 엔차원 텐서의 경우에는 우리가 이제 수식으로 표현하게 됐을 때 어 인덱스의 개수가 몇 개인지를 좀 보시면 엔 개가 된다는 걸 볼 수가 있는데요. 잘 살펴보시면 벡터의 경우에는 사실 XI로 표시할 수가 있었죠. 이때 이 아이의 개수는 14부터 d까지 총 2개의 어로 차원으로 표현이 되게 되는데 이 인덱스 개수 그 자체만 보게 되면은 아이라는 하나로만 표현이 되죠. 그래서 여기서 말하는 인덱스 개수라는 거는 이 차원을 말하는 것이 아니고 이 벡터를 표현할 때 사용하게 되는 이 인덱스의 문자의 개수라고 보시면 되겠습니다. 이때 이 인덱스 개수가 하나면 1차원 텐서가 되는 것이고요. 행렬의 경우처럼 만약에 두 개의 인덱스를 가지고 표현하게 된다면은 2차원 텐서가 되는 것이고 만약에 3개의 인덱스를 가지고 표현해야 된다면은 우리는 3차원 텐서라고 부르면 되겠습니다. 그럼 만약에 인덱스의 개수가 n개면은 당연히 n차원 텐서가 되겠죠 그렇다면 텐서는 주로 언제 사용하게 되는 것일까요? 네 사실 저희가 사용하게 되는 대부분의 데이터 중 텐서로 많이 표현이 되는데 그 중 하나인 영상 데이터 같은 경우에는 어 실제로는 그 2차원 데이터로 여러분들이 보실 수 있지만 사실 영상 데이터를 여러분이 잘 살펴보시면 알지비로 우리가 분해를 할 수가 있는데 각자 2차원 행렬들이 3개 즉 3개의 채널로 이루어져 있는 데이터라는 거를 우리가 사실은 알 수가 있게 됩니다. 즉 다시 말해 행과 열로 이루어져 있는 2차원 배열이 3개로 이루어져 있고 그렇다면 이 3개의 또 다른 차원이 발생하는 걸로 볼 수가 있겠죠 그래서 사실 영상 데이터는 3차원 텐서로 여러분들께서 이해를 하실 수가 있게 됩니다. 즉 표현을 해주게 되면은 채널이 3개니까요. 총 3개의 우리가 채널 인덱스를 표현하게 될 텐데 행렬이 총 3개가 있는 것이죠. 그래서 첫 번째 채널에 해당하는 스시1 뭐 레드 채널이라고 볼게요. 두 번째는 c2 채널에 해당하는 스시2에서는 그린에 해당하는 거겠죠. 마찬가지로 블루에 해당하는 게 xc3로 표현할 수가 있게 되는 것이고 각각은 2차원 배열인 행렬입니다만 이렇게 3개의 채널로 구성돼 있는 이 x 3차원 텐서가 실제로는 영상 데이터가 되는 것입니다. 하나의 영상 데이터가 되는 것이죠. 네 그래서 채널 개수가 아닌 인덱스의 개수가 3개라서 우리는 이제 3차원 패스어라고 부른다는 사실을 일단은 기억을 해 주시고요. 수식으로 표현해 주게 되면은 씨바 치바 블로 우리가 3차원 텐서를 표현할 수가 있게 됩니다. 그리고 이렇게 영상 데이터가 여러 개가 있는 경우에는요. 각각의 이제 3차원 텐서들이 여러 개가 있는 걸로 볼 수가 있겠죠. 지난 시간에 데이터를 우리가 담아내는 걸 행렬이라고 불렀습니다. 각각의 데이터가 벡터일 때 그 벡터를 모은 걸 행렬이라고 부른다고 했었는데요. 그렇다면 3차원 텐서로 이루어져 있는 영상 데이터는 몇 차원 텐서가 될까요? 네 맞습니다. 4차원 텐서가 됩니다. 그래서 3차원 텐서로 이루어져 있는 어레이가 되는 것이기 때문에 이 4차원 텐서는 실제로 영상 데이터로 구성돼 있는 데이터 집합이 되는 것이고 이때 각 영상 데이터의 개수를 비라고 했을 때 우리가 이렇게 비라는 차원이 하나 더 늘어나서 수식으로는 BB, c hv w로 표현하게 됩니다. 우리가 딥러닝에서 사실 쓰게 되는 배치라는 표현이 이때 많이 쓰이게 되는데요. 보통 이 b라는 기호는 배치 또는 미니 배치 개수의 의미를 하는데 이것은 이 데이터에 들어가 있는 영상 데이터의 개수를 의미한다라는 거를 기억해 주시면 좋겠습니다. 네 텐서 연산도 사실은 벡터랑 행렬 연산과 마찬가지로 어 텐서끼리 같은 모양을 가지면 덧셈 뺄셈 그리고 성공 곱도 모두 정의를 할 수가 있습니다. 그래서 수식이 인덱스의 개수가 늘어나다 보니까 좀 복잡해 보일 수는 있겠지만 텐서끼리의 덧셈 뺄셈 그리고 텐서끼리의 성품 곱은 사실 각각의 덧셈 뺄셈과 각각의 곱셈으로 표현이 된다. 그래서 벡터와 행렬에서 썼던 그런 공식들을 우리가 똑같이 텐서에서도 활용할 수 있다라는 점을 기억하시면 좋겠습니다. 하지만 문제는 곱셈입니다. 사실 벡터의 곱셈과 행렬의 곱셈이 달랐듯이 텐서의 곱셈도 좀 복잡하게 정의가 되기 때문에 여러분들께서 조금 조심해서 살펴보셔야 될 텐데요. 특히 n파의 연산마다 텐서 곱이 행렬 곱이랑은 조금 다르게 동작하는 경우가 있을 수 있어서 여러분들께서 좀 주의를 하실 필요가 있습니다. 가령 x라는 텐서랑 y라는 텐서의 도트 그리고 x라는 텐서랑 y라는 텐서의 매트릭스 멀티플리케이션 이 두 함수는 행렬에서는 둘 다 행렬곱을 계산하는 기능을 담당했었지만 3차원 이상의 텐서부터는 계산 방식이 달라지게 됩니다. 그래서 n파이 도트 같은 경우에 실제로 3차원 어 텐서에 적용하시게 되면은 4차원 텐서가 결괏값이 나오고요. 매트릭스 멀티플리케이션 함수를 가져와서 적용해 주게 되면은 이렇게 3차원 텐서가 됩니다. 그 이유는 두 개의 텐서 곱에 적용되는 공식이 다르기 때문에 그렇습니다. 먼저 도트 같은 경우에는 비아케 인덱스와 피케 제 인덱스에서 각각의 케에 대한 성분 합으로 정의되는 것인데 메트리스 멀티플리케이션은 비아케와 그리고 비 케제에 대해서 비가 동일한 인덱스에 대해 케이들끼리 서로 곱해서 더해주는 걸로 우리가 정의를 해 줍니다. 따라서 도트 같은 경우에는 비랑 피라는 인덱스가 추가되기 때문에 비아피제가 되는 것이고 매트릭스 멀리플리케이션은 공통된 비에 대해서만 계산을 해주니까 비아제가 되는 것이죠. 그래서 각각의 결과 값이 아주 다르기 때문에 여러분들께서 사용하실 때 함수의 이름만 보고 판단하시면 안 되고 함수에 사용되는 수식적인 정의를 보시고 여러분의 달리 사용해야 된다는 주의가 좀 필요합니다. 근데 넘파이에서 이런 것들을 다 하나하나씩 기억하는 것은 좀 괴로운 일이죠. 그래서 이런 문제를 해결하기 위해서 좀 쓸 수 있는 이제 아주 편리한 라이브러리를 좀 소개를 하려고 합니다. 그것은 바로 아인 썸 즉 아인슈타인 표기법이라고 부르는 아인슈타인 서메이션을 사용하는 표기법입니다. 아인 썸은 아인슈타인 표기법에서 유래한 것인데 텐서를 활용한 여러 종류의 곱 연산에서 좀 편리하게 여러분들이 사용해 볼 수가 있습니다. 가령 앞서 배웠던 행렬 곱 연산을 좀 다시 한 번 생각해 보시면요. 행렬곱은 스라는 행렬과 와라는 행렬에 행벡터와 열벡터 사이의 내적으로 계산된다고 했습니다. 즉 x라는 행렬의 행벡터들의 원수와 y라는 행렬의 열벡터들의 원수의 내적이기 때문에 각각의 이 x라는 행벡터의 열의 인덱스와 y라는 열 벡터의 이 행의 인덱스가 서로 일치한 상태에서 이 합을 수행하게 되는데 이게 이제 내적 계산이 되겠죠. 이거를 우리가 아인슈타인 표기법으로 다음과 같이 표기할 수 있습니다. 즉 반복적인 덧셈 기호를 생략하고 대신에 이 k라는 인덱스를 공통시켰으니까 케에 대해서 합을 표현하는구나라고 우리가 이제 규칙을 가지고 연산을 이제 표현하게 되는 것인데요. 즉 ikkj 그리고 그 결과가 i제다라고 하게 되면은 우리가 자연스럽게 아이랑 제이는 고정된 인덱스고 k에 대해서 합을 취해주는 연산이구나라고 우리가 정의를 하고 이렇게 텐서업 연산을 정의해 주는 게 아인슈타인 표기법이 되겠습니다. 이 아인슈타인 표기법을 사용해 주게 되면은 우리가 인덱스를 유추해서 텐 속업을 정의해서 사용할 수 있게 되는데요. 가령 행렬 곡 같은 텐서 곡은 어떻게 정해질 수가 있냐면은 목표가 되는 거는 아제이고 중간 행렬들 스랑 와에 아케와 케제에 해당하는 인덱스끼리 곱해서 더해 준다. 즉 행벡터와 열벡터를 내적해 준다라는 거를 우리가 다음과 같이 쓸 수가 있는데 이 수식을 잘 살펴보시면 이 앞서 사용했던 공식이랑 일치한다는 걸 볼 수가 있습니다. 즉 IK 인덱스를 먼저 쓰시고 그다음에 kj 인덱스를 쓰시고 이때 서메이션이 생략된 상태에서 케이가 사라지고 남는 것은 아제이다라고 이렇게 쓰시게 되면은 이 행렬 곱의 연산의 결과값이 사실 아케와 케제 간의 내적이다라는 거를 아인슈타인 서메이션에서 알 수가 있습니다. 그래서 이 수식을요 아케랑 케제를 묶어서 아제로 보낸다라고 써주게 되면은 이 라인 섬 연산은 두 행렬곱의 연산을 실제로 처리를 해주게 됩니다. 행렬구뿐만 아니라 사실 아인선 같은 경우에는 전치 행렬도 표현할 수가 있습니다. 전치 행렬 같은 경우에는 앞서 살펴보신 것처럼 아이랑 제이라는 인덱스의 순서를 바꿔서 제아로 바꾸는 것이었죠. 그러면은 아 제 인덱스를 제아로 바꾼다라고 우리가 이렇게 써주게 되면은 결과값은 x제아다라고 인식하게 되니까 두 개의 인덱스의 순서를 바꿔주는 연산을 수행해 주게 되고 결과적으로 우리는 x라는 행렬에 아제 인덱스를 바꿔주세요라고 계산해 줄 수 있어서 전체 행렬을 구할 수가 있게 됩니다. 이와 같이 행렬곱이나 전체 행렬처럼 수식으로 표현될 수 있는 연산들은 우리가 아인 썸 라이브러리를 해 가지고 우리가 쉽게 어 텐서 연산들도 다 계산을 할 수가 있는 장점이 있습니다. 네 그리고 행렬 파트에서 배웠던 내적 연산도 사실은 해볼 수가 있는데요. 어 행렬 연산 같은 경우에는 사실 트랜스포트 시키고 곱해주면 되니까 쉽게 해줄 수가 있는데 이거를 한번 연습 차원에서 한번 살펴보도록 하겠습니다. 이 경우에는 IK랑 JK를 곱해서 내적시켜주는 것이죠. 이때 i랑 j는 고정된 상태에서 k를 바꿔주면서 더해준다라는 아인슈타임 서메이션이 표기법이 적용되어 있습니다. 그리고 그 결과값은 GI제로 표현되는 것이고요. 이때 행렬의 내적은 전치시킨 다음에 행렬곱을 취해 주는 거니까 왠지 여러분들께서 보셨을 때 이 위에 있는 2개의 연산을 반복적으로 적용하는 것처럼 보일 수 있어요. 그래서 와의 트랜스포즈는 앞서 썼던 전체 행렬을 시키는 아인 썸 연산을 적용해 주고 그다음에 이 트랜스포즈랑 원래 스의 행렬 급을 연산을 해주는 거니까 아케랑 케제를 아제로 보내주는 행렬 곱 연산을 취해주면은 이 두 행렬의 행렬 내적을 계산할 수 있게 되겠습니다만 실제로는 그냥 아케랑 제케를 묶어서 아제로 보내주세요라고 여러분이 쓰시면 네 두 줄로 표현하는 행렬 내적을 이렇게 한 줄로 쓸 수 있기 때문에 훨씬 더 직관적으로 여러분이 텐서 연산 텐서 곱을 정의할 수가 있게 되는 것이죠. 네 그래서 텐서 연산을 조금 더 우리가 한번 이해를 해 볼 것인데요. 앞서 설명드렸던 도트 같은 경우에는 bik랑 PK제를 받아서 BiP제로 보내는 연산으로 우리가 이해할 수가 있겠죠 케라는 합을 쓰고요. 그렇다면 아인슈타인 표기법에 따르면 bik랑 PKJ를 받아서 bipj로 보내는 연산이라고 얘기할 수 있으니까 bik랑 PKJ를 받아서 bipj로 보내는 연산으로 여러분이 아인선 표기를 쓰시면 네 도트 연산의 논파이 도트 연산을 구현하실 수가 있게 됩니다. 마찬가지로 매트릭스 멀티플리케이션의 경우 비아케랑 비케제를 받아서 비아제로 보내는 수식 연산이니까요. 비아케랑 비케제를 받아서 비아제로 보낸다라고 이렇게 써 주시게 되면은 매트릭스 멀티플리케이션도 똑같이 아인 썸으로 표현할 수가 있게 됩니다. 즉 여러분이 엠피도트랑 엠피 메트멀리플리케이션의 수식을 어떤 식으로 이게 정의가 되는지 다 기억하실 필요 없이 즉 도함수랑 몇몰 함수가 어떻게 동작하더라 이거를 외우실 필요 없이 내가 수식으로만 표현할 수가 있으면 그러니까 아인슈타임 서메이션 수식으로 표현되는 방법만 아시면은 이렇게 아인 썸으로 한 번에 다 동일하게 표현할 수 있기 때문에 굉장히 여러분이 가독성 있고 효율적인 어 텐서 곱을 다루실 수가 있게 됩니다. 아인 썸의 경우에는 실제로 넌 파일뿐만 아니라 파이토치 텐서플로우 그리고 잭스에서도 지원하기 때문에 여러분들께서 꼭 익혀 두시면 좋겠습니다. 네 앞서 배웠던 아인 서메이션을 조금 더 우리가 심화적으로 한번 배워볼게요. 네 아인 썸 말고도 우리가 실제로는 오퍼레이션이라는 개념이 들어간 아이옵스를 이용해 주게 되면은 텐서 계산을 다루는 데 훨씬 더 직관적으로 사용할 수가 있게 됩니다. 그래서 이번 시간에는 이 두 가지를 같이 활용하는 연산들을 좀 다뤄보도록 하겠습니다. 먼저 첫 번째 예제입니다. 3차원 텐서의 각 성분별로 트레이스 값을 계산하는 공식을 여러분이 한번 만들어 보고 싶습니다. 트레이스 값이라는 건 뭐냐면은 어떤 행렬들이 있을 때 그 행렬들의 대각 성분의 합을 구하는 걸로 보실 수가 있는데요. 좀 더 정확한 정의는 이렇게 3차원 텐서들의 각 성분인 행렬들의 트레이스를 각각 구한 후에 3차원 텐서의 트레이스는 이 각각 행렬들의 트레이스 값으로 저장된 값을 정의할 수가 있겠죠. 즉 3차원 텐서는 뭐냐 하면 각 행렬들의 트레이스 값으로 저장된 배열 트레이스 값은 우리가 대각 성분들의 합이기 때문에 숫자이고 이 숫자로 이루어져 있는 배열은 우리가 벡터가 되는 것이죠. 그래서 3차원 텐서의 트레이스는 우리가 하나의 벡터가 나오게 될 텐데 이 트랜스 연산자를 가지고 실제로 계산해 보시게 되면은 우리가 이 넘파에서 어떻게 되는지를 좀 살펴볼게요. 만약에 이와 같은 3차원 텐서를 우리가 정리해 봤다고 하겠습니다. 참고로 이게 어 대괄호가 2개가 들어 있기 때문에 행렬처럼 보이시지만 사실 여기에 하나가 더 있기 때문에 이거 같은 경우는 실제로는 3차원 텐서입니다. 근데 이 3차원 텐서에 대해서 우리가 트레이스 값을 계산해 보시게 되면은 어 원래는 1 2 3 4로 이루어져 있는 행렬이기 때문에 1과 4를 더해서 5가 첫 번째 행렬의 트레이스 값이 되는 것이고 두 번째 행렬은 마이너스 1 마이너스 2와 마이너스 3과 마이너스 4로 이루어져 있는 행벡터로 이루어져 있어서 트레이스 값이 마이너스 1과 마이너스 4를 더한 마이너스 5가 돼야 됩니다. 즉 요 3차원 텐서의 트레이스 값을 계산하면 원래는 5 콤마 마이너스 5가 나와야 되는데 어 지금 이거 같은 경우에는 거꾸로 마이너스 2 콤마 마이너스 2가 나온 상황이네요. 네 어 좀 부정확하게 계산된 결과라고 보시면 되겠습니다. 자 그렇다면 이거를 우리가 어떤 식으로 좀 바꿔볼 수가 있을까요? 네 사실 트랜스 연산이라는 거는 이렇게 어떤 행렬이 주어져 있을 때 각 대각 성분의 합을 우리가 계산해 주는 연산이라고 보시면 되는 거니까 우리가 비 번째 행렬의 아아 번째 인덱스를 이 비 번째 값으로 보내주는 연산으로 우리가 정의를 할 수가 있어요. 무슨 말이냐면은 이 비 번째 행렬에 II 인덱스를 다 더하라라는 식으로 정의할 수가 있겠죠. 그러면 bii 인덱스를 b로 보내주는 연산을 해주게 되면은 이 i의 인덱스에 해당하는 연산들을 다 더해주게 되는 것이니까 b 번째 행렬에 II 인덱스에 있는 원소들을 다 더해주는 연산을 취해줘서 트레이스 연산을 수행해 주게 됩니다. 네 이 아이아 번째의 인덱스에 대해서 덧셈을 더해주는 게 원래 트랜스 연산자의 정의였기 때문에 이 연산을 실제로 수행하는 게 우리가 원하는 네 원래 연산이었다는 거를 기억하시면 좋겠습니다. 그래서 이와 같이 아인 썸을 가지고 여러분들께서 정의를 하시게 되면은 원래 앞서 계산했던 트레이스 계산이랑 달리 정확하게 트레이스 값을 계산할 수 있다라는 거를 살펴보실 수가 있게 됩니다. 즉 여러분들께서 트레이스 연산을 이렇게 수직적으로 표현할 수가 있고 각 b번째 행렬의 II 인덱스를 아인슈타임 서메이션 컨벤션을 이용해서 이와 같이 표현할 수가 있고 그 결과가 비번째 값이다라고 표현되는 거를 여러분들이 어 수학적으로 이렇게 쓰실 수 있다면은 우리가 아인슈타인 컨벤션을 이용해서 아인 썸을 이용해서 우리가 쉽게 정확하게 계산할 수가 있게 됩니다. 다른 예제를 한번 살펴보겠습니다. 이번에는 텐서들을 2차원으로 변한 후에 행벡터끼리 내적을 계산하고 싶은 예제입니다. 참고로 이 계산은요 여러분들이 나중에 트랜스포머 아키텍처를 구현하실 때 굉장히 많이 쓰시게 될 연산 중 하나입니다. 먼저 2차원으로 변환하는 함수를 우리가 생각할 때는 우리가 넘파이의 리쉐이프라는 함수를 쓰실 수가 있습니다. 굉장히 흔히들 쓰는 이제 함수인데요. 리쉐이프를 이용해 주게 되면은 어떤 텐서가 있을 때 그 텐서의 쉐이프를 우리가 원하는 방향으로 우리가 원하는 어떤 모양으로 변환을 시킬 수가 있게 됩니다. 근데 이 리쉐이프 연산을 하려면은 이 원래 텐서들의 모양이 어떤지를 기억을 해야 되고요. 그리고 변환하고자 할 때 정확하게 그 구성 성분들의 개수가 일치해야 되기 때문에 즉 모양을 바꾸는 것이지 구성 성분의 값을 버리는 건 아니라서 리쉐이프를 할 때 정확히 구성 성분의 개수가 몇 개인지를 알아야 됩니다. 어 근데 이게 이제 구현하시다 보면은 이 텐서들의 차원이 얼마였더라라는 걸 기억하기가 쉽지 않은 경우가 있어서 일일이 따라가면서 값을 이렇게 그 디버깅하면서 추적을 해야 되는데요. 리세이프 연산을 쓰지 않고 앞서 소개해 드렸던 아인 오피스 즉 아인 오퍼레이션의 리어레인지 함수를 쓰시게 되면은 텐서의 모양을 정확하게 알지 않아도 우리가 추상적으로 이렇게 리쉐이프를 구현할 수가 있게 됩니다. 구체적으로 좀 살펴보면요. 이 텐서 같은 경우에는 4차원 텐서로 이루어져 있다고 하겠습니다. BI JK 4개의 인덱스로 이루어져 있는 네 4차원 텐서라고 가정하겠습니다. 이때 2차원으로 변환할 때 어떤 기준으로 변환하냐면요. 맨 앞에 있는 b라는 인덱스는 두고 그대로 두고 ijk 인덱스를 모두 묶어서 하나의 즉 두 번째 2차원으로 변할 때 두 번째 차원에 해당하는 인덱스들로 모두 묶고 싶은 것입니다. 즉 아라는 인덱스가 가질 수 있는 경우의 수와 제이라는 인덱스가 가질 수 있는 경우의 수와 케라는 인덱스가 가질 수 있는 경우의 수를 모두 곱해서 이 두 번째 차원에다가 다 묶어서 표현하고 싶은 거죠. 그럼 이거를 어떻게 해줄 수 있냐면요. 이와 같이 가로로 묶어주게 되면은 이렇게 4차원 텐서를 비 인덱스는 그대로 두고 아제케 인덱스를 묶은 이 2차원 인덱스로 하나로 묶어서 우리가 쉐입을 변환할 수가 있게 됩니다. 정확하게 리쉐이프 함수를 구현할 수가 있다는 것이죠. 그리고 행배터끼리 내적을 계산하고 싶은 거니까요. 우리가 앞에서 썼던 MP 이너를 써도 되지만 사실 아인 썸을 이용을 해서 BI랑 BI를 곱해서 우리가 비로 표현한다. 즉 b 번째 인덱스의 i번째 구성 성분과 비 번째 인덱스의 아이 번째 구성 성분끼리의 성분 곱을 해가지고 계산해 준다라는 게 우리가 실제로 2차원 어레이의 내적이죠. 네 이거를 계산했을 때 결과값은 비 번째 인덱스의 값을 계산하는 것이니까 아 비아와 비아끼리 곱해서 비가 나온다라고 이렇게 아인슈타임 포메이션 컨벤션으로 표현할 수가 있게 됩니다. 참고로 이때 나오는 스비아랑 와비아는 리세이프 된 2차원 텐서들을 쓰면 되는 것이죠. 네 그래서 우리가 수식으로 써주게 되게 되면은 이렇게 리어레인지 함수를 두 번 써주고 그다음에 아인썬 함수를 이용해서 우리가 최종적으로 2차원 텐서로 변한 후에 행벡터끼리 내적을 계산하는 게 가능해지게 되는 것입니다. 마지막 예제입니다. 이번에는 4차원 bijc 텐서를 3차원 비케씨 텐서로 변환한 후에 케 인덱스에 대해 내적 계산을 한 후 네 비 인덱스 별로 평균값을 구하고 싶다라는 연산입니다. 네 좀 몇 개를 꼬아 놨죠? 네 여러분들께서 아인 썬과 아인노스의 친해지기 위해서 제가 문제를 좀 꼬아봤습니다. 근데 이런 연산들이 실제로 여러분들이 딥러닝 구현을 하실 때 꽤 많이 쓰이는 연산이라서 지금부터 익숙해지시는 게 굉장히 필요해집니다. 먼저 비아드시 텐서를 비케씨 텐서로 바꾸는 게 필요하겠죠. 이거는 앞에서 배웠던 아이노스의 리어레인지 함수를 쓰시면 될 거고요. 그다음에 BKC 텐서로 바꾼 거를 케 인덱스에 대한 내적 계산을 하는 거는 우리가 비랑 씨를 남겨두고 케에 대해서 내적 계산을 하는 것이니까 결과값이 b씨가 되겠습니다. 그러면은 아인슈타인 컨벤션 연산이 어떻게 되는지를 한번 상상해 보실 수가 있겠죠 BKC랑 BKC를 받아서 BC로 보내는 연산이 되겠습니다. 그리고 마지막으로 그렇게 계산된 거를 기준으로 평균값을 구현하는 것이 미션입니다. 하나씩 한번 해볼게요. 먼저 bijc 텐서를 BKC 텐서로 변환해 줘야 되니까 BC는 그대로 두고 아제를 케로 묶어주는 리어레인지 연산을 취해 줍니다. 그래서 비아제 연산을 아이랑 제를 묶어서 케이로 바꿔주는 연산을 취해 주게 되면은 이렇게 스랑 와를 각각 리쉐입을 할 수가 있게 되고요. 이렇게 리쉐이프를 해 주게 된 3차원 텐서들을 다시 가져와서 이번엔 케 인덱스에 대한 내적 계산을 수행해 주면 됩니다. 그러면 BKC와 BKC를 BC로 보내는 내적 연산을 해주면 되는 것이죠. 이때 ij를 k로 묶었다라는 사실을 기억해 두시고요. 그러면은 BKC니까 BKC가 되는 것이고 여기서 두 번째 텐서에서도 c 프라임을 다시 이 ij에 묶어서 k로 가져오게 되는 것이겠죠. 그랬을 때 이 두 연산들을 묶어서 비씨로 이렇게 묶어주시게 되면은 위에서 설명드린 대로 케 인덱스 별로 우리가 내적 계산을 수행할 수가 있게 됩니다. 그리고 마지막으로요 우리가 해주고 싶은 거는 비 인덱스 별로 평균값을 계산해 주는 것인데 이 경우에는 넘파이 민을 쓰셔도 되지만 넌 파이 민을 쓰시는 경우에는 액세스를 여러분이 설정을 해 주셔야 정확하게 나오게 되는데 어 우리가 아이노스의 안에 들어 있는 리듀스 함수를 쓰시게 되면은 우리가 평균값 계산하는 데 쓸 수가 있습니다. 자 그래서 앞서 계산했던 지라는 네 어 텐서를 가져오고요. 참고로 이 텐서는 비랑 씨라는 인덱스로 이루어져 있는 행렬인데 이 b랑 c라고 이루어져 있는 이 인덱스를 비 인덱스 별로 평균값을 구하는 것이니까 비는 고정시켜두고 세를 움직이면서 이렇게 평균을 계산하는 오퍼레이션을 취해 주면 되겠죠. 그러면 비 씨를 받아서 이렇게 비로 보내주는 네 아인슈타인 서메이션 컨벤션을 취해 주고 리듀스에서 미이라는 어 리듀스 방식을 취해주고 싶은 거니까 미니라는 옵션을 이렇게 넣어주면은 어 우리가 평균값을 계산하는 데 쓸 수가 있습니다. 그래서 이렇게 리얼 레인지랑 아인서메이션이랑 그리고 리듀스 기능을 쓰면은 어려워 보이는 텐서 연산들도 우리가 좀 손쉽게 어 좀 가독성 있게 실제로 좀 표현을 해 볼 수가 있고 이렇게 하게 되면은 좀 더 효율적으로 코드에 대해서 관리도 할 수 있고 해석도 할 수가 있게 되는 것입니다. 네 어 그래서 실제로 이렇게 리어레인지랑 아이 썸을 이용해 가지고요. 어 한번 그 위에서 보여드린 예제 3번의 연산을 한번 수행해 보시는 건데 어 여러분들께서 한 가지 조금 유념하실 거는요 이 아이노스의 리듀스 연산을 사용하실 때에는 데이터 타입을 명시해 주시는 게 좀 필요합니다. 즉 다시 말해서 이 아이노스 리듀스 연산을 사용하기 전에 여기 보시면 아인 섬 연산에서 데이터 타입을 플롯으로 바꿔주는 좀 어 기능을 했는데요. 이걸 해줘야만 좀 아이노스 리듀스 연산이 좀 동작을 하기가 좀 편하기 때문에 여러분들께서 텐서 연산을 다루실 때 넌 파이의 경우에는 이런 데이터 타입을 조금 신경 써서 구현하시는 거를 기억해 두시면 되겠습니다. 그래서 실제로 넌 파이로 구현된 연산이랑 아이옵스로 구현된 연산이랑 한번 구현을 해 보시면 같은 결괏값이 나온다라는 거를 여러분이 비교를 해볼 수가 있겠습니다. 네 이것으로 텐서에 대한 강의를 마치도록 하겠습니다. 이번 시간까지 리뉴얼 제브라 선형 대수에 대한 벡터 행렬 그리고 텐서에 대한 거를 배워봤는데요. 이제 다음 시간부터는 리뉴얼 제브라를 떠나서 딥러닝 최적화에 쓰이게 되는 경사 하강법에 대해서 공부해 보도록 하겠습니다. 수고하셨습니다."
}