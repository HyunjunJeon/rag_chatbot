{
  "lecture_name": "(실습 01) Adding Conditional Control to Text-to-Image Diffusion Models",
  "source_file": "(실습 01) Adding Conditional Control to Text-to-Image Diffusion Models_59.mp4_2025-12-04-103640779.json",
  "text": "안녕하세요. 이번 CV 리센스 트레인드 실습 1 조교를 맡은 신상훈이라고 합니다. 이번 시간에 실습해 볼 논문은 에딩 컨디셔널 컨트롤 2 텍스트 투 이미지 디퓨전 모델 쓰라는 논문입니다. 세간에서는 이제 컨트롤넷이라고 불리는 논문인데 화제가 되어서 컨트롤넷을 한번 실습해 보도록 하겠습니다. 이번 시간의 실습 개요는 다음과 같습니다. 컨트롤넷에 대해 알아보고 컨트롤넷 깃허브 코드를 실행시켜보고 디퓨저 라이브러리를 통해서도 구현해 보도록 하겠습니다. 실습 수행으로 얻어갈 수 있는 역량은 다음과 같습니다. 컨트롤 넷을 베이스 코드 레벨에서 구현해 볼 수 있다. 디퓨저 라이브러리를 통해서 디퓨전 모델을 구현할 수 있다. 디퓨 라이브러리를 통해서 스테이블 디퓨전 컨트롤넷을 구현할 수 있다. 실습 진행 목적 및 배경은 다음과 같습니다. 최근 화제가 되고 있는 컨트롤넷을 활용한 여러 가지 실습을 통해 모듈을 다루는 데 익숙해지고 자기의 과제에 능숙하게 활용할 수 있게 실습을 진행합니다. 먼저 컨트롤 넷을 알아보기 위해 스테이블 디퓨전을 잠시 보고 가도록 하겠습니다. 스테이블 디퓨전은 텍스트 투 이미지 모델로 레이턴트 디퓨전 모델을 기반으로 대용량의 학습 데이터를 학습한 모델입니다. 먼저 레이턴트 디퓨전의 논문은 다음과 같은데요. 하이레졸루션 이미지 시네틱스 w 레이턴트 디퓨전 모델 스라는 논문입니다. 레이턴트 디퓨전 모델이 나온 배경은 다음과 같은데 디퓨전 모델이 디퓨전 프로세스를 진행할 때 이미지 레졸루션이 유지되는 그런 단점이 있습니다. 유지되면 단점이 어떤 거냐면 이미지 크기가 크면 클수록 코스트가 많이 들고 이미지를 큰 레졸루션에서 프로세스를 진행하기 때문에 컴퓨터이셔널 포스트나 시간이 오래 걸린다는 단점이 있습니다. 그래서 논문의 컨트리뷰션은 다음과 같은데 먼저 픽셀 디멘전에서 어떤 인코더를 통해서 레이턴트 스페이스로 이미지를 매핑한 다음에 거기서 디퓨전 프로세스를 진행하는 것입니다. 그리고 크로스 어텐션이나 다양한 인코딩 모듈을 통해 컨디션을 줄 수 있다는 장점이 있습니다. 그래서 레이턴트 디퓨전이 이러한 것을 활용해서 최근 소타라고 불리는 스테이트 오브 디 성능이 가장 좋다는 뜻이죠. 그런 성능을 언컨디셔널 이미 제너레이션이나 여러 가지 테스크에서 달성했습니다. 먼저 레이턴트 디퓨전의 아키텍처는 다음과 같은데요. 먼저 x라는 어떠한 우리가 가지고 있는 이미지를 이 인코더를 통해서 이 z라는 레이턴트 스페이스로 매핑합니다. 이때 z는 이 x보다 레졸루션이 낮을 것입니다. 그리고 여기서 디퓨전 프로세스를 이렇게 쭉 진행을 하고 디코더를 통해서 원래의 픽셀 스페이스로 돌아옵니다. 이때 보는 픽셀 스페이스에 돌아온 스가 우리가 보는 이미지랑 같다고 생각하시면 됩니다. 그리고 여기서는 타우 세터를 통해서 어떠한 컨디셔닝 모듈을 통해서 이 크로스 어텐션에 컨디션을 줄 수 있는데요. 우리가 만들기에 따라서 다양한 컨디션을 줄 수 있다는 장점이 있습니다. 먼저 디퓨전 모델의 로스 펑션은 다음과 같습니다. 기본적으로 DDPM과 거의 유사한 것을 따르는데요. 이 제티라는 게 원래 DDPM에서는 xt라고 생각하시면 됩니다. 그래서 별 차이점이 없다고 말할 수 있겠습니다. 이제 컨트롤넷 논문으로 돌아와서 에딩 컨디셔널 컨트롤 투 텍스트 2 이미지 디퓨전 모델 스가 이 컨트롤 넷의 논문 제목입니다. 백그라운드는 다음과 같은데요. 스테이블 디퓨전이 대용량의 이미지를 학습했기 때문에 이 모델의 파워를 사용하는 데 관심이 커져 왔습니다. 그런데 처음부터 학습시키기에는 학습 시간도 오래 걸리고 그만한 장비나 여러 가지 코스트가 많이 듭니다. 그래서 이 스테이블 디퓨션에 웨이트를 사용해서 그대로 모델의 파워를 사용해서 원하는 컨디션을 주고 우리가 원하는 방향으로 생성하기를 원했던 관점에서 이런 논문이 나오게 되었는데요. 컨트리뷰션은 다음과 같습니다. 이 제로 콤블루션을 사용해서 이 프리트레인드 모델의 웨이트를 사용하면서 웨이트에는 영향을 주지 않는 그런 방법을 고안해 냈고요. 그래서 프리트레인드 모델부터 학습을 할 수 있고 결국에는 그 파워를 사용할 수 있게 됩니다. 그러면 우리는 이미지를 많이 학습하지 않아도 스테이블 디퓨전에서 엄청난 양의 데이터로 학습을 했었기 때문에 그 파워를 살리면서 우리의 테스크에 맞게 모델을 변형시킬 수 있는 것입니다. 그래서 이 논문은 이제 컨트롤넷이라는 모듈을 소개를 하는데 컨트롤넷은 이런 식으로 케니 엣지 맵이나 휴먼 포즈나 이러한 컨디션을 줬을 때 이런 식으로 이 컨디션과 유사한 리얼리스틱한 이미지를 만들어 낼 수 있습니다. 물론 스테이블 디퓨전이 이제 텍스트 투 이미지 모델이기 때문에 이러한 텍스트 컨디션도 줄 수 있는 것입니다. 그리고 케니 맵이나 아까 보았던 휴먼 포즈와 거기에 추가를 해서 뎁스 맵이라든지 세그멘테이션 맵 등 학습시키기에 따라서 원하는 컨디션을 줄 수 있게 됩니다. 그래서 아까 말씀드렸듯이 컨트롤넷의 키 컨트리뷰션은 이 제로 콤블루션입니다. 제로 콤블루션은 바이어스와 웨이트가 처음에 제로로 이니셜라이즈 돼 있는 컨볼루션이라고 생각을 하면 되시고 이것을 통해서 이전에 이미 학습된 프리트레인드 모델의 웨이트를 건드리지 않으면서 거기서부터 추가로 원하는 방향으로 학습할 수 있게 해주는 것입니다. 사실 컨트롤 넷은 여러 가지 이제 프리 트렌드 디퓨저 모델에 적용을 할 수 있지만 최근 가장 유명한 스테이블 디퓨전에 적용을 해서 많이 쓰이고 있고요. 다음과 같이 이제 에가 스테이블 디퓨전의 모델 구조입니다. 백번 모델 유닛 모델 구조이겠죠 그래서 컨트롤 넷은 이 위에 미들 위에 부분만 이제 똑같이 구성을 가져가고 밑에는 제로 컨볼루션을 추가를 해서 모델을 학습할 수 있게 도와줍니다. 그리고 이것은 컨트롤넷의 결과입니다. 다음과 같은 여러 가지 컨디션을 통해서 이렇게 원하는 방향으로 이미지를 생성할 수 있게 하는 것입니다. 이제 실습 코드를 한번 다뤄봐야 되는데 그전에 이 PPT 슬라이드를 통해서 코드의 구성을 한번 보고 가도록 하겠습니다. 이번에 실습한 파일은 컨트롤 n 깃허브 안에 있는 라디오 DP스트 이미지 점 py라는 파일을 저희가 실습해 볼 건데요. 다른 여기 있는 파일도 비슷한 형식으로 이루어져 있고 이제 실습하는 것을 통해서 비슷하게 활용을 하시면 될 것 같습니다. 그래서 먼저 필요한 라이브러리를 인폴트 하게 됩니다. 이렇게 저희가 필요한 라이브러리를 먼저 불러오고 이제 라이브러리를 인폴트 했으면 밑에 다음과 같은 코드가 있습니다. 먼저 한 줄씩 보면 어플라이 마이더스는 뎁스 맵을 만들기 위한 모듈입니다. 그리고 모델은 크리에이티브 모델을 통해서 웨이트가 이니셜라이즈 된 모델을 생성합니다. 이 모델이 어떤 웨이트를 담을 수 있는 틀을 제공한다고 보시면 되고, 이 틀에 들어가는 하이퍼 파라미터는 시엘디앤브15 야몰 파일을 통해서 모델에 전달해 주게 됩니다. 그리고 모델의 로드 스테이트 딕트를 통해서 학습된 웨이트를 불러오고요. 그리고 모델을 GPU 연산을 가능하게 이제 크다 이런 식으로 지정을 해줍니다. 디퓨전 모델에는 그리고 여러 가지 샘플러가 있는데 ddim을 통해서 샘플링하게 다음과 같은 방식으로 정해주게 됩니다. cldmv15.0몰 파일을 보면 다음과 같은 내용이 있는 것을 확인할 수 있습니다. 이 야몰 파일의 목적은 우리가 하이퍼 파라미터를 모델에 전달하는 것인데요. 다음과 같이 지정된 파라미터들이 모델에 들어가게 되는 것입니다. 타겟을 보면 파일의 위치가 나오는데 베이스가 되는 모델은 씨엘디엠 폴더 안에 씨엘디엠 피와 안에 클래스 컨트롤 엘디엠이 되는 것을 알 수 있겠습니다. 다음과 같은 주소를 통해서 모델을 찾아가시면 됩니다. 그리고 앞선 모델 안에 파람스 부분에서 컨트롤 스테이지 컴피그, 유닛 컴피그, 펄스테이지 컴피그 이런 다양한 컴피그 파일이 있는데요. 모두 컨트롤 알디엠을 구성하는 요소입니다. 각 컴피그를 보면 다시 타겟이 되는 네트워크들이 있는데 다시 각각의 모델을 구성하는 하이퍼 파라미터입니다. 그래서 컨트롤 엘디엠을 실행하기 위해서는 여러 가지 네트워크들이 필요한 것을 알 수 있습니다. 그래서 컨트롤 LDM을 보면 레이턴트 디퓨저 클래스를 상속받는 것을 알 수 있는데 앞단의 야물 파일에서 컨트롤 LDM으로 전달되는 것을 보면 컨트롤 스테이지, 컴피그 컨트롤, 키, 올리미드 컨트롤 등이 있는데 이 하이퍼 파라미터들이 전달되는 것을 알 수 있습니다. 이 부분인데 앞서 이 컨트롤 넷에 이런 파라미터들이 들어가게 되는 것이겠죠. 근데 이제 보시면 앞서 본 것이 이제 컨트롤 LDM에서 모든 파라미터를 받지 않고 상속된 클래스에서 받는 것을 알 수 있습니다. 그래서 레이턴트 디퓨전을 다시 보면 DDPM 클래스를 상속받는 것을 알 수 있습니다. 그런데 레이턴트 디퓨전에서 전달받지 않은 그러한 파일들이 여전히 보일 것입니다. 이런 것들은 다시 DDPM 클래스를 찾아가 보시면 확인하실 수 있을 것입니다. 그리고 이제 아까 그라디오 데스트 이미지 ppy의 컨트롤넷을 실행시켜주는 게 이 프로세스 펑션인데 프로세스 펑션은 다음과 같은 인풋을 받습니다. 하나씩 찾아보면 인풋 이미지는 입력 이미지, 여기서는 뎁스 맵을 얻을 이미지를 뜻합니다. 프롬폼트는 우리가 원하는 방향으로 바꾸길 원하는 텍스트 디스크립션입니다. 그리고 에 프롬폼트는 에디드 프롬폼트 예를 들어서 베스트 퀄리티 익스트리미 디테일 등 그런 프롬트가 있을 것입니다. 그리고 엠 프롬폼트는 negative 프롬폼트 이미지 생성에 좋지 않은 텍스트 예를 들어서 워스트 퀄리티, 로우 퀄리티 등이 있겠습니다. 그리고 넘 샘플 스는 샘플링할 이미지 수이고, 이미지 레졸루션은 이미지의 크기, 디텍트 레졸루션은 뎁스, 웹의 크기, ddim 스텝스는 ddim의 스텝스, 그리고 게스 모드는 컨트롤넷의 게스 모드를 켤지 말지를 지정합니다. 스트렝스는 컨트롤넷 아웃풋의 영향력, 스케일은 클래식 파이어 프리 가이던스의 스케일, 시드는 랜덤 시드 그리고 에타는 ddim의 에타입니다. 그래서 빨간색 박스를 보시면 이미지를 모델에 넣기 위해 전처리해 주는 과정입니다. 어플라이 마이더스를 통해 인풋 이미지에서 dept 맵을 추출합니다. 그리고 노란색 박스를 보시면 디텍티드 맵의 사이즈를 바꿔주고, 컨트롤은 디텍티드 맵을 모델에 넣어주기 위해 텐서로 바꾸고 차원을 h블씨에서 ch블로 바꿔줍니다. 그 외에 시드는 우리가 이미지를 생성할 때 시드마다 다른 결과가 나오기 때문에 랜덤으로 지정을 해주고, 생성 결과가 같기를 원하면 시드를 고정해 주시면 됩니다. 세이브 메모리는 메모리를 절약하고 싶을 때 사용합니다. 그래서 프로세스 펑션 안을 보면 펀드는 모델의 줄 컨디션을 의미한다. c 컴켓은 모델의 줄 컨트롤 예를 들어서 뎁스, 맵, 케니, 엣지 등등이 있고, c 크로스 어텐션은 크로스 어텐션의 줄 컨디션, 보통 텍스트를 클립 텍스트 인코더를 통해서 변환 후 컨디션으로 주게 됩니다. 언컨드는 클래식 파이어 프리 가이던스에 사용되는 컨디션이고요. 쉐이프는 디퓨전 모델을 적용할 텐서의 쉐이프 8로 나누는 이유는 스테이블 디퓨전이 원본 이미지를 레이턴트 스페이스로 매핑하기 때문입니다. 그래서 모델 컨트롤 스케이스는 모델 스케이를 지정을 해주고 샘플스 인터미디어츠는 디디아엠 샘플에서 나온 결과물, 여기서는 아직 레이턴트 디멘전에 있다고 볼 수 있습니다. 그리고 스 샘플 스는 디코더를 통해서 나온 샘플 우리가 실제로 얻는 이미지입니다. 리턴으로 뎁스 맵과 결과물 이미지를 얻습니다. 밑에 그레디오 코드는 웹에서 간단하게 코드를 실행시키기 위한 툴이라고 이해하시면 될 것 같습니다. 그리고 우리가 이제 방금은 코드 레벨에서 좀 완전 디테일하게 알아봤는데 여기서는 디퓨저 라이브러리를 통해서도 컨트롤 넷을 구현해 보도록 하겠습니다. 디퓨저는 이미지 오디오 등 스테이트 오버 디 알트 프리트레인드 디퓨저 모델을 쉽게 이용할 수 있는 라이브러리입니다. 또한 간단한 인플런스와 트레인을 제공합니다. 요약하자면 디퓨저스는 위에 둘을 제공하는 모듈러 툴 박스입니다. 한번 홈페이지에 가서 보시면 디퓨저스가 어떤 것을 제공하는지 보실 수 있을 것입니다. 먼저 튜튜 리얼을 나중에 코드로도 해보겠지만 알아보고 가겠습니다. 이렇게 다음과 같은 네 줄의 코드로 다음과 같은 이미지를 만들 수 있게 됩니다. 먼저 디디피엠은 디디피엠 파이프라인을 통해서 이 프레이 트레인드 모델을 이 디디피엠 파이프라인을 불러옵니다. 그리고 이미지는 이디피엠의 샘플링을 이제 엄청 축소해 놓은 거라고 보시면 되고 여기서는 스텝 25 스텝으로 이미지를 생성하겠다고 이해하시면 될 것 같습니다. 이렇게 간단한 네 줄의 코드를 통해 디퓨전 모델을 통해서 샘플링을 할 수 있게 해줍니다. 그런데 디퓨션 모델은 여러 가지 프로세스를 가지고 있어서 디테일한 부분을 바꾸고 싶을 수 있습니다. 예를 들어 샘플링이나 스케줄러를 바꿀 수도 있고요. 그래서 앞서 설명한 파이프라인을 좀 더 자세하게 쪼개 보도록 하겠습니다. 먼저 파이프라인은 유닛 2디 모델과 디디피엠 스케줄러를 가지고 있습니다. 유닛 2디 모델은 디퓨전 모델이 학습할 때 쓰는 네트워크이며, 디디피엠 스케줄러는 디퓨션 모델의 스케줄을 정해 준다고 생각하시면 될 것 같습니다. 이제 유닛 2D 모델과 DDPM 스케줄러를 통해서 앞선 파이프라인의 과정을 다시 구현해 보도록 하겠습니다. 먼저 모델과 스케줄러를 로드합니다. 그리고 진행할 타임 스텝의 수를 정합니다. 정의된 타임 스텝은 다음과 같이 찍어오면 볼 수 있습니다. 그리고 랜덤한 노이즈를 뽑고 디멘전을 정해 주고요. 여기서는 아까 256 모델을 불러와서 샘플 사이즈 바이 256으로 생각하시면 될 것 같습니다. 이제 아까 추출한 노이즈를 인풋으로 넣고 디퓨전 모델을 통해 디노이징 프로세스를 진행합니다. 기본적으로 디퓨저스 라이브러리는 이러한 프로세스를 비슷하게 따릅니다. 이제 디노이즈 된 이미지를 이미지로 변환하면 처음에 파이프라인을 사용한 방법과 동일한 프로세스를 따릅니다. 이제 똑같은 방식으로 화제가 되고 있는 스테이블 디퓨션에 적용해 보도록 하겠습니다. 앞서 말했듯이 스테이블 디퓨전은 레지턴트 디퓨전 모델이고요. 이미지를 레지턴트 스페이스로 매핑했다가 다시 픽셀 스페이스로 가져오는 방식을 따르고 있습니다. 그래서 위에 설명에서 보았듯이 우리가 스테이블 디퓨전을 사용하기 위해서는 앞서 실습해 본 디디피엠보다 더 많은 프리 트레인드 모델을 필요로 합니다. 먼저 이미지를 레이턴트 스페이스로 압축할 인코더, 그리고 스테이블 디퓨전이 텍스트 2 이미지 모델이기 때문에 텍스트 인코더도 필요합니다. 또한 앞서 DDPM에서 사용한 유넷 모델도 필요합니다. 먼저 다음과 같은 코드로 클립 텍스트 모델, 클립 토크나이저 오토 인코더, 케이엘 유닛 2디 컨디션 모델 피앤디앤 스케줄러를 임포트해 옵니다. 유닛 2디 컨디션 모델 피엠디엠 스케줄러는 기본적으로 앞선 디디피엠의 유넷 모델과 스케줄러와 같은 방식으로 사용됩니다. 오토 인코더 케이엘은 이미지를 레이턴트 스페이스로 매핑해 주는 인코더입니다. 브에라고 이름 짓는 이유는 인코더가 VA 방식으로 학습했기 때문입니다. 클립 토크나이저는 텍스트 프로 폰트를 벡터로 바꿔주고 클립 텍스트 모델은 텍스트를 모델에 넣어주기 위해 인코딩해주는 역할을 합니다. 그리고 기본적인 피엠디엠 스케줄러 대신 유니 피시 멀티스텝 스케줄러를 사용할 수 있습니다. 그리고 인퍼런스 습도를 높여주기 위해 모델들을 GPU로 옮겨줍니다. 이미지를 생성하기 위해 위와 같은 조건들을 정의해 줍니다. 프롬트는 작성자가 원하는 프론트를 적어 줍니다. 프롬트를 토크나이저를 통해 토큰으로 바꾸고 텍스트 인코더를 통해 텍스트 인베딩을 얻습니다. 패딩 토큰을 위한 언컨디셔널 인베딩도 얻습니다. 그리고 텍스트 인베딩을 컴켓 해줍니다. 이제 샘플링을 위한 랜덤 노이즈를 추출합니다. 그리고 유니 피시 멀티스텝 스케줄러를 위해 인풋을 스케일링 해 줍니다. 이제 앞선 디디피엠과 같이 노이즈를 디노이징 루프를 통해서 이미지로 변환합니다. 레이턴트를 다시 스케일링 해주고 난 후 디코더를 통해서 레이턴트 스페이스에서 픽셀 스페이스로 다시 이미지를 불러옵니다. 마지막으로 다시 이미지로 변환해 줍니다. 먼저 다음과 같은 주소에서 vs 코드를 다운받습니다. 저희가 이번 실습에서는 vs 코드랑 주피터 노트북을 사용해서 실습을 할 텐데요. 그래서 먼저 다운 받아 주시는 것을 권장드립니다. 그리고 서버를 접속을 해 볼 텐데 다음과 같은 명령어를 사용해서 접속을 합니다. 저희가 AI 스테이지 홈페이지에서 펌 파일을 다운받을 수 있는데 이 펌 파일을 이제 로컬 디스크 씨의 유저스에 저희가 사용자의 이제 에스치로 폰 파일을 먼저 이동시켜 놓습니다. 그리고 시드 명령어를 통해서 여기서 에스치로 접속해 보도록 하겠습니다. 여기에 들어와서 이제 홈 파일이 여기 있다는 가정을 하고 다음과 같이 세 줄의 명령어를 입력해 주시면 됩니다. 이렇게 하고 저희가 홈페이지에서 이제 IP 주소랑 포트를 할당을 받았을 텐데요. 이제 할당된 명령어를 통해서 엔터를 눌러주시면 다음과 같이 서버에 접속할 수 있게 됩니다. 그리고 다음 슬라이드로 넘어가서 다음과 같은 명령어들을 입력해 줍니다. 이거는 이제 깃허브에서 컨트롤 된 레퍼시스토리를 저희 주소로 불러오는 명령어입니다. 그래서 엘스 명령어를 쳐보면 컨트롤 넷이 다운 받아진 것을 볼 수 있고 CD 명령어를 통해서 컨트롤넷을 들어가 보도록 하겠습니다. 먼저 이제 컨트롤 넷에 들어가 보면 다음과 같은 파일들이 있는 것을 알 수 있습니다. 그래서 여기에 이제 세 번째 명령어를 입력해 줍니다. 그럼 이제 다운이 받아질 텐데요. 한번 기다려보도록 하겠습니다. 저희가 이제 다운받는 동안 vs 코드에 한번 접속해 보도록 하겠습니다. vs 코드에 접속하면 다음과 같은 화면이 나올 텐데요. 저희가 이제 익스텐션이라는 것을 통해서 리모트 sh를 받아줍니다. 이렇게 SSH를 치면 리모트 sh가 나오는데요. 이것을 사용하시면 됩니다. 그래서 접속을 한번 해보도록 하겠습니다. 이 버튼을 누르고 커넥터 호스트를 하고 컴퓨겨 SSH 그리고 다음과 같이 SSH 컴피그에 들어가면 다음과 같은 글이 있을 텐데요. 없으면 다음과 같이 입력해 주시면 될 것 같습니다. 그래서 이제 이 호스트는 이제 저희가 사용할 서버의 이름이라고 생각을 하시면 되고 아무렇게나 원하는 대로 지정하셔도 됩니다. 그리고 호스트 네임에는 IP 주소를 입력을 해야 되는데요. 저희가 AI 스테이지 홈페이지에서 할당받은 호스트 이름을 IP를 다음과 같이 넣어줍니다. 그리고 유저에는 루트 그리고 포트는 아까 할당 받으신 마이너스 p 뒤에 숫자를 입력하시면 됩니다. 이렇게 하고 컨트롤 s를 통해서 저장을 할 수 있습니다. 다음과 같이 이 호스트를 들어가면 보트라는 게 생성이 돼 있을 텐데요. 이것을 눌러줍니다. 조금 기다리면 다음과 같이 화면이 뜰 텐데요. 이렇게 연결이 돼 있는 것을 확인할 수 있습니다. 그리고 오픈 폴더를 통해서 저희가 아까 컨트롤 넷을 다운 받았잖아요. 그 폴더로 한번 가보도록 하겠습니다. 폴더 주소는 데이터에 이거에 이제 홈을 누르고 오케이를 누릅니다. 그러면 다음과 같이 접속이 된 것을 볼 수 있습니다. 이렇게 보면 컨트롤넷이라는 이런 폴더가 있을 텐데요. 그리고 터미널은 아까 우리가 보았던 CMD 창이라고 보시면 될 것 같습니다. 자 다음과 같이 다운이 완료가 되었습니다. 이제 브스 코드에서 보시면 다음과 같은 파일이 다운 받아져 있는 것을 볼 수 있는데요. 이것이 이제 프리트레인드 웨이트라고 생각을 하시면 되고 아까 저희가 라디오 데스트 이미지 PI를 사용한다고 했으니까 한번 보도록 하겠습니다. 아까 보셨듯이 다음과 같이 코드가 이루어져 있는 것을 볼 수 있습니다. 이것을 이제 한번 실행시켜 보도록 할 텐데요. 이 모델이 받는 주소를 보면 모델s 안에 컨트롤 ST DES ptho라고 되어 있는데 이름이 살짝 다르죠 한번 이름을 바꿔주도록 하겠습니다. pthda는 다 지워주도록 하겠습니다. 이렇게 됐고 모델스 안에 있었으니까 다음과 같이 넣어주시면 됩니다. 아니면 여기에서 주소를 바꿔주시는 방법도 있습니다. 이게 다음과 같은 부분에 주소를 바꿔주시면 될 것 같습니다. 그래서 이제 한번 파일을 실행시켜 보도록 하겠습니다. 여기 터미널에서 CD를 하고 컨트롤 넷으로 들어갑니다. 먼저 vs 코드를 사용하는 이유는 다음과 같이 이렇게 CMD로 접속했을 경우는 이 파일을 수정한다거나 보기가 vs 코드보다 불편합니다. 그래서 vs 코드를 사용하시면 다음과 같이 편하게 코드도 수정할 수 있고 다음과 같이 터미널에서 실행도 시킬 수 있습니다. 이제 파이썬을 하고 라디오 데스트 이미지 PI를 실행시켜 보도록 하겠습니다. 그러면 다음과 같은 창이 뜨면서 파일이 실행이 됩니다. 이제 필요한 파일들을 다운받아 주시는 과정이라고 생각하시면 될 것 같습니다. 자 이제 파일의 실행이 완료되었고 아까 보셨지만 여기서 파이썬 익스텐션도 여기서 찾아서 다운받아 주시면 좋습니다. 그래서 방금 오프닝 브라우저가 떴었는데 그걸 클릭하셔도 되고 URL을 복사를 하셔가지고 이제 인터넷 창을 켜서 다음과 같이 로컬 호스트를 누르시면 됩니다. 그 뒤에는 이제 vs 코드를 보시면 아시겠지만 이 포트 넘버가 7 860이라고 나옵니다. 다음과 같이 로컬 호스트 7860을 쓰면 웹에서 다음과 같이 접속할 수 있게 됩니다. 그러면 이제 데스트 이미지를 한번 실험을 해볼 텐데요. 먼저 컨트롤 넷을 한번 들어가 봅니다. 컨트롤 네키 터그인데요. 그러니까 PPT에 있는 주소를 통해서 접속을 하실 수 있습니다. 다음과 같은 주소를 인터넷에 치면 접속할 수 있습니다. 그래서 한번 쭉 내려보시면 다음과 같이 캐니에서 이미지로 아니면 헤드 투 이미지 여러 가지 파일들이 있죠 저희는 이제 댑스 투 이미지가 있으니까 실험을 해보도록 하겠습니다. 먼저 펌트를 한번 복사를 해서 다음과 같이 웹에 펌트를 쳐줍니다. 그래서 여러 가지 옵션들이 있는데요. 아까 프로세스에서 배운 그런 옵션들입니다. 여기서 이미지를 한번 찾아서 넣어볼 건데 저희가 똑같은 이미지를 사용하면 좋잖아요 그래서 보시면 여기에 테스트 이미지스를 들어가면 아까와 같은 이미지들이 있습니다. 그래서 여기 보시면 SD라는 이미지가 컨트롤은 홈페이지에서 사용한 이미지인데요. 이것을 통해서 vs 코드에서 다운로드를 누르면 저희가 다운을 받을 수 있습니다. 그래서 한번 다운을 받아보도록 하겠습니다. 이미지를 다운받으셨으면 다음과 같이 드래그 앤 드롭 할 수 있고요. lan을 하시면 이미지가 생성되게 됩니다. 그래서 vs 코드에 들어가 보면 다음과 같이 샘플링이 되고 있는 것을 알 수 있습니다. 다 된 것을 보실 수 있죠. 여기서 이미지를 2개로 한번 해보도록 하겠습니다. 여기서 런을 누르시면 다음과 같이 이미지가 2개 생성되는 것을 볼 수 있습니다. 자 여기서 컨트롤 c를 누르면 이것을 종료를 할 수 있고요. 이제 주피터 노트북을 통해서 실습을 해보도록 하겠습니다. 먼저 주피터 노트북을 사용하기 위해서 환경 세팅을 다시 해주셔야 되는데요. 주피터 노트북에서는 디퓨저를 사용할 거기 때문에 다음과 같은 명령어들을 입력해 줍니다. 여기서 똑같이 입력을 해 주시면 됩니다. 이제 pip 인스톨 주피터까지 완료를 하셨으면 주피터 노트북에 한번 접속해 보도록 하겠습니다. 지피터 노트북에 접속하기 위해서는 다음과 같은 명령어를 사용하면 되는데요. 여기서 포트 넘버의 넘버만 바꿔주시면 됩니다. 여기서 넘버를 저희가 홈페이지에서 할당받은 2개의 포트가 있을 텐데요. 그 둘 중 하나를 사용하시면 됩니다. 자 그러면 주피터 노트북이 실행된 것을 볼 수 있는데요. 복습하기 위해서 이 다음과 같은 주소를 복사를 하여 인터넷에 입력시켜 주면 됩니다. 여기서 이 부분을 저희가 할당받은 IP로 바꿔줍니다. 그럼 입력이 된 것을 주피터 노트북에 접속한 것을 보실 수 있으실 겁니다. 그래서 여기서 파이썬 3를 열어줍니다. 먼저 아까 PPT에서 배운 디퓨저를 간단하게 실습해 보도록 하겠습니다. 다음과 같이 명령어를 입력을 하고요. 그리고 시프트 엔터를 통해서 실행시켜주도록 합니다. 먼저 DDPM 파이프라인을 이제 프리트레인드 모델을 통해서 불러오고요. 그리고 25개의 스텝을 통해서 이미지를 생성하게 됩니다. 그리고 이제 세세하게 다시 아까처럼 보도록 하겠습니다. 이제 스케줄러와 모듈을 저희가 다음과 같은 명령어로 지정을 해 줄 수 있습니다. 그리고 타임 스텝을 지정해 줍니다. 타임 스텝을 한번 찍어볼 수 있는데 한번 입력을 해보면 다음과 같이 나오는 것을 볼 수 있습니다. 그리고 이제 다음과 같은 명령어를 통해서 랜덤한 노이즈를 생성해 줄 수 있는데요. 입력을 하시면 입력이 되고 샘플 사이즈를 한번 보시면 256인 것을 알 수 있습니다. 저희가 아까 256 모델을 사용했기 때문에 256인 것을 알 수 있고 노이즈를 찍어 보시면 다음과 같이 이러한 텐서가 생성되는 것을 볼 수 있습니다. 노이즈의 셰이프를 한번 보시면 다음과 같이 1 바이 3 바이 256 바이 256이 인 것을 볼 수 있습니다. 그리고 이제 이 과정을 통해 샘플링을 해보도록 하겠습니다. 자 샘플링이 완료되었고 이 인풋이 이제 이미지 샘플링된 이미지를 센서로 만들어 놨는데요. 이것을 다시 전처리를 통해서 이미지로 바꾸면 다음과 같은 이미지가 생성된 것을 볼 수 있습니다. 그리고 이제 스테이블 디퓨전을 한번 다시 간단히 실습을 해볼 텐데요. 아까 보셨듯이 저희가 v에 토크나이저 텍스트 인코더 유닛 모델을 이제 가져오는 것을 볼 수 있습니다. 입력을 하시면 이렇게 지정이 되고 이제 스케줄러를 한번 지정해 보도록 하겠습니다. 여기서는 유니 피시 멀티스텝 스케줄러를 사용하겠습니다. 그리고 터치 디바이스를 코다로 지정을 해주고 이 아까 블로어 모델들을 GPU에 넘겨줍니다. 그리고 이제 프론트와 이미지의 레졸루션 그리고 스텝 수 가이던스 스케일 제너레이터 이거는 시드를 지정해 준다고 생각하시면 됩니다. 그리고 배치 사이즈를 정해주고 실행을 시켜줍니다. 그리고 이제 텍스트 인풋과 토크나이저를 통해서 텍스트 인풋을 만들고 이제 텍스트 인풋을 인코더를 통해서 텍스트 인베딩을 만듭니다. 그리고 클래시파이어 가이던스를 통한 언컨디셔널 인베딩도 지정을 해주고요. 그래서 텍스트 인베딩을 다음과 같이 지정해 줍니다. 그리고 아까 DDPM과 같이 이렇게 랜덤한 레이턴트를 저희가 만들어 줍니다. 여기서 디바이스에서 에러가 나는 것 같은데 그러면 이렇게 지워주시고 레이턴트를 따로 쿠다로 다시 올려줍니다. 그리고 레이턴트를 스케일에 맞춰주고 이제 샘플링을 해보도록 하겠습니다. 다음과 같은 명령어를 통해서 샘플링을 진행합니다. 그리고 디코더에 넣기 위해 스케일링을 다시 해주고요. 디코더에 넣고 이미지를 전처리하면 다음과 같은 그림이 나오게 됩니다. 그러니까 여기서 포 아스트로넛 라이딩 어 홀스라는 홈트를 넣어서 다음과 같은 그림이 나온 것을 볼 수 있습니다. 자 이제 본론으로 들어가서 컨트롤 넷을 한번 실습해 보도록 하겠습니다. 저희가 케니 엣지 맵을 먼저 실습을 해볼 건데요. 제가 드린 실습 파일 안에 이런 코드가 있는데 이 주소를 바꿔줘야 됩니다. 이 주소를 어떻게 하냐면 아까 저희가 vs 코드를 사용을 했었잖아요. 여기 테스트 이미지를 가져올 텐데 저는 이 버드라는 이미지를 통해서 한번 해보도록 하겠습니다. 여기서 카피 패스라는 게 있는데 카피 패스를 누르고 입력을 해 주시면 이제 코드가 실행되는 것을 볼 수 있고 여기서 이미지를 가져와서 저희가 오리지널 이미지를 불러와서 MP 어레이로 넘 파이로 바꿔주고 쓰레시 월드를 주고 이미지를 통해서 케니를 바꾸고 그리고 이 케니로 바뀐 이미지를 전처리를 해 주시면 저희가 케니 이미지를 얻을 수 있게 됩니다. 여기서 컨트롤넷 모델을 통해서 컨트롤넷을 한번 불러와 볼 텐데요. 파이프라인은 설명드린 거랑 거의 비슷합니다. 먼저 컨트롤넷이 케니에 대해서 프리트레인드 된 모델을 불러오고 스테이블 디퓨전 파이프라인을 한번 불러오도록 하겠습니다. 스테이블 디퓨전 버전 1.5를 사용한다는 것을 알 수 있고요. 최근에 배포된 다른 모델들도 사용해 보실 수 있습니다. 그리고 스케줄러로는 유니 피싱 멀티 스텝 스케줄러를 사용했습니다. 이제 파일들이 다운 받아지고 있는데요. 다시 드림 코드를 통해서 한번 캐니 맵을 출력해 보도록 하겠습니다. 이렇게 해니 맵이 나온 것을 볼 수 있고요. 이것을 통해서 불러온 파이프라인을 통해서 코드를 입력을 하면 저희가 50 스텝으로 지정을 했기 때문에 이렇게 50 스텝을 거치는 것을 볼 수 있고요. 아니면 스텝 수를 바꿔주실 수 있습니다. 여기서 저희가 프롬트로 이글을 넣었기 때문에 이 케니에 대한 독수리 모양의 이미지가 출력된 것입니다. 저희가 스텝 수는 아까 지정은 안 한 것 같은데 기본 스텝이 50이라 아까 제가 설명드린 부분을 이제 스텝 수를 원하시는 스텝을 입력을 하시면 샘플링을 원하시는 스텝으로 할 수 있습니다. 다시 프롬트를 바꿔서 이번엔 라이온을 한번 입력해 보도록 하겠습니다. 이제 사자가 나온 것을 볼 수 있고요. 여기 원하는 프론트를 바꿔가면서 실험을 해보시는 것을 추천드립니다. 그리고 이번에 다시 뎁스 맵을 실험을 해볼 텐데요. 아까 여기 주소를 저희가 아까 vs 코드에서 바꿀 수 있었죠 제가 가서 스디에서 커피 패스를 통해서 한번 입력시켜 보도록 하겠습니다. 이거는 이제 이미지를 뎁스 맵으로 바꿔주는 펑션이고요. 뎁스 에스미트를 불러오고 그리고 겟 뎁스 맵을 통해서 뎁스 이미지를 얻습니다. 그리고 똑같이 여기에 이제 댑스 모델을 불러오는데요. 다른 부분은 동일하다고 보시면 될 것 같습니다. 불필요한 것을 다운받아 주고 이제 샘플링을 진행해 보도록 하겠습니다. 여기서 이제 아까 SD 이미지 봤었잖아요. 거기서 레고 배트맨이라는 프론트를 통해서 변환을 시켜보면 어떻게 되는지 보겠습니다. 레고와 배트맨이 적용되는 것을 볼 수 있겠습니다. 그리고 픽사를 통해서 한 번 더 샘플링 해보도록 하겠습니다. 이제 픽사가 적용된 이미지가 나오시는 것을 볼 수 있습니다. 그리고 이번에는 인페인팅 모델을 통해서 한번 실험을 해볼 텐데 인페인팅은 어떠한 마스크가 있을 때 이 부분을 채워주는 것입니다. 인페인팅 컨디션을 이제 전처리해 주는 그런 펑션이라고 생각을 하시면 되고 인페인팅 모델을 로드해 보도록 하겠습니다. 여기서 인페인트로 돼 있는 것을 알 수 있고 여전히 스테이블 디퓨전 버전 1.5를 쓰는 것을 알 수 있습니다. 그래서 이제 텍스트를 다음과 같이 주고 생성을 해보면 이 세 번째와 같은 이미지를 얻은 것을 알 수 있는데 이제 코기 페이스에 귀가 큰 그리고 디테일한 픽사 그리고 애니메이티드 디즈니를 하면 여기에 배트맨 부분에 마스크를 씌우고 그 부분을 다음과 같이 코기로 채운 것을 볼 수 있습니다. 그리고 인플런스 탭을 아까는 20을 했는데 여기서는 50을 해보겠습니다 하면 조금 바뀌는 것을 보실 수 있습니다. 그리고 이제 스테이블 디퓨전 엑셀이라고 이제 다른 새로운 버전의 스테이블 디퓨전을 통해서도 한번 실행시켜 보도록 하겠습니다. 여기서는 디퓨저 라이브러리의 로고를 이제 캐니 웹으로 바꾼 건데요. 앞서 캐니 웹을 할 때 쓰던 코드는 동일하고 이제 바뀌는 부분은 불러오는 웨이트가 다르겠죠. 그래서 SD엑셀이랑 스테이블 디퓨전 엑셀 베이스 1.0 모델을 한번 불러와 보도록 하겠습니다. 그리고 프롬트에 슈퍼맨 베스트 퀄리티 익스트리미 디테일 등 프롬트를 넣고 로우 퀄리티 배드 퀄리티 스케치라는 우리가 제외하고 싶은 프롬트를 negative 프롬트로 넣습니다. 그리고 실행을 한번 시켜보도록 하겠습니다. 일단 필요한 것들이 다운이 받아지고 있습니다. 필요한 파일들이 다 다운 받아졌고요. 이제 샘플링을 해보도록 하겠습니다. 다음과 같은 샘플링을 통해서 이미지를 뽑을 수 있는데 어떻게 나오는지 한번 보시죠. 슈퍼맨 베스트 퀄리티 익스트리미 디테일 등을 넣었을 때 다음과 같은 이미지가 나온 것을 볼 수 있습니다. 이상으로 실습 원을 마치도록 하겠습니다. 감사합니다."
}